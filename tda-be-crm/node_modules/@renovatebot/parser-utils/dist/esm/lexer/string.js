import { getCounterpartBracketKey, isBracketKey, isRightKey } from './bracket';
import { copyStateDefinition, fallbackRule, sortStatesMap } from './rules';
function exprTplStatesMap($, { tplEndToken, tplEnd }) {
    const rootState = {};
    const tplState = copyStateDefinition($);
    for (const [bracketKey, bracketRule] of Object.entries(tplState)) {
        if (bracketRule.t === 'string' &&
            isBracketKey(bracketKey) &&
            isRightKey(bracketKey) &&
            (bracketRule.match.startsWith(tplEnd) ||
                tplEnd.startsWith(bracketRule.match))) {
            const counterpartKey = getCounterpartBracketKey(bracketKey);
            if (!counterpartKey) {
                throw new Error('String template definition conflicts with brackets');
            }
            const counterpartRule = tplState[counterpartKey];
            if (!counterpartRule || counterpartRule.t !== 'string') {
                throw new Error('String template definition conflicts with brackets');
            }
            delete tplState[bracketKey];
            counterpartRule.push = '$';
            rootState[counterpartKey] = { ...counterpartRule };
            rootState[bracketKey] = { ...bracketRule, pop: 1 };
        }
    }
    const tplEndRule = { t: 'string', match: tplEnd, pop: 1 };
    tplState[tplEndToken] = tplEndRule;
    return { $: rootState, tplState };
}
function varTplState($, strState, { allowedTokens = [], tplStateName }) {
    const result = { ...strState };
    Object.entries(result).forEach(([key, val]) => {
        if (val.t !== 'fallback') {
            const { push, pop, next } = val;
            if ([push, pop, next].every((x) => x === undefined)) {
                result[key] = { ...val, next: tplStateName };
            }
            else {
                result[key] = { ...val };
            }
        }
        else {
            result[key] = { ...val };
        }
    });
    for (const tokenName of allowedTokens) {
        const rule = $[tokenName];
        if (rule) {
            if (rule.t !== 'fallback') {
                result[tokenName] = { ...rule };
            }
        }
        else {
            throw new Error(`Wrong element for allowedRules: ${tokenName}`);
        }
    }
    return result;
}
export function configStrings(states, opts) {
    if (!opts.length) {
        return states;
    }
    const $ = copyStateDefinition(states.$);
    const strStates = {};
    const exprTplPreStates = [];
    const varTplPreStates = [];
    opts.forEach((strOpt, strIdx) => {
        const { startsWith: strStart, endsWith: strEnd = strStart, templates: tplOpts, } = strOpt;
        const strToken = `str$${strIdx}`;
        const strStartToken = `${strToken}$start`;
        const strEndToken = `${strToken}$end`;
        const strValueToken = `${strToken}$value`;
        const strStateName = `${strToken}$state`;
        const strState = {
            [strEndToken]: { t: 'string', match: strEnd, pop: 1 },
            [strValueToken]: fallbackRule,
        };
        tplOpts === null || tplOpts === void 0 ? void 0 : tplOpts.forEach((tplOpt, tplIdx) => {
            const { startsWith: tplStart } = tplOpt;
            const tplToken = `${strToken}$tpl$${tplIdx}`;
            const tplStartToken = `${tplToken}$start`;
            const tplEndToken = `${tplToken}$end`;
            const tplStateName = `${tplToken}$state`;
            if (tplOpt.type === 'expr') {
                strState[tplStartToken] = {
                    t: 'string',
                    match: tplStart,
                    push: tplStateName,
                };
                const { endsWith: tplEnd } = tplOpt;
                exprTplPreStates.push({ tplStateName, tplEndToken, tplEnd });
            }
            if (tplOpt.type === 'var') {
                strState[tplStartToken] = {
                    t: 'string',
                    match: tplStart,
                    push: tplStateName,
                };
                const { allowedTokens } = tplOpt;
                varTplPreStates.push({
                    allowedTokens,
                    tplStateName,
                    tplStart,
                    strEnd,
                    strStateName,
                });
            }
        });
        strStates[strStateName] = strState;
        $[strStartToken] = { t: 'string', match: strStart, push: strStateName };
    });
    const tplStates = {};
    for (const exprTplStateInput of exprTplPreStates) {
        const { tplStateName } = exprTplStateInput;
        const exprTplStates = exprTplStatesMap($, exprTplStateInput);
        Object.assign($, exprTplStates.$);
        tplStates[tplStateName] = exprTplStates.tplState;
    }
    for (const varTplStateInput of varTplPreStates) {
        const { tplStateName, strStateName } = varTplStateInput;
        const strState = strStates[strStateName];
        if (strState) {
            tplStates[tplStateName] = varTplState($, strState, varTplStateInput);
        }
    }
    const result = { $, ...strStates, ...tplStates };
    return sortStatesMap(result);
}
//# sourceMappingURL=string.js.map