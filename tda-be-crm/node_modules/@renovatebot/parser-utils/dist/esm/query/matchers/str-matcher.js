import { coerceHandler } from '../util';
import { AbstractMatcher } from './abstract-matcher';
export class StrContentMatcher extends AbstractMatcher {
    constructor({ value, handler }) {
        super();
        this.content = value !== null && value !== void 0 ? value : null;
        this.handler = coerceHandler(handler);
    }
    match(checkpoint) {
        let { cursor, context } = checkpoint;
        const node = cursor.node;
        if ((node === null || node === void 0 ? void 0 : node.type) === 'string-value') {
            let isMatched = true;
            if (typeof this.content === 'string') {
                isMatched = this.content === node.value;
            }
            else if (this.content instanceof RegExp) {
                isMatched = this.content.test(node.value);
            }
            if (isMatched) {
                context = this.handler(context, node);
                cursor = this.seekRight(cursor);
                return { cursor, context };
            }
        }
        return null;
    }
}
export class StrTplMatcher extends AbstractMatcher {
    constructor(config) {
        super();
        this.matcher = config.matcher;
        this.preHandler = coerceHandler(config.preHandler);
        this.postHandler = coerceHandler(config.postHandler);
    }
    match(checkpoint) {
        var _a;
        const { cursor: tplCursor, context: tplContext } = checkpoint;
        const rootNode = tplCursor.node;
        if ((rootNode === null || rootNode === void 0 ? void 0 : rootNode.type) === 'template-tree') {
            let cursor = checkpoint.cursor.down;
            if (cursor && cursor.node) {
                let context = this.preHandler(tplContext, rootNode);
                cursor = this.matcher.seek(cursor);
                const match = this.matcher.match({ context, cursor });
                if (match) {
                    ({ cursor, context } = match);
                    cursor = this.seek(cursor);
                    if (((_a = cursor.node) === null || _a === void 0 ? void 0 : _a.type) === '_end') {
                        context = this.postHandler(context, rootNode);
                        cursor = this.seekRight(tplCursor);
                        return { context, cursor };
                    }
                }
            }
        }
        return null;
    }
}
export class StrNodeMatcher extends AbstractMatcher {
    constructor(opts) {
        var _a;
        super();
        this.matchers = (_a = opts.matchers) !== null && _a !== void 0 ? _a : null;
        this.preHandler = coerceHandler(opts.preHandler);
        this.postHandler = coerceHandler(opts.postHandler);
    }
    match(checkpoint) {
        const rootNode = checkpoint.cursor.node;
        if ((rootNode === null || rootNode === void 0 ? void 0 : rootNode.type) === 'string-tree') {
            let context = this.preHandler(checkpoint.context, rootNode);
            let cursor = checkpoint.cursor;
            if (this.matchers) {
                const tokensCount = cursor.children.length - 2;
                if (tokensCount !== this.matchers.length) {
                    return null;
                }
                if (tokensCount > 0) {
                    cursor = this.seekRight(cursor.down);
                    for (const matcher of this.matchers) {
                        const match = matcher.match({ context, cursor });
                        if (!match) {
                            return null;
                        }
                        ({ cursor, context } = match);
                    }
                }
            }
            context = this.postHandler(context, rootNode);
            cursor = this.seekRight(checkpoint.cursor);
            return { context, cursor };
        }
        return null;
    }
}
//# sourceMappingURL=str-matcher.js.map