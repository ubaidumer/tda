import { __awaiter, __generator } from "tslib";
import { sleep } from "./utils/sleep";
import { WaiterState } from "./waiter";
var exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {
    if (attempt > attemptCeiling)
        return maxDelay;
    var delay = minDelay * Math.pow(2, (attempt - 1));
    return randomInRange(minDelay, delay);
};
var randomInRange = function (min, max) { return min + Math.random() * (max - min); };
export var runPolling = function (_a, input, acceptorChecks) {
    var minDelay = _a.minDelay, maxDelay = _a.maxDelay, maxWaitTime = _a.maxWaitTime, abortController = _a.abortController, client = _a.client, abortSignal = _a.abortSignal;
    return __awaiter(void 0, void 0, void 0, function () {
        var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;
        var _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4, acceptorChecks(client, input)];
                case 1:
                    state = (_c.sent()).state;
                    if (state !== WaiterState.RETRY) {
                        return [2, { state: state }];
                    }
                    currentAttempt = 1;
                    waitUntil = Date.now() + maxWaitTime * 1000;
                    attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
                    _c.label = 2;
                case 2:
                    if (!true) return [3, 5];
                    if (((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
                        return [2, { state: WaiterState.ABORTED }];
                    }
                    delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
                    if (Date.now() + delay * 1000 > waitUntil) {
                        return [2, { state: WaiterState.TIMEOUT }];
                    }
                    return [4, sleep(delay)];
                case 3:
                    _c.sent();
                    return [4, acceptorChecks(client, input)];
                case 4:
                    state_1 = (_c.sent()).state;
                    if (state_1 !== WaiterState.RETRY) {
                        return [2, { state: state_1 }];
                    }
                    currentAttempt += 1;
                    return [3, 2];
                case 5: return [2];
            }
        });
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3BvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0QyxPQUFPLEVBQStCLFdBQVcsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUtwRSxJQUFNLDRCQUE0QixHQUFHLFVBQUMsUUFBZ0IsRUFBRSxRQUFnQixFQUFFLGNBQXNCLEVBQUUsT0FBZTtJQUMvRyxJQUFJLE9BQU8sR0FBRyxjQUFjO1FBQUUsT0FBTyxRQUFRLENBQUM7SUFDOUMsSUFBTSxLQUFLLEdBQUcsUUFBUSxHQUFHLFNBQUEsQ0FBQyxFQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFBLENBQUM7SUFDNUMsT0FBTyxhQUFhLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3hDLENBQUMsQ0FBQztBQUVGLElBQU0sYUFBYSxHQUFHLFVBQUMsR0FBVyxFQUFFLEdBQVcsSUFBSyxPQUFBLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQWpDLENBQWlDLENBQUM7QUFVdEYsTUFBTSxDQUFDLElBQU0sVUFBVSxHQUFHLFVBQ3hCLEVBQWdHLEVBQ2hHLEtBQVksRUFDWixjQUF1RTtRQUZyRSxRQUFRLGNBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxXQUFXLGlCQUFBLEVBQUUsZUFBZSxxQkFBQSxFQUFFLE1BQU0sWUFBQSxFQUFFLFdBQVcsaUJBQUE7Ozs7Ozt3QkFJckQsV0FBTSxjQUFjLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFBOztvQkFBN0MsS0FBSyxHQUFLLENBQUEsU0FBbUMsQ0FBQSxNQUF4QztvQkFDYixJQUFJLEtBQUssS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFFO3dCQUMvQixXQUFPLEVBQUUsS0FBSyxPQUFBLEVBQUUsRUFBQztxQkFDbEI7b0JBRUcsY0FBYyxHQUFHLENBQUMsQ0FBQztvQkFDakIsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDO29CQUc1QyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Ozt5QkFDaEUsSUFBSTtvQkFDVCxJQUFJLENBQUEsTUFBQSxlQUFlLGFBQWYsZUFBZSx1QkFBZixlQUFlLENBQUUsTUFBTSwwQ0FBRSxPQUFPLE1BQUksV0FBVyxhQUFYLFdBQVcsdUJBQVgsV0FBVyxDQUFFLE9BQU8sQ0FBQSxFQUFFO3dCQUM1RCxXQUFPLEVBQUUsS0FBSyxFQUFFLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBQztxQkFDdkM7b0JBQ0ssS0FBSyxHQUFHLDRCQUE0QixDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxDQUFDO29CQUcvRixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLFNBQVMsRUFBRTt3QkFDekMsV0FBTyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsT0FBTyxFQUFFLEVBQUM7cUJBQ3ZDO29CQUNELFdBQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFBOztvQkFBbEIsU0FBa0IsQ0FBQztvQkFDRCxXQUFNLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUE7O29CQUE3QyxVQUFVLENBQUEsU0FBbUMsQ0FBQSxNQUF4QztvQkFDYixJQUFJLE9BQUssS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFFO3dCQUMvQixXQUFPLEVBQUUsS0FBSyxTQUFBLEVBQUUsRUFBQztxQkFDbEI7b0JBRUQsY0FBYyxJQUFJLENBQUMsQ0FBQzs7Ozs7O0NBRXZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzbGVlcCB9IGZyb20gXCIuL3V0aWxzL3NsZWVwXCI7XG5pbXBvcnQgeyBXYWl0ZXJPcHRpb25zLCBXYWl0ZXJSZXN1bHQsIFdhaXRlclN0YXRlIH0gZnJvbSBcIi4vd2FpdGVyXCI7XG5cbi8qKlxuICogUmVmZXJlbmNlOiBodHRwczovL2F3c2xhYnMuZ2l0aHViLmlvL3NtaXRoeS8xLjAvc3BlYy93YWl0ZXJzLmh0bWwjd2FpdGVyLXJldHJpZXNcbiAqL1xuY29uc3QgZXhwb25lbnRpYWxCYWNrb2ZmV2l0aEppdHRlciA9IChtaW5EZWxheTogbnVtYmVyLCBtYXhEZWxheTogbnVtYmVyLCBhdHRlbXB0Q2VpbGluZzogbnVtYmVyLCBhdHRlbXB0OiBudW1iZXIpID0+IHtcbiAgaWYgKGF0dGVtcHQgPiBhdHRlbXB0Q2VpbGluZykgcmV0dXJuIG1heERlbGF5O1xuICBjb25zdCBkZWxheSA9IG1pbkRlbGF5ICogMiAqKiAoYXR0ZW1wdCAtIDEpO1xuICByZXR1cm4gcmFuZG9tSW5SYW5nZShtaW5EZWxheSwgZGVsYXkpO1xufTtcblxuY29uc3QgcmFuZG9tSW5SYW5nZSA9IChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpID0+IG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJ1bnMgcG9sbGluZyBhcyBwYXJ0IG9mIHdhaXRlcnMuIFRoaXMgd2lsbCBtYWtlIG9uZSBpbml0YWwgYXR0ZW1wdCBhbmQgdGhlblxuICogc3Vic2VxdWVudCBhdHRlbXB0cyB3aXRoIGFuIGluY3JlYXNpbmcgZGVsYXkuXG4gKiBAcGFyYW0gcGFyYW1zIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB3YWl0ZXIuXG4gKiBAcGFyYW0gY2xpZW50IEFXUyBTREsgQ2xpZW50XG4gKiBAcGFyYW0gaW5wdXQgY2xpZW50IGlucHV0XG4gKiBAcGFyYW0gc3RhdGVDaGVja2VyIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHRoZSBhY2NlcHRvciBzdGF0ZXMgb24gZWFjaCBwb2xsLlxuICovXG5leHBvcnQgY29uc3QgcnVuUG9sbGluZyA9IGFzeW5jIDxDbGllbnQsIElucHV0PihcbiAgeyBtaW5EZWxheSwgbWF4RGVsYXksIG1heFdhaXRUaW1lLCBhYm9ydENvbnRyb2xsZXIsIGNsaWVudCwgYWJvcnRTaWduYWwgfTogV2FpdGVyT3B0aW9uczxDbGllbnQ+LFxuICBpbnB1dDogSW5wdXQsXG4gIGFjY2VwdG9yQ2hlY2tzOiAoY2xpZW50OiBDbGllbnQsIGlucHV0OiBJbnB1dCkgPT4gUHJvbWlzZTxXYWl0ZXJSZXN1bHQ+XG4pOiBQcm9taXNlPFdhaXRlclJlc3VsdD4gPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCBhY2NlcHRvckNoZWNrcyhjbGllbnQsIGlucHV0KTtcbiAgaWYgKHN0YXRlICE9PSBXYWl0ZXJTdGF0ZS5SRVRSWSkge1xuICAgIHJldHVybiB7IHN0YXRlIH07XG4gIH1cblxuICBsZXQgY3VycmVudEF0dGVtcHQgPSAxO1xuICBjb25zdCB3YWl0VW50aWwgPSBEYXRlLm5vdygpICsgbWF4V2FpdFRpbWUgKiAxMDAwO1xuICAvLyBUaGUgbWF4IGF0dGVtcHQgbnVtYmVyIHRoYXQgdGhlIGRlcml2ZWQgZGVsYXkgdGltZSB0ZW5kIHRvIGluY3JlYXNlLlxuICAvLyBQcmUtY29tcHV0ZSB0aGlzIG51bWJlciB0byBhdm9pZCBOdW1iZXIgdHlwZSBvdmVyZmxvdy5cbiAgY29uc3QgYXR0ZW1wdENlaWxpbmcgPSBNYXRoLmxvZyhtYXhEZWxheSAvIG1pbkRlbGF5KSAvIE1hdGgubG9nKDIpICsgMTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyPy5zaWduYWw/LmFib3J0ZWQgfHwgYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHN0YXRlOiBXYWl0ZXJTdGF0ZS5BQk9SVEVEIH07XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gZXhwb25lbnRpYWxCYWNrb2ZmV2l0aEppdHRlcihtaW5EZWxheSwgbWF4RGVsYXksIGF0dGVtcHRDZWlsaW5nLCBjdXJyZW50QXR0ZW1wdCk7XG4gICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSBleHBsaWNpdGx5IGF0IHRpbWVvdXQgb3IgYWJvcnRlZC4gT3RoZXJ3aXNlIHRoaXMgd2hpbGUgbG9vcCB3aWxsIGtlZXAgbWFraW5nIEFQSSBjYWxsIHVudGlsXG4gICAgLy8gYGFjY2VwdG9yQ2hlY2tgIHJldHVybnMgbm9uLXJldHJ5IHN0YXR1cywgZXZlbiB3aXRoIHRoZSBQcm9taXNlLnJhY2UoKSBvdXRzaWRlLlxuICAgIGlmIChEYXRlLm5vdygpICsgZGVsYXkgKiAxMDAwID4gd2FpdFVudGlsKSB7XG4gICAgICByZXR1cm4geyBzdGF0ZTogV2FpdGVyU3RhdGUuVElNRU9VVCB9O1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgYWNjZXB0b3JDaGVja3MoY2xpZW50LCBpbnB1dCk7XG4gICAgaWYgKHN0YXRlICE9PSBXYWl0ZXJTdGF0ZS5SRVRSWSkge1xuICAgICAgcmV0dXJuIHsgc3RhdGUgfTtcbiAgICB9XG5cbiAgICBjdXJyZW50QXR0ZW1wdCArPSAxO1xuICB9XG59O1xuIl19