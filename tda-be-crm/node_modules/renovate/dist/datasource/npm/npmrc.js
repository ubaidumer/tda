"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePackage = exports.setNpmrc = exports.getNpmrc = void 0;
const tslib_1 = require("tslib");
const url_1 = (0, tslib_1.__importDefault)(require("url"));
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const ini_1 = (0, tslib_1.__importDefault)(require("ini"));
const registry_auth_token_1 = (0, tslib_1.__importDefault)(require("registry-auth-token"));
const registry_url_1 = (0, tslib_1.__importDefault)(require("registry-auth-token/registry-url"));
const global_1 = require("../../config/global");
const logger_1 = require("../../logger");
const mask_1 = require("../../util/mask");
const regex_1 = require("../../util/regex");
const sanitize_1 = require("../../util/sanitize");
let npmrc = {};
let npmrcRaw = '';
function getNpmrc() {
    return npmrc;
}
exports.getNpmrc = getNpmrc;
function envReplace(value, env = process.env) {
    // istanbul ignore if
    if (!is_1.default.string(value)) {
        return value;
    }
    const ENV_EXPR = (0, regex_1.regEx)(/(\\*)\$\{([^}]+)\}/g);
    return value.replace(ENV_EXPR, (match, esc, envVarName) => {
        if (env[envVarName] === undefined) {
            logger_1.logger.warn('Failed to replace env in config: ' + match);
            throw new Error('env-replace');
        }
        return env[envVarName];
    });
}
const envRe = (0, regex_1.regEx)(/(\\*)\$\{([^}]+)\}/);
// TODO: better add to host rules (#9588)
function sanitize(key, val) {
    if (!val || envRe.test(val)) {
        return;
    }
    if (key.endsWith('_authToken') || key.endsWith('_auth')) {
        (0, sanitize_1.add)(val);
    }
    else if (key.endsWith(':_password')) {
        (0, sanitize_1.add)(val);
        const password = Buffer.from(val, 'base64').toString();
        (0, sanitize_1.add)(password);
        const username = npmrc[key.replace(':_password', ':username')];
        (0, sanitize_1.add)(Buffer.from(`${username}:${password}`).toString('base64'));
    }
}
function setNpmrc(input) {
    if (input) {
        if (input === npmrcRaw) {
            return;
        }
        const existingNpmrc = npmrc;
        npmrcRaw = input;
        logger_1.logger.debug('Setting npmrc');
        npmrc = ini_1.default.parse(input.replace((0, regex_1.regEx)(/\\n/g), '\n'));
        const { exposeAllEnv } = global_1.GlobalConfig.get();
        for (const [key, val] of Object.entries(npmrc)) {
            if (!exposeAllEnv) {
                sanitize(key, val);
            }
            if (!exposeAllEnv &&
                key.endsWith('registry') &&
                val &&
                val.includes('localhost')) {
                logger_1.logger.debug({ key, val }, 'Detected localhost registry - rejecting npmrc file');
                npmrc = existingNpmrc;
                return;
            }
        }
        if (!exposeAllEnv) {
            return;
        }
        for (const key of Object.keys(npmrc)) {
            npmrc[key] = envReplace(npmrc[key]);
            sanitize(key, npmrc[key]);
        }
    }
    else if (npmrc) {
        logger_1.logger.debug('Resetting npmrc');
        npmrc = {};
        npmrcRaw = '';
    }
}
exports.setNpmrc = setNpmrc;
function resolvePackage(packageName) {
    var _a;
    const scope = packageName.split('/')[0];
    let registryUrl;
    try {
        registryUrl = (0, registry_url_1.default)(scope, getNpmrc());
    }
    catch (err) {
        registryUrl = 'https://registry.npmjs.org/';
    }
    const packageUrl = url_1.default.resolve(registryUrl, encodeURIComponent(packageName).replace((0, regex_1.regEx)(/^%40/), '@'));
    const headers = {};
    let authInfo = (0, registry_auth_token_1.default)(registryUrl, { npmrc, recursive: true });
    if (!authInfo &&
        npmrc &&
        npmrc._authToken &&
        registryUrl.replace(/\/?$/, '/') === ((_a = npmrc.registry) === null || _a === void 0 ? void 0 : _a.replace(/\/?$/, '/')) // TODO #12070
    ) {
        authInfo = { type: 'Bearer', token: npmrc._authToken };
    }
    if ((authInfo === null || authInfo === void 0 ? void 0 : authInfo.type) && authInfo.token) {
        headers.authorization = `${authInfo.type} ${authInfo.token}`;
        logger_1.logger.trace({ token: (0, mask_1.maskToken)(authInfo.token), npmName: packageName }, 'Using auth (via npmrc) for npm lookup');
    }
    return { headers, packageUrl, registryUrl };
}
exports.resolvePackage = resolvePackage;
//# sourceMappingURL=npmrc.js.map