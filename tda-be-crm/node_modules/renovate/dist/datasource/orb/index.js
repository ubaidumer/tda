"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrbDatasource = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../../logger");
const decorator_1 = require("../../util/cache/package/decorator");
const datasource_1 = require("../datasource");
const query = `
query($lookupName: String!) {
  orb(name: $lookupName) {
    name,
    homeUrl,
    versions {
      version,
      createdAt
    }
  }
}
`;
class OrbDatasource extends datasource_1.Datasource {
    constructor() {
        super(OrbDatasource.id);
        this.customRegistrySupport = false;
        this.defaultRegistryUrls = ['https://circleci.com/'];
    }
    async getReleases({ lookupName, registryUrl, }) {
        var _a;
        const url = `${registryUrl}graphql-unstable`;
        const body = {
            query,
            variables: { lookupName },
        };
        const res = (await this.http.postJson(url, {
            body,
        })).body.data.orb;
        if (!res) {
            logger_1.logger.debug({ lookupName }, 'Failed to look up orb');
            return null;
        }
        // Simplify response before caching and returning
        const dep = {
            releases: null,
        };
        if ((_a = res.homeUrl) === null || _a === void 0 ? void 0 : _a.length) {
            dep.homepage = res.homeUrl;
        }
        dep.homepage =
            dep.homepage || `https://circleci.com/developer/orbs/orb/${lookupName}`;
        dep.releases = res.versions.map(({ version, createdAt }) => ({
            version,
            releaseTimestamp: createdAt || null,
        }));
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
}
OrbDatasource.id = 'orb';
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${OrbDatasource.id}`,
        key: ({ lookupName }) => lookupName,
    })
], OrbDatasource.prototype, "getReleases", null);
exports.OrbDatasource = OrbDatasource;
//# sourceMappingURL=index.js.map