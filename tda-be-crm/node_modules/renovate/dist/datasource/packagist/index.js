"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const tslib_1 = require("tslib");
const url_1 = (0, tslib_1.__importDefault)(require("url"));
const p_all_1 = (0, tslib_1.__importDefault)(require("p-all"));
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const memCache = (0, tslib_1.__importStar)(require("../../util/cache/memory"));
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const hostRules = (0, tslib_1.__importStar)(require("../../util/host-rules"));
const http_1 = require("../../util/http");
const regex_1 = require("../../util/regex");
const composerVersioning = (0, tslib_1.__importStar)(require("../../versioning/composer"));
exports.id = 'packagist';
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = ['https://packagist.org'];
exports.defaultVersioning = composerVersioning.id;
exports.registryStrategy = 'hunt';
const http = new http_1.Http(exports.id);
// We calculate auth at this datasource layer so that we can know whether it's safe to cache or not
function getHostOpts(url) {
    let opts = {};
    const { username, password } = hostRules.find({
        hostType: exports.id,
        url,
    });
    if (username && password) {
        opts = { ...opts, username, password };
    }
    return opts;
}
async function getRegistryMeta(regUrl) {
    const url = url_1.default.resolve(regUrl.replace(/\/?$/, '/'), 'packages.json'); // TODO #12070
    const opts = getHostOpts(url);
    const res = (await http.getJson(url, opts)).body;
    const meta = {
        providerPackages: {},
    };
    meta.packages = res.packages;
    if (res.includes) {
        meta.includesFiles = [];
        for (const [name, val] of Object.entries(res.includes)) {
            const file = {
                key: name.replace(val.sha256, '%hash%'),
                sha256: val.sha256,
            };
            meta.includesFiles.push(file);
        }
    }
    if (res['providers-url']) {
        meta.providersUrl = res['providers-url'];
    }
    if (res['providers-lazy-url']) {
        meta.providersLazyUrl = res['providers-lazy-url'];
    }
    if (res['provider-includes']) {
        meta.files = [];
        for (const [key, val] of Object.entries(res['provider-includes'])) {
            const file = {
                key,
                sha256: val.sha256,
            };
            meta.files.push(file);
        }
    }
    if (res.providers) {
        for (const [key, val] of Object.entries(res.providers)) {
            meta.providerPackages[key] = val.sha256;
        }
    }
    return meta;
}
async function getPackagistFile(regUrl, file) {
    var _a;
    const { key, sha256 } = file;
    const fileName = key.replace('%hash%', sha256);
    const opts = getHostOpts(regUrl);
    if (opts.password || ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.authorization)) {
        return (await http.getJson(regUrl + '/' + fileName, opts))
            .body;
    }
    const cacheNamespace = 'datasource-packagist-files';
    const cacheKey = regUrl + key;
    // Check the persistent cache for public registries
    const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
    // istanbul ignore if
    if (cachedResult && cachedResult.sha256 === sha256) {
        return cachedResult.res;
    }
    const res = (await http.getJson(regUrl + '/' + fileName, opts))
        .body;
    const cacheMinutes = 1440; // 1 day
    await packageCache.set(cacheNamespace, cacheKey, { res, sha256 }, cacheMinutes);
    return res;
}
function extractDepReleases(versions) {
    const dep = { releases: null };
    // istanbul ignore if
    if (!versions) {
        dep.releases = [];
        return dep;
    }
    dep.releases = Object.keys(versions).map((version) => {
        var _a;
        const release = versions[version];
        dep.homepage = release.homepage || dep.homepage;
        if ((_a = release.source) === null || _a === void 0 ? void 0 : _a.url) {
            dep.sourceUrl = release.source.url;
        }
        return {
            version: version.replace((0, regex_1.regEx)(/^v/), ''),
            gitRef: version,
            releaseTimestamp: release.time,
        };
    });
    return dep;
}
async function getAllPackages(regUrl) {
    const registryMeta = await getRegistryMeta(regUrl);
    const { packages, providersUrl, providersLazyUrl, files, includesFiles, providerPackages, } = registryMeta;
    if (files) {
        const queue = files.map((file) => () => getPackagistFile(regUrl, file));
        const resolvedFiles = await (0, p_all_1.default)(queue, { concurrency: 5 });
        for (const res of resolvedFiles) {
            for (const [name, val] of Object.entries(res.providers)) {
                providerPackages[name] = val.sha256;
            }
        }
    }
    const includesPackages = {};
    if (includesFiles) {
        for (const file of includesFiles) {
            const res = await getPackagistFile(regUrl, file);
            if (res.packages) {
                for (const [key, val] of Object.entries(res.packages)) {
                    const dep = extractDepReleases(val);
                    includesPackages[key] = dep;
                }
            }
        }
    }
    const allPackages = {
        packages,
        providersUrl,
        providersLazyUrl,
        providerPackages,
        includesPackages,
    };
    return allPackages;
}
function getAllCachedPackages(regUrl) {
    const cacheKey = `packagist-${regUrl}`;
    const cachedResult = memCache.get(cacheKey);
    // istanbul ignore if
    if (cachedResult !== undefined) {
        return cachedResult;
    }
    const promisedRes = getAllPackages(regUrl);
    memCache.set(cacheKey, promisedRes);
    return promisedRes;
}
async function packagistOrgLookup(name) {
    const cacheNamespace = 'datasource-packagist-org';
    const cachedResult = await packageCache.get(cacheNamespace, name);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    let dep = null;
    const regUrl = 'https://packagist.org';
    const pkgUrl = url_1.default.resolve(regUrl, `/p/${name}.json`);
    // TODO: fix types (#9610)
    const res = (await http.getJson(pkgUrl)).body.packages[name];
    if (res) {
        dep = extractDepReleases(res);
        logger_1.logger.trace({ dep }, 'dep');
    }
    const cacheMinutes = 10;
    await packageCache.set(cacheNamespace, name, dep, cacheMinutes);
    return dep;
}
async function packageLookup(regUrl, name) {
    try {
        if (regUrl === 'https://packagist.org') {
            const packagistResult = await packagistOrgLookup(name);
            return packagistResult;
        }
        const allPackages = await getAllCachedPackages(regUrl);
        const { packages, providersUrl, providersLazyUrl, providerPackages, includesPackages, } = allPackages;
        if (packages === null || packages === void 0 ? void 0 : packages[name]) {
            const dep = extractDepReleases(packages[name]);
            return dep;
        }
        if (includesPackages === null || includesPackages === void 0 ? void 0 : includesPackages[name]) {
            return includesPackages[name];
        }
        let pkgUrl;
        if (providerPackages === null || providerPackages === void 0 ? void 0 : providerPackages[name]) {
            pkgUrl = url_1.default.resolve(regUrl, providersUrl
                .replace('%package%', name)
                .replace('%hash%', providerPackages[name]));
        }
        else if (providersLazyUrl) {
            pkgUrl = url_1.default.resolve(regUrl, providersLazyUrl.replace('%package%', name));
        }
        else {
            return null;
        }
        const opts = getHostOpts(regUrl);
        // TODO: fix types (#9610)
        const versions = (await http.getJson(pkgUrl, opts)).body.packages[name];
        const dep = extractDepReleases(versions);
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
    catch (err) /* istanbul ignore next */ {
        if (err.host === 'packagist.org') {
            if (err.code === 'ECONNRESET' || err.code === 'ETIMEDOUT') {
                throw new external_host_error_1.ExternalHostError(err);
            }
            if (err.statusCode && err.statusCode >= 500 && err.statusCode < 600) {
                throw new external_host_error_1.ExternalHostError(err);
            }
        }
        throw err;
    }
}
function getReleases({ lookupName, registryUrl, }) {
    logger_1.logger.trace(`getReleases(${lookupName})`);
    return packageLookup(registryUrl, lookupName);
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map