"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependencyInfo = exports.getDependencyParts = exports.downloadMavenXml = exports.getMavenUrl = exports.checkHttpResource = exports.downloadHttpProtocol = void 0;
const tslib_1 = require("tslib");
const url_1 = (0, tslib_1.__importDefault)(require("url"));
const luxon_1 = require("luxon");
const xmldoc_1 = require("xmldoc");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const http_1 = require("../../util/http");
const regex_1 = require("../../util/regex");
const metadata_1 = require("../metadata");
const common_1 = require("./common");
const http = {};
function httpByHostType(hostType) {
    if (!http[hostType]) {
        http[hostType] = new http_1.Http(hostType);
    }
    return http[hostType];
}
const getHost = (x) => new url_1.default.URL(x).host;
function isMavenCentral(pkgUrl) {
    const host = typeof pkgUrl === 'string' ? pkgUrl : pkgUrl.host;
    return getHost(common_1.MAVEN_REPO) === host;
}
function isTemporalError(err) {
    return (err.code === 'ECONNRESET' ||
        err.statusCode === 429 ||
        (err.statusCode >= 500 && err.statusCode < 600));
}
function isHostError(err) {
    return err.code === 'ETIMEDOUT';
}
function isNotFoundError(err) {
    return err.code === 'ENOTFOUND' || err.statusCode === 404;
}
function isPermissionsIssue(err) {
    return err.statusCode === 401 || err.statusCode === 403;
}
function isConnectionError(err) {
    return (err.code === 'EAI_AGAIN' ||
        err.code === 'ERR_TLS_CERT_ALTNAME_INVALID' ||
        err.code === 'ECONNREFUSED');
}
function isUnsupportedHostError(err) {
    return err.name === 'UnsupportedProtocolError';
}
async function downloadHttpProtocol(pkgUrl, hostType = common_1.id) {
    let raw;
    try {
        const httpClient = httpByHostType(hostType);
        raw = await httpClient.get(pkgUrl.toString());
        return raw;
    }
    catch (err) {
        const failedUrl = pkgUrl.toString();
        if (err.message === error_messages_1.HOST_DISABLED) {
            // istanbul ignore next
            logger_1.logger.trace({ failedUrl }, 'Host disabled');
        }
        else if (isNotFoundError(err)) {
            logger_1.logger.trace({ failedUrl }, `Url not found`);
        }
        else if (isHostError(err)) {
            // istanbul ignore next
            logger_1.logger.debug({ failedUrl }, `Cannot connect to ${hostType} host`);
        }
        else if (isPermissionsIssue(err)) {
            logger_1.logger.debug({ failedUrl }, 'Dependency lookup unauthorized. Please add authentication with a hostRule');
        }
        else if (isTemporalError(err)) {
            logger_1.logger.debug({ failedUrl, err }, 'Temporary error');
            if (isMavenCentral(pkgUrl)) {
                throw new external_host_error_1.ExternalHostError(err);
            }
        }
        else if (isConnectionError(err)) {
            // istanbul ignore next
            logger_1.logger.debug({ failedUrl }, 'Connection refused to maven registry');
        }
        else if (isUnsupportedHostError(err)) {
            // istanbul ignore next
            logger_1.logger.debug({ failedUrl }, 'Unsupported host');
        }
        else {
            logger_1.logger.info({ failedUrl, err }, 'Unknown error');
        }
        return {};
    }
}
exports.downloadHttpProtocol = downloadHttpProtocol;
async function checkHttpResource(pkgUrl, hostType = common_1.id) {
    var _a;
    try {
        const httpClient = httpByHostType(hostType);
        const res = await httpClient.head(pkgUrl.toString());
        const timestamp = (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a['last-modified'];
        if (timestamp) {
            const isoTimestamp = (0, metadata_1.normalizeDate)(timestamp);
            if (isoTimestamp) {
                const releaseDate = luxon_1.DateTime.fromISO(isoTimestamp, {
                    zone: 'UTC',
                }).toJSDate();
                return releaseDate;
            }
        }
        return 'found';
    }
    catch (err) {
        if (isNotFoundError(err)) {
            return 'not-found';
        }
        const failedUrl = pkgUrl.toString();
        logger_1.logger.debug({ failedUrl, statusCode: err.statusCode }, `Can't check HTTP resource existence`);
        return 'error';
    }
}
exports.checkHttpResource = checkHttpResource;
function containsPlaceholder(str) {
    return (0, regex_1.regEx)(/\${.*?}/g).test(str);
}
function getMavenUrl(dependency, repoUrl, path) {
    return new url_1.default.URL(`${dependency.dependencyUrl}/${path}`, repoUrl);
}
exports.getMavenUrl = getMavenUrl;
async function downloadMavenXml(pkgUrl) {
    /* istanbul ignore if */
    if (!pkgUrl) {
        return {};
    }
    let rawContent;
    let authorization;
    let statusCode;
    switch (pkgUrl.protocol) {
        case 'http:':
        case 'https:':
            ({
                authorization,
                body: rawContent,
                statusCode,
            } = await downloadHttpProtocol(pkgUrl));
            break;
        case 's3:':
            logger_1.logger.debug('Skipping s3 dependency');
            return {};
        default:
            logger_1.logger.debug({ url: pkgUrl.toString() }, `Unsupported Maven protocol`);
            return {};
    }
    if (!rawContent) {
        logger_1.logger.debug({ url: pkgUrl.toString(), statusCode }, `Content is not found for Maven url`);
        return {};
    }
    return { authorization, xml: new xmldoc_1.XmlDocument(rawContent) };
}
exports.downloadMavenXml = downloadMavenXml;
function getDependencyParts(lookupName) {
    const [group, name] = lookupName.split(':');
    const dependencyUrl = `${group.replace((0, regex_1.regEx)(/\./g), '/')}/${name}`;
    return {
        display: lookupName,
        group,
        name,
        dependencyUrl,
    };
}
exports.getDependencyParts = getDependencyParts;
async function getDependencyInfo(dependency, repoUrl, version, recursionLimit = 5) {
    const result = {};
    const path = `${version}/${dependency.name}-${version}.pom`;
    const pomUrl = getMavenUrl(dependency, repoUrl, path);
    const { xml: pomContent } = await downloadMavenXml(pomUrl);
    // istanbul ignore if
    if (!pomContent) {
        return result;
    }
    const homepage = pomContent.valueWithPath('url');
    if (homepage && !containsPlaceholder(homepage)) {
        result.homepage = homepage;
    }
    const sourceUrl = pomContent.valueWithPath('scm.url');
    if (sourceUrl && !containsPlaceholder(sourceUrl)) {
        result.sourceUrl = sourceUrl
            .replace((0, regex_1.regEx)(/^scm:/), '')
            .replace((0, regex_1.regEx)(/^git:/), '')
            .replace((0, regex_1.regEx)(/^git@github.com:/), 'https://github.com/')
            .replace((0, regex_1.regEx)(/^git@github.com\//), 'https://github.com/')
            .replace((0, regex_1.regEx)(/\.git$/), '');
        if (result.sourceUrl.startsWith('//')) {
            // most likely the result of us stripping scm:, git: etc
            // going with prepending https: here which should result in potential information retrival
            result.sourceUrl = `https:${result.sourceUrl}`;
        }
    }
    const parent = pomContent.childNamed('parent');
    if (recursionLimit > 0 && parent && (!result.sourceUrl || !result.homepage)) {
        // if we found a parent and are missing some information
        // trying to get the scm/homepage information from it
        const [parentGroupId, parentArtifactId, parentVersion] = [
            'groupId',
            'artifactId',
            'version',
        ].map((k) => { var _a; return (_a = parent.valueWithPath(k)) === null || _a === void 0 ? void 0 : _a.replace(/\s+/g, ''); });
        if (parentGroupId && parentArtifactId && parentVersion) {
            const parentDisplayId = `${parentGroupId}:${parentArtifactId}`;
            const parentDependency = getDependencyParts(parentDisplayId);
            const parentInformation = await getDependencyInfo(parentDependency, repoUrl, parentVersion, recursionLimit - 1);
            if (!result.sourceUrl && parentInformation.sourceUrl) {
                result.sourceUrl = parentInformation.sourceUrl;
            }
            if (!result.homepage && parentInformation.homepage) {
                result.homepage = parentInformation.homepage;
            }
        }
    }
    return result;
}
exports.getDependencyInfo = getDependencyInfo;
//# sourceMappingURL=util.js.map