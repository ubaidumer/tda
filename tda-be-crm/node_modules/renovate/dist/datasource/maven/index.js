"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const luxon_1 = require("luxon");
const p_all_1 = (0, tslib_1.__importDefault)(require("p-all"));
const logger_1 = require("../../logger");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const regex_1 = require("../../util/regex");
const maven_1 = (0, tslib_1.__importDefault)(require("../../versioning/maven"));
const mavenVersioning = (0, tslib_1.__importStar)(require("../../versioning/maven"));
const compare_1 = require("../../versioning/maven/compare");
const common_1 = require("./common");
const util_1 = require("./util");
var common_2 = require("./common");
Object.defineProperty(exports, "id", { enumerable: true, get: function () { return common_2.id; } });
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = [common_1.MAVEN_REPO];
exports.defaultVersioning = mavenVersioning.id;
exports.registryStrategy = 'merge';
function isStableVersion(x) {
    return maven_1.default.isStable(x);
}
function getLatestSuitableVersion(releases) {
    // istanbul ignore if
    if (!(releases === null || releases === void 0 ? void 0 : releases.length)) {
        return null;
    }
    const allVersions = releases.map(({ version }) => version);
    const stableVersions = allVersions.filter(isStableVersion);
    const versions = stableVersions.length ? stableVersions : allVersions;
    return versions.reduce((latestVersion, version) => (0, compare_1.compare)(version, latestVersion) === 1 ? version : latestVersion);
}
function extractVersions(metadata) {
    const versions = metadata.descendantWithPath('versioning.versions');
    const elements = versions === null || versions === void 0 ? void 0 : versions.childrenNamed('version');
    if (!elements) {
        return [];
    }
    return elements.map((el) => el.val);
}
async function fetchReleasesFromMetadata(dependency, repoUrl) {
    const metadataUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, 'maven-metadata.xml');
    const cacheNamespace = 'datasource-maven:metadata-xml';
    const cacheKey = metadataUrl.toString();
    const cachedVersions = await packageCache.get(cacheNamespace, cacheKey);
    /* istanbul ignore if */
    if (cachedVersions) {
        return cachedVersions;
    }
    const { authorization, xml: mavenMetadata } = await (0, util_1.downloadMavenXml)(metadataUrl);
    if (!mavenMetadata) {
        return {};
    }
    const versions = extractVersions(mavenMetadata);
    const releaseMap = versions.reduce((acc, version) => ({ ...acc, [version]: null }), {});
    if (!authorization) {
        await packageCache.set(cacheNamespace, cacheKey, releaseMap, 30);
    }
    return releaseMap;
}
const mavenCentralHtmlVersionRegex = (0, regex_1.regEx)('^<a href="(?<version>[^"]+)\\/" title="(?:[^"]+)\\/">(?:[^"]+)\\/<\\/a>\\s+(?<releaseTimestamp>\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d)\\s+-$', 'i');
async function addReleasesFromIndexPage(inputReleaseMap, dependency, repoUrl) {
    var _a;
    const cacheNs = 'datasource-maven:index-html-releases';
    const cacheKey = `${repoUrl}${dependency.dependencyUrl}`;
    let workingReleaseMap = await packageCache.get(cacheNs, cacheKey);
    if (!workingReleaseMap) {
        workingReleaseMap = {};
        let retryEarlier = false;
        try {
            if (repoUrl.startsWith(common_1.MAVEN_REPO)) {
                const indexUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, 'index.html');
                const res = await (0, util_1.downloadHttpProtocol)(indexUrl);
                const { body = '' } = res;
                for (const line of body.split('\n')) {
                    const match = line.trim().match(mavenCentralHtmlVersionRegex);
                    if (match) {
                        const { version, releaseTimestamp: timestamp } = (match === null || match === void 0 ? void 0 : match.groups) || {};
                        if (version && timestamp) {
                            const date = luxon_1.DateTime.fromFormat(timestamp, 'yyyy-MM-dd HH:mm', {
                                zone: 'UTC',
                            });
                            if (date.isValid) {
                                const releaseTimestamp = date.toISO();
                                workingReleaseMap[version] = { version, releaseTimestamp };
                            }
                        }
                    }
                }
            }
        }
        catch (err) /* istanbul ignore next */ {
            retryEarlier = true;
            logger_1.logger.debug({ dependency, err }, 'Failed to get releases from index.html');
        }
        const cacheTTL = retryEarlier ? 60 : 24 * 60;
        await packageCache.set(cacheNs, cacheKey, workingReleaseMap, cacheTTL);
    }
    const releaseMap = { ...inputReleaseMap };
    for (const version of Object.keys(releaseMap)) {
        releaseMap[version] || (releaseMap[version] = (_a = workingReleaseMap[version]) !== null && _a !== void 0 ? _a : null);
    }
    return releaseMap;
}
function isSnapshotVersion(version) {
    if (version.endsWith('-SNAPSHOT')) {
        return true;
    }
    return false;
}
function extractSnapshotVersion(metadata) {
    var _a, _b, _c, _d;
    // Parse the maven-metadata.xml for the snapshot version and determine
    // the fixed version of the latest deployed snapshot.
    // The metadata descriptor can be found at
    // https://maven.apache.org/ref/3.3.3/maven-repository-metadata/repository-metadata.html
    //
    // Basically, we need to replace -SNAPSHOT with the artifact timestanp & build number,
    // so for example 1.0.0-SNAPSHOT will become 1.0.0-<timestamp>-<buildNumber>
    const version = (_b = (_a = metadata
        .descendantWithPath('version')) === null || _a === void 0 ? void 0 : _a.val) === null || _b === void 0 ? void 0 : _b.replace('-SNAPSHOT', '');
    const snapshot = metadata.descendantWithPath('versioning.snapshot');
    const timestamp = (_c = snapshot === null || snapshot === void 0 ? void 0 : snapshot.childNamed('timestamp')) === null || _c === void 0 ? void 0 : _c.val;
    const build = (_d = snapshot === null || snapshot === void 0 ? void 0 : snapshot.childNamed('buildNumber')) === null || _d === void 0 ? void 0 : _d.val;
    // If we weren't able to parse out the required 3 version elements,
    // return null because we can't determine the fixed version of the latest snapshot.
    if (!version || !timestamp || !build) {
        return null;
    }
    return `${version}-${timestamp}-${build}`;
}
async function getSnapshotFullVersion(version, dependency, repoUrl) {
    // To determine what actual files are available for the snapshot, first we have to fetch and parse
    // the metadata located at http://<repo>/<group>/<artifact>/<version-SNAPSHOT>/maven-metadata.xml
    const metadataUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, `${version}/maven-metadata.xml`);
    const { xml: mavenMetadata } = await (0, util_1.downloadMavenXml)(metadataUrl);
    if (!mavenMetadata) {
        return null;
    }
    return extractSnapshotVersion(mavenMetadata);
}
async function createUrlForDependencyPom(version, dependency, repoUrl) {
    if (isSnapshotVersion(version)) {
        // By default, Maven snapshots are deployed to the repository with fixed file names.
        // Resolve the full, actual pom file name for the version.
        const fullVersion = await getSnapshotFullVersion(version, dependency, repoUrl);
        // If we were able to resolve the version, use that, otherwise fall back to using -SNAPSHOT
        if (fullVersion !== null) {
            return `${version}/${dependency.name}-${fullVersion}.pom`;
        }
    }
    return `${version}/${dependency.name}-${version}.pom`;
}
async function addReleasesUsingHeadRequests(inputReleaseMap, dependency, repoUrl) {
    var _a;
    const releaseMap = { ...inputReleaseMap };
    if (process.env.RENOVATE_EXPERIMENTAL_NO_MAVEN_POM_CHECK) {
        return releaseMap;
    }
    const cacheNs = 'datasource-maven:head-requests';
    const cacheKey = `${repoUrl}${dependency.dependencyUrl}`;
    let workingReleaseMap = await packageCache.get(cacheNs, cacheKey);
    if (!workingReleaseMap) {
        workingReleaseMap = {};
        const unknownVersions = Object.entries(releaseMap)
            .filter(([version, release]) => {
            const isDiscoveredOutside = !!release;
            const isDiscoveredInsideAndCached = !is_1.default.undefined(workingReleaseMap[version]);
            const isDiscovered = isDiscoveredOutside || isDiscoveredInsideAndCached;
            return !isDiscovered;
        })
            .map(([k]) => k);
        if (unknownVersions.length) {
            let retryEarlier = false;
            const queue = unknownVersions.map((version) => async () => {
                const pomUrl = await createUrlForDependencyPom(version, dependency, repoUrl);
                const artifactUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, pomUrl);
                const release = { version };
                const res = await (0, util_1.checkHttpResource)(artifactUrl);
                if (res === 'error') {
                    retryEarlier = true;
                }
                if (is_1.default.date(res)) {
                    release.releaseTimestamp = res.toISOString();
                }
                if (res !== 'not-found' && res !== 'error') {
                    workingReleaseMap[version] = release;
                }
            });
            await (0, p_all_1.default)(queue, { concurrency: 5 });
            const cacheTTL = retryEarlier ? 60 : 24 * 60;
            await packageCache.set(cacheNs, cacheKey, workingReleaseMap, cacheTTL);
        }
    }
    for (const version of Object.keys(releaseMap)) {
        releaseMap[version] || (releaseMap[version] = (_a = workingReleaseMap[version]) !== null && _a !== void 0 ? _a : null);
    }
    return releaseMap;
}
function getReleasesFromMap(releaseMap) {
    const releases = Object.values(releaseMap).filter(Boolean);
    if (releases.length) {
        return releases;
    }
    return Object.keys(releaseMap).map((version) => ({ version }));
}
async function getReleases({ lookupName, registryUrl, }) {
    const dependency = (0, util_1.getDependencyParts)(lookupName);
    const repoUrl = registryUrl.replace(/\/?$/, '/'); // TODO #12071
    logger_1.logger.debug(`Looking up ${dependency.display} in repository ${repoUrl}`);
    let releaseMap = await fetchReleasesFromMetadata(dependency, repoUrl);
    releaseMap = await addReleasesFromIndexPage(releaseMap, dependency, repoUrl);
    releaseMap = await addReleasesUsingHeadRequests(releaseMap, dependency, repoUrl);
    const releases = getReleasesFromMap(releaseMap);
    if (!(releases === null || releases === void 0 ? void 0 : releases.length)) {
        return null;
    }
    logger_1.logger.debug(`Found ${releases.length} new releases for ${dependency.display} in repository ${repoUrl}`);
    const latestSuitableVersion = getLatestSuitableVersion(releases);
    const dependencyInfo = latestSuitableVersion &&
        (await (0, util_1.getDependencyInfo)(dependency, repoUrl, latestSuitableVersion));
    return { ...dependency, ...dependencyInfo, releases };
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map