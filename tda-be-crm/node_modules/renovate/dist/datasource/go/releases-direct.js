"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../../logger");
const regex_1 = require("../../util/regex");
const github = (0, tslib_1.__importStar)(require("../github-tags"));
const gitlab = (0, tslib_1.__importStar)(require("../gitlab-tags"));
const common_1 = require("./common");
const get_datasource_1 = require("./get-datasource");
/**
 * go.getReleases
 *
 * This datasource resolves a go module URL into its source repository
 *  and then fetch it if it is on GitHub.
 *
 * This function will:
 *  - Determine the source URL for the module
 *  - Call the respective getReleases in github/gitlab to retrieve the tags
 *  - Filter module tags according to the module path
 */
async function getReleases(config) {
    const { lookupName } = config;
    let res = null;
    logger_1.logger.trace(`go.getReleases(${lookupName})`);
    const source = await (0, get_datasource_1.getDatasource)(lookupName);
    if (!source) {
        logger_1.logger.info({ lookupName }, 'Unsupported go host - cannot look up versions');
        return null;
    }
    switch (source.datasource) {
        case github.id: {
            res = await github.getReleases(source);
            break;
        }
        case gitlab.id: {
            res = await gitlab.getReleases(source);
            break;
        }
        case common_1.bitbucket.id: {
            res = await common_1.bitbucket.getReleases(source);
            break;
        }
        /* istanbul ignore next: can never happen, makes lint happy */
        default: {
            return null;
        }
    }
    // istanbul ignore if
    if (!res) {
        return null;
    }
    const sourceUrl = (0, common_1.getSourceUrl)(source);
    /**
     * github.com/org/mod/submodule should be tagged as submodule/va.b.c
     * and that tag should be used instead of just va.b.c, although for compatibility
     * the old behaviour stays the same.
     */
    const nameParts = lookupName.replace((0, regex_1.regEx)(/\/v\d+$/), '').split('/');
    logger_1.logger.trace({ nameParts, releases: res.releases }, 'go.getReleases');
    // If it has more than 3 parts it's a submodule or subgroup (gitlab only)
    if (nameParts.length > 3) {
        const prefix = nameParts.slice(3, nameParts.length).join('/');
        logger_1.logger.trace(`go.getReleases.prefix:${prefix}`);
        // Filter the releases so that we only get the ones that are for this submodule
        // Also trim the submodule prefix from the version number
        const submodReleases = res.releases
            .filter((release) => { var _a; return (_a = release.version) === null || _a === void 0 ? void 0 : _a.startsWith(prefix); })
            .map((release) => {
            const r2 = release;
            r2.version = r2.version.replace(`${prefix}/`, '');
            return r2;
        });
        logger_1.logger.trace({ submodReleases }, 'go.getReleases');
        // If not from gitlab -> no subgroups -> must be submodule
        // If from gitlab and directory one level above has tags -> has to be submodule, since groups can't have tags
        // If not, it's simply a repo in a subfolder, and the normal tags are used.
        if (!(source.datasource === gitlab.id) ||
            (source.datasource === gitlab.id && submodReleases.length)) {
            return {
                sourceUrl,
                releases: submodReleases,
            };
        }
    }
    if (res.releases) {
        res.releases = res.releases.filter((release) => { var _a; return (_a = release.version) === null || _a === void 0 ? void 0 : _a.startsWith('v'); });
    }
    return { ...res, sourceUrl };
}
exports.getReleases = getReleases;
//# sourceMappingURL=releases-direct.js.map