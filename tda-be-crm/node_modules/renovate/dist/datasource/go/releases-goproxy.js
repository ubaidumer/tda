"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.versionInfo = exports.listVersions = exports.encodeCase = exports.parseNoproxy = exports.parseGoproxy = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const moo_1 = (0, tslib_1.__importDefault)(require("moo"));
const p_all_1 = (0, tslib_1.__importDefault)(require("p-all"));
const logger_1 = require("../../logger");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const regex_1 = require("../../util/regex");
const common_1 = require("./common");
const get_datasource_1 = require("./get-datasource");
const direct = (0, tslib_1.__importStar)(require("./releases-direct"));
const parsedGoproxy = {};
/**
 * Parse `GOPROXY` to the sequence of url + fallback strategy tags.
 *
 * @example
 * parseGoproxy('foo.example.com|bar.example.com,baz.example.com')
 * // [
 * //   { url: 'foo.example.com', fallback: '|' },
 * //   { url: 'bar.example.com', fallback: ',' },
 * //   { url: 'baz.example.com', fallback: '|' },
 * // ]
 *
 * @see https://golang.org/ref/mod#goproxy-protocol
 */
function parseGoproxy(input = process.env.GOPROXY) {
    if (!is_1.default.string(input)) {
        return [];
    }
    if (parsedGoproxy[input]) {
        return parsedGoproxy[input];
    }
    const result = input
        .split((0, regex_1.regEx)(/([^,|]*(?:,|\|))/))
        .filter(Boolean)
        .map((s) => s.split(/(?=,|\|)/)) // TODO: #12872 lookahead
        .map(([url, separator]) => ({
        url,
        fallback: separator === ','
            ? common_1.GoproxyFallback.WhenNotFoundOrGone
            : common_1.GoproxyFallback.Always,
    }));
    parsedGoproxy[input] = result;
    return result;
}
exports.parseGoproxy = parseGoproxy;
// https://golang.org/pkg/path/#Match
const lexer = moo_1.default.states({
    main: {
        separator: {
            match: /\s*?,\s*?/,
            value: (_) => '|',
        },
        asterisk: {
            match: '*',
            value: (_) => '[^\\/]*',
        },
        qmark: {
            match: '?',
            value: (_) => '[^\\/]',
        },
        characterRangeOpen: {
            match: '[',
            push: 'characterRange',
            value: (_) => '[',
        },
        char: {
            match: /[^*?\\[\n]/,
            value: (s) => s.replace((0, regex_1.regEx)('\\.', 'g'), '\\.'),
        },
        escapedChar: {
            match: /\\./,
            value: (s) => s.slice(1),
        },
    },
    characterRange: {
        char: /[^\\\]\n]/,
        escapedChar: {
            match: /\\./,
            value: (s) => s.slice(1),
        },
        characterRangeEnd: {
            match: ']',
            pop: 1,
        },
    },
});
const parsedNoproxy = {};
function parseNoproxy(input = process.env.GONOPROXY || process.env.GOPRIVATE) {
    if (!is_1.default.string(input)) {
        return null;
    }
    if (parsedNoproxy[input] !== undefined) {
        return parsedNoproxy[input];
    }
    lexer.reset(input);
    const noproxyPattern = [...lexer].map(({ value }) => value).join('');
    const result = noproxyPattern ? (0, regex_1.regEx)(`^(?:${noproxyPattern})$`) : null;
    parsedNoproxy[input] = result;
    return result;
}
exports.parseNoproxy = parseNoproxy;
/**
 * Avoid ambiguity when serving from case-insensitive file systems.
 *
 * @see https://golang.org/ref/mod#goproxy-protocol
 */
function encodeCase(input) {
    return input.replace((0, regex_1.regEx)(/([A-Z])/g), (x) => `!${x.toLowerCase()}`);
}
exports.encodeCase = encodeCase;
async function listVersions(baseUrl, lookupName) {
    const url = `${baseUrl}/${encodeCase(lookupName)}/@v/list`;
    const { body } = await common_1.http.get(url);
    return body
        .split((0, regex_1.regEx)(/\s+/))
        .filter(Boolean)
        .filter((x) => x.indexOf('+') === -1);
}
exports.listVersions = listVersions;
async function versionInfo(baseUrl, lookupName, version) {
    const url = `${baseUrl}/${encodeCase(lookupName)}/@v/${version}.info`;
    const res = await common_1.http.getJson(url);
    const result = {
        version: res.body.Version,
    };
    if (res.body.Time) {
        result.releaseTimestamp = res.body.Time;
    }
    return result;
}
exports.versionInfo = versionInfo;
async function getReleases(config) {
    var _a;
    const { lookupName } = config;
    logger_1.logger.trace(`goproxy.getReleases(${lookupName})`);
    const goproxy = process.env.GOPROXY;
    const proxyList = parseGoproxy(goproxy);
    const noproxy = parseNoproxy();
    const cacheNamespaces = 'datasource-go-proxy';
    const cacheKey = `${lookupName}@@${goproxy}@@${noproxy === null || noproxy === void 0 ? void 0 : noproxy.toString()}`;
    const cacheMinutes = 60;
    const cachedResult = await packageCache.get(cacheNamespaces, cacheKey);
    // istanbul ignore if
    if (cachedResult || cachedResult === null) {
        return cachedResult;
    }
    let result = null;
    if (noproxy === null || noproxy === void 0 ? void 0 : noproxy.test(lookupName)) {
        logger_1.logger.debug(`Fetching ${lookupName} via GONOPROXY match`);
        result = await direct.getReleases(config);
        await packageCache.set(cacheNamespaces, cacheKey, result, cacheMinutes);
        return result;
    }
    for (const { url, fallback } of proxyList) {
        try {
            if (url === 'off') {
                break;
            }
            else if (url === 'direct') {
                result = await direct.getReleases(config);
                break;
            }
            const versions = await listVersions(url, lookupName);
            const queue = versions.map((version) => async () => {
                try {
                    return await versionInfo(url, lookupName, version);
                }
                catch (err) {
                    logger_1.logger.trace({ err }, `Can't obtain data from ${url}`);
                    return { version };
                }
            });
            const releases = await (0, p_all_1.default)(queue, { concurrency: 5 });
            if (releases.length) {
                const datasource = await (0, get_datasource_1.getDatasource)(lookupName);
                const sourceUrl = (0, common_1.getSourceUrl)(datasource);
                result = { releases, sourceUrl };
                break;
            }
        }
        catch (err) {
            const statusCode = (_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.statusCode;
            const canFallback = fallback === common_1.GoproxyFallback.Always
                ? true
                : statusCode === 404 || statusCode === 410;
            const msg = canFallback
                ? 'Goproxy error: trying next URL provided with GOPROXY'
                : 'Goproxy error: skipping other URLs provided with GOPROXY';
            logger_1.logger.debug({ err }, msg);
            if (!canFallback) {
                break;
            }
        }
    }
    await packageCache.set(cacheNamespaces, cacheKey, result, cacheMinutes);
    return result;
}
exports.getReleases = getReleases;
//# sourceMappingURL=releases-goproxy.js.map