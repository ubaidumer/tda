{"version":3,"file":"v2.js","sourceRoot":"","sources":["../../../lib/datasource/nuget/v2.ts"],"names":[],"mappings":";;;AAAA,mCAAiD;AACjD,yCAAsC;AACtC,0CAAuC;AACvC,4CAAyC;AAEzC,qCAA+C;AAE/C,MAAM,IAAI,GAAG,IAAI,WAAI,CAAC,WAAE,CAAC,CAAC;AAE1B,SAAS,UAAU,CAAC,OAAmB,EAAE,QAAgB;;IACvD,OAAO,MAAA,OAAO,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,UAAU,CAAC,KAAK,QAAQ,EAAE,CAAC,0CAAE,GAAG,CAAC;AAC7E,CAAC;AAEM,KAAK,UAAU,WAAW,CAC/B,OAAe,EACf,OAAe;IAEf,MAAM,GAAG,GAAkB;QACzB,QAAQ,EAAE,EAAE;KACb,CAAC;IACF,IAAI,UAAU,GAAG,GAAG,OAAO,CAAC,OAAO,CACjC,IAAA,aAAK,EAAC,MAAM,CAAC,EACb,EAAE,CACH,6BAA6B,OAAO,0DAA0D,CAAC;IAChG,GAAG;QACD,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACtD,MAAM,kBAAkB,GAAG,IAAI,oBAAW,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAEpE,MAAM,WAAW,GAAG,kBAAkB,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAE9D,KAAK,MAAM,OAAO,IAAI,WAAW,EAAE;YACjC,MAAM,OAAO,GAAG,UAAU,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;YAC/C,MAAM,gBAAgB,GAAG,UAAU,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAC1D,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC;gBAChB,OAAO,EAAE,IAAA,wBAAe,EAAC,OAAO,CAAC;gBACjC,gBAAgB;aACjB,CAAC,CAAC;YACH,IAAI;gBACF,MAAM,kBAAkB,GAAG,UAAU,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;gBAClE,IAAI,kBAAkB,KAAK,MAAM,EAAE;oBACjC,MAAM,UAAU,GAAG,UAAU,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;oBACrD,IAAI,UAAU,EAAE;wBACd,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC;qBAC5B;iBACF;aACF;YAAC,OAAO,GAAG,EAAE,0BAA0B,CAAC;gBACvC,eAAM,CAAC,KAAK,CACV,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,EACzB,8DAA8D,CAC/D,CAAC;aACH;SACF;QAED,MAAM,kBAAkB,GAAG,kBAAkB;aAC1C,aAAa,CAAC,MAAM,CAAC;aACrB,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC;QAE5C,UAAU,GAAG,kBAAkB,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;KACvE,QAAQ,UAAU,KAAK,IAAI,EAAE;IAE9B,2DAA2D;IAC3D,IAAI,GAAG,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,IAAI,CAAC;KACb;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AArDD,kCAqDC","sourcesContent":["import { XmlDocument, XmlElement } from 'xmldoc';\nimport { logger } from '../../logger';\nimport { Http } from '../../util/http';\nimport { regEx } from '../../util/regex';\nimport type { ReleaseResult } from '../types';\nimport { id, removeBuildMeta } from './common';\n\nconst http = new Http(id);\n\nfunction getPkgProp(pkgInfo: XmlElement, propName: string): string {\n  return pkgInfo.childNamed('m:properties').childNamed(`d:${propName}`)?.val;\n}\n\nexport async function getReleases(\n  feedUrl: string,\n  pkgName: string\n): Promise<ReleaseResult | null> {\n  const dep: ReleaseResult = {\n    releases: [],\n  };\n  let pkgUrlList = `${feedUrl.replace(\n    regEx(/\\/+$/),\n    ''\n  )}/FindPackagesById()?id=%27${pkgName}%27&$select=Version,IsLatestVersion,ProjectUrl,Published`;\n  do {\n    const pkgVersionsListRaw = await http.get(pkgUrlList);\n    const pkgVersionsListDoc = new XmlDocument(pkgVersionsListRaw.body);\n\n    const pkgInfoList = pkgVersionsListDoc.childrenNamed('entry');\n\n    for (const pkgInfo of pkgInfoList) {\n      const version = getPkgProp(pkgInfo, 'Version');\n      const releaseTimestamp = getPkgProp(pkgInfo, 'Published');\n      dep.releases.push({\n        version: removeBuildMeta(version),\n        releaseTimestamp,\n      });\n      try {\n        const pkgIsLatestVersion = getPkgProp(pkgInfo, 'IsLatestVersion');\n        if (pkgIsLatestVersion === 'true') {\n          const projectUrl = getPkgProp(pkgInfo, 'ProjectUrl');\n          if (projectUrl) {\n            dep.sourceUrl = projectUrl;\n          }\n        }\n      } catch (err) /* istanbul ignore next */ {\n        logger.debug(\n          { err, pkgName, feedUrl },\n          `nuget registry failure: can't parse pkg info for project url`\n        );\n      }\n    }\n\n    const nextPkgUrlListLink = pkgVersionsListDoc\n      .childrenNamed('link')\n      .find((node) => node.attr.rel === 'next');\n\n    pkgUrlList = nextPkgUrlListLink ? nextPkgUrlListLink.attr.href : null;\n  } while (pkgUrlList !== null);\n\n  // dep not found if no release, so we can try next registry\n  if (dep.releases.length === 0) {\n    return null;\n  }\n\n  return dep;\n}\n"]}