"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDigest = exports.getReleases = exports.registryStrategy = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../../logger");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const common_1 = require("./common");
Object.defineProperty(exports, "id", { enumerable: true, get: function () { return common_1.id; } });
const digest_1 = require("./digest");
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = ['https://github.com'];
exports.registryStrategy = 'first';
function getReleasesCacheKey(registryUrl, repo) {
    const type = 'tags';
    return `${registryUrl}:${repo}:${type}`;
}
/**
 * github.getReleases
 *
 * This function can be used to fetch releases with a customisable versioning (e.g. semver) and with releases.
 *
 * This function will:
 *  - Fetch all releases
 *  - Sanitize the versions if desired (e.g. strip out leading 'v')
 *  - Return a dependency object containing sourceUrl string and releases array
 */
async function getReleases({ lookupName: repo, registryUrl, }) {
    const cacheKey = getReleasesCacheKey(registryUrl, repo);
    const cachedResult = await packageCache.get(common_1.cacheNamespace, cacheKey);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    const apiBaseUrl = (0, common_1.getApiBaseUrl)(registryUrl);
    const url = `${apiBaseUrl}repos/${repo}/releases?per_page=100`;
    const res = await common_1.http.getJson(url, {
        paginate: true,
    });
    const githubReleases = res.body;
    const dependency = {
        sourceUrl: (0, common_1.getSourceUrl)(repo, registryUrl),
        releases: null,
    };
    dependency.releases = githubReleases
        .filter(({ draft }) => draft !== true)
        .map(({ tag_name, published_at, prerelease }) => ({
        version: tag_name,
        gitRef: tag_name,
        releaseTimestamp: published_at,
        isStable: prerelease ? false : undefined,
    }));
    const cacheMinutes = 10;
    await packageCache.set(common_1.cacheNamespace, cacheKey, dependency, cacheMinutes);
    return dependency;
}
exports.getReleases = getReleases;
function getDigestCacheKey({ lookupName: repo, currentValue, currentDigest, registryUrl }, newValue) {
    const type = 'digest';
    return `${registryUrl}:${repo}:${currentValue}:${currentDigest}:${newValue}:${type}`;
}
/**
 * github.getDigest
 *
 * The `newValue` supplied here should be a valid tag for the GitHub release.
 * Requires `currentValue` and `currentDigest`.
 *
 * There may be many assets attached to the release. This function will:
 *  - Identify the asset pinned by `currentDigest` in the `currentValue` release
 *     - Download small release assets, parse as checksum manifests (e.g. `SHASUMS.txt`).
 *     - Download individual assets until `currentDigest` is encountered. This is limited to sha256 and sha512.
 *  - Map the hashed asset to `newValue` and return the updated digest as a string
 */
async function getDigest({ lookupName: repo, currentValue, currentDigest, registryUrl }, newValue) {
    logger_1.logger.debug({ repo, currentValue, currentDigest, registryUrl, newValue }, 'getDigest');
    if (!currentDigest) {
        return null;
    }
    if (!currentValue) {
        return currentDigest;
    }
    const cacheKey = getDigestCacheKey({ lookupName: repo, currentValue, currentDigest, registryUrl }, newValue);
    const cachedResult = await packageCache.get(common_1.cacheNamespace, cacheKey);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    const apiBaseUrl = (0, common_1.getApiBaseUrl)(registryUrl);
    const currentRelease = await (0, common_1.getGithubRelease)(apiBaseUrl, repo, currentValue);
    const digestAsset = await (0, digest_1.findDigestAsset)(currentRelease, currentDigest);
    let newDigest;
    if (!digestAsset || newValue === currentValue) {
        newDigest = currentDigest;
    }
    else {
        const newRelease = await (0, common_1.getGithubRelease)(apiBaseUrl, repo, newValue);
        newDigest = await (0, digest_1.mapDigestAssetToRelease)(digestAsset, newRelease);
    }
    const cacheMinutes = 1440;
    await packageCache.set(common_1.cacheNamespace, cacheKey, newDigest, cacheMinutes);
    return newDigest;
}
exports.getDigest = getDigest;
//# sourceMappingURL=index.js.map