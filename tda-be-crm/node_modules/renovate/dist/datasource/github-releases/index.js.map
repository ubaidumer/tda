{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../lib/datasource/github-releases/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../logger';\nimport * as packageCache from '../../util/cache/package';\nimport type { DigestConfig, GetReleasesConfig, ReleaseResult } from '../types';\nimport {\n  cacheNamespace,\n  getApiBaseUrl,\n  getGithubRelease,\n  getSourceUrl,\n  http,\n  id,\n} from './common';\nimport { findDigestAsset, mapDigestAssetToRelease } from './digest';\nimport type { GithubRelease } from './types';\n\nexport { id };\nexport const customRegistrySupport = true;\nexport const defaultRegistryUrls = ['https://github.com'];\nexport const registryStrategy = 'first';\n\nfunction getReleasesCacheKey(registryUrl: string, repo: string): string {\n  const type = 'tags';\n  return `${registryUrl}:${repo}:${type}`;\n}\n\n/**\n * github.getReleases\n *\n * This function can be used to fetch releases with a customisable versioning (e.g. semver) and with releases.\n *\n * This function will:\n *  - Fetch all releases\n *  - Sanitize the versions if desired (e.g. strip out leading 'v')\n *  - Return a dependency object containing sourceUrl string and releases array\n */\nexport async function getReleases({\n  lookupName: repo,\n  registryUrl,\n}: GetReleasesConfig): Promise<ReleaseResult | null> {\n  const cacheKey = getReleasesCacheKey(registryUrl, repo);\n  const cachedResult = await packageCache.get<ReleaseResult>(\n    cacheNamespace,\n    cacheKey\n  );\n  // istanbul ignore if\n  if (cachedResult) {\n    return cachedResult;\n  }\n  const apiBaseUrl = getApiBaseUrl(registryUrl);\n  const url = `${apiBaseUrl}repos/${repo}/releases?per_page=100`;\n  const res = await http.getJson<GithubRelease[]>(url, {\n    paginate: true,\n  });\n  const githubReleases = res.body;\n  const dependency: ReleaseResult = {\n    sourceUrl: getSourceUrl(repo, registryUrl),\n    releases: null,\n  };\n  dependency.releases = githubReleases\n    .filter(({ draft }) => draft !== true)\n    .map(({ tag_name, published_at, prerelease }) => ({\n      version: tag_name,\n      gitRef: tag_name,\n      releaseTimestamp: published_at,\n      isStable: prerelease ? false : undefined,\n    }));\n  const cacheMinutes = 10;\n  await packageCache.set(cacheNamespace, cacheKey, dependency, cacheMinutes);\n  return dependency;\n}\n\nfunction getDigestCacheKey(\n  { lookupName: repo, currentValue, currentDigest, registryUrl }: DigestConfig,\n  newValue: string\n): string {\n  const type = 'digest';\n  return `${registryUrl}:${repo}:${currentValue}:${currentDigest}:${newValue}:${type}`;\n}\n\n/**\n * github.getDigest\n *\n * The `newValue` supplied here should be a valid tag for the GitHub release.\n * Requires `currentValue` and `currentDigest`.\n *\n * There may be many assets attached to the release. This function will:\n *  - Identify the asset pinned by `currentDigest` in the `currentValue` release\n *     - Download small release assets, parse as checksum manifests (e.g. `SHASUMS.txt`).\n *     - Download individual assets until `currentDigest` is encountered. This is limited to sha256 and sha512.\n *  - Map the hashed asset to `newValue` and return the updated digest as a string\n */\nexport async function getDigest(\n  { lookupName: repo, currentValue, currentDigest, registryUrl }: DigestConfig,\n  newValue?: string\n): Promise<string | null> {\n  logger.debug(\n    { repo, currentValue, currentDigest, registryUrl, newValue },\n    'getDigest'\n  );\n  if (!currentDigest) {\n    return null;\n  }\n  if (!currentValue) {\n    return currentDigest;\n  }\n  const cacheKey = getDigestCacheKey(\n    { lookupName: repo, currentValue, currentDigest, registryUrl },\n    newValue\n  );\n  const cachedResult = await packageCache.get<string>(cacheNamespace, cacheKey);\n  // istanbul ignore if\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  const apiBaseUrl = getApiBaseUrl(registryUrl);\n  const currentRelease = await getGithubRelease(apiBaseUrl, repo, currentValue);\n  const digestAsset = await findDigestAsset(currentRelease, currentDigest);\n  let newDigest: string;\n  if (!digestAsset || newValue === currentValue) {\n    newDigest = currentDigest;\n  } else {\n    const newRelease = await getGithubRelease(apiBaseUrl, repo, newValue);\n    newDigest = await mapDigestAssetToRelease(digestAsset, newRelease);\n  }\n\n  const cacheMinutes = 1440;\n  await packageCache.set(cacheNamespace, cacheKey, newDigest, cacheMinutes);\n  return newDigest;\n}\n"]}