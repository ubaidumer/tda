"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsMachineImageDataSource = void 0;
const tslib_1 = require("tslib");
const client_ec2_1 = require("@aws-sdk/client-ec2");
const decorator_1 = require("../../util/cache/package/decorator");
const amazonMachineImageVersioning = (0, tslib_1.__importStar)(require("../../versioning/aws-machine-image"));
const datasource_1 = require("../datasource");
class AwsMachineImageDataSource extends datasource_1.Datasource {
    constructor() {
        super(AwsMachineImageDataSource.id);
        this.defaultVersioning = amazonMachineImageVersioning.id;
        this.caching = true;
        this.defaultConfig = {
            // Because AMIs don't follow any versioning scheme, we override commitMessageExtra to remove the 'v'
            commitMessageExtra: 'to {{{newVersion}}}',
            prBodyColumns: ['Change', 'Image'],
            prBodyDefinitions: {
                Image: '```{{{newDigest}}}```',
            },
            digest: {
                // Because newDigestShort will allways be 'amazon-' we override to print the name of the AMI
                commitMessageExtra: 'to {{{newDigest}}}',
                prBodyColumns: ['Image'],
                prBodyDefinitions: {
                    Image: '```{{{newDigest}}}```',
                },
            },
        };
        this.ec2 = new client_ec2_1.EC2Client({});
        this.now = Date.now();
    }
    async getSortedAwsMachineImages(serializedAmiFilter) {
        var _a;
        const cmd = new client_ec2_1.DescribeImagesCommand({
            Filters: JSON.parse(serializedAmiFilter),
        });
        const matchingImages = await this.ec2.send(cmd);
        matchingImages.Images = (_a = matchingImages.Images) !== null && _a !== void 0 ? _a : [];
        return matchingImages.Images.sort((image1, image2) => Date.parse(image1.CreationDate) - Date.parse(image2.CreationDate));
    }
    async getDigest({ lookupName: serializedAmiFilter }, newValue) {
        const images = await this.getSortedAwsMachineImages(serializedAmiFilter);
        if (images.length < 1) {
            return null;
        }
        if (newValue) {
            const newValueMatchingImages = images.filter((image) => image.ImageId === newValue);
            if (newValueMatchingImages.length === 1) {
                return newValueMatchingImages[0].Name;
            }
            return null;
        }
        return (await this.getReleases({ lookupName: serializedAmiFilter }))
            .releases[0].newDigest;
    }
    async getReleases({ lookupName: serializedAmiFilter, }) {
        var _a;
        const images = await this.getSortedAwsMachineImages(serializedAmiFilter);
        if (images.length === 0) {
            return null;
        }
        const latestImage = images[images.length - 1];
        return {
            releases: [
                {
                    version: latestImage.ImageId,
                    releaseTimestamp: latestImage.CreationDate,
                    isDeprecated: Date.parse((_a = latestImage.DeprecationTime) !== null && _a !== void 0 ? _a : this.now.toString()) <
                        this.now,
                    newDigest: latestImage.Name,
                },
            ],
        };
    }
}
AwsMachineImageDataSource.id = 'aws-machine-image';
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${AwsMachineImageDataSource.id}`,
        key: (serializedAmiFilter) => `getSortedAwsMachineImages:${serializedAmiFilter}`,
    })
], AwsMachineImageDataSource.prototype, "getSortedAwsMachineImages", null);
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${AwsMachineImageDataSource.id}`,
        key: ({ registryUrl, lookupName }, newValue) => `getDigest:${registryUrl}:${lookupName}:${newValue !== null && newValue !== void 0 ? newValue : ''}`,
    })
], AwsMachineImageDataSource.prototype, "getDigest", null);
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${AwsMachineImageDataSource.id}`,
        key: ({ registryUrl, lookupName }) => `getReleases:${registryUrl}:${lookupName}`,
    })
], AwsMachineImageDataSource.prototype, "getReleases", null);
exports.AwsMachineImageDataSource = AwsMachineImageDataSource;
//# sourceMappingURL=index.js.map