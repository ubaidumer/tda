{"version":3,"file":"get.js","sourceRoot":"","sources":["../../../lib/datasource/rubygems/get.ts"],"names":[],"mappings":"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","sourcesContent":["import Marshal from 'marshal';\nimport { logger } from '../../logger';\nimport { HttpError } from '../../util/http/types';\nimport { getQueryString, joinUrlParts, parseUrl } from '../../util/url';\nimport { Datasource } from '../datasource';\nimport type { GetReleasesConfig, Release, ReleaseResult } from '../types';\nimport type {\n  JsonGemVersions,\n  JsonGemsInfo,\n  MarshalledVersionInfo,\n} from './types';\n\nconst INFO_PATH = '/api/v1/gems';\nconst VERSIONS_PATH = '/api/v1/versions';\nconst DEPENDENCIES_PATH = '/api/v1/dependencies';\n\nexport class InternalRubyGemsDatasource extends Datasource {\n  constructor(override readonly id: string) {\n    super(id);\n  }\n\n  private knownFallbackHosts = ['rubygems.pkg.github.com', 'gitlab.com'];\n\n  override getReleases({\n    lookupName,\n    registryUrl,\n  }: GetReleasesConfig): Promise<ReleaseResult | null> {\n    if (this.knownFallbackHosts.includes(parseUrl(registryUrl)?.hostname)) {\n      return this.getDependencyFallback(lookupName, registryUrl);\n    }\n    return this.getDependency(lookupName, registryUrl);\n  }\n\n  async getDependencyFallback(\n    dependency: string,\n    registry: string\n  ): Promise<ReleaseResult | null> {\n    logger.debug(\n      { dependency, api: DEPENDENCIES_PATH },\n      'RubyGems lookup for dependency'\n    );\n    const info = await this.fetchBuffer<MarshalledVersionInfo[]>(\n      dependency,\n      registry,\n      DEPENDENCIES_PATH\n    );\n    if (!info || info.length === 0) {\n      return null;\n    }\n    const releases = info.map(\n      ({ number: version, platform: rubyPlatform }) => ({\n        version,\n        rubyPlatform,\n      })\n    );\n    return {\n      releases,\n      homepage: null,\n      sourceUrl: null,\n      changelogUrl: null,\n    };\n  }\n\n  async getDependency(\n    dependency: string,\n    registry: string\n  ): Promise<ReleaseResult | null> {\n    logger.debug(\n      { dependency, api: INFO_PATH },\n      'RubyGems lookup for dependency'\n    );\n    let info: JsonGemsInfo;\n\n    try {\n      info = await this.fetchJson(dependency, registry, INFO_PATH);\n    } catch (error) {\n      // fallback to deps api on 404\n      if (error instanceof HttpError && error.response?.statusCode === 404) {\n        return await this.getDependencyFallback(dependency, registry);\n      }\n      throw error;\n    }\n\n    if (!info) {\n      logger.debug({ dependency }, 'RubyGems package not found.');\n      return null;\n    }\n\n    if (dependency.toLowerCase() !== info.name.toLowerCase()) {\n      logger.warn(\n        { lookup: dependency, returned: info.name },\n        'Lookup name does not match with returned.'\n      );\n      return null;\n    }\n\n    let versions: JsonGemVersions[] = [];\n    let releases: Release[] = [];\n    try {\n      versions = await this.fetchJson(dependency, registry, VERSIONS_PATH);\n    } catch (err) {\n      if (err.statusCode === 400 || err.statusCode === 404) {\n        logger.debug(\n          { registry },\n          'versions endpoint returns error - falling back to info endpoint'\n        );\n      } else {\n        throw err;\n      }\n    }\n\n    // TODO: invalid properties for `Release` see #11312\n\n    if (versions.length === 0 && info.version) {\n      logger.warn('falling back to the version from the info endpoint');\n      releases = [\n        {\n          version: info.version,\n          rubyPlatform: info.platform,\n        } as Release,\n      ];\n    } else {\n      releases = versions.map(\n        ({\n          number: version,\n          platform: rubyPlatform,\n          created_at: releaseTimestamp,\n          rubygems_version: rubygemsVersion,\n          ruby_version: rubyVersion,\n        }) => ({\n          version,\n          rubyPlatform,\n          releaseTimestamp,\n          rubygemsVersion,\n          rubyVersion,\n        })\n      );\n    }\n\n    return {\n      releases,\n      homepage: info.homepage_uri,\n      sourceUrl: info.source_code_uri,\n      changelogUrl: info.changelog_uri,\n    };\n  }\n\n  private async fetchJson<T>(\n    dependency: string,\n    registry: string,\n    path: string\n  ): Promise<T> {\n    const url = joinUrlParts(registry, path, `${dependency}.json`);\n\n    logger.trace({ registry, dependency, url }, `RubyGems lookup request`);\n    const response = (await this.http.getJson<T>(url)) || {\n      body: undefined,\n    };\n\n    return response.body;\n  }\n\n  private async fetchBuffer<T>(\n    dependency: string,\n    registry: string,\n    path: string\n  ): Promise<T> {\n    const url = `${joinUrlParts(registry, path)}?${getQueryString({\n      gems: dependency,\n    })}`;\n\n    logger.trace({ registry, dependency, url }, `RubyGems lookup request`);\n    const response = await this.http.getBuffer(url);\n\n    return new Marshal(response.body).parsed as T;\n  }\n}\n"]}