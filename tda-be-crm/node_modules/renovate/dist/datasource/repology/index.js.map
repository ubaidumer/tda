{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../lib/datasource/repology/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { HOST_DISABLED } from '../../constants/error-messages';\nimport { logger } from '../../logger';\nimport { ExternalHostError } from '../../types/errors/external-host-error';\nimport * as packageCache from '../../util/cache/package';\nimport { Http } from '../../util/http';\nimport { getQueryString, joinUrlParts } from '../../util/url';\nimport type { GetReleasesConfig, ReleaseResult } from '../types';\nimport type { RepologyPackage, RepologyPackageType } from './types';\n\nexport const id = 'repology';\nexport const customRegistrySupport = true;\nexport const defaultRegistryUrls = ['https://repology.org/'];\nexport const registryStrategy = 'hunt';\n\nconst http = new Http(id);\nconst cacheNamespace = `datasource-${id}-list`;\nconst cacheMinutes = 60;\n\nconst packageTypes: RepologyPackageType[] = ['binname', 'srcname'];\n\nasync function queryPackages(url: string): Promise<RepologyPackage[]> {\n  try {\n    const res = await http.getJson<RepologyPackage[]>(url);\n    return res.body;\n  } catch (err) {\n    if (err.statusCode === 404) {\n      // Return an array here because the api does not return proper http codes\n      // and instead of an 404 error an empty array with code 200 is returned\n      // When querying the resolver 404 is thrown if package could not be resolved\n      // and 403 if the repo is not supported\n      // 403 is handled later because in this case we are trying the API\n      return [];\n    }\n\n    throw err;\n  }\n}\n\nasync function queryPackagesViaResolver(\n  registryUrl: string,\n  repoName: string,\n  packageName: string,\n  packageType: RepologyPackageType\n): Promise<RepologyPackage[]> {\n  const query = getQueryString({\n    repo: repoName,\n    name_type: packageType,\n    target_page: 'api_v1_project',\n    noautoresolve: 'on',\n    name: packageName,\n  });\n\n  // Retrieve list of packages by looking up Repology project\n  const packages = await queryPackages(\n    joinUrlParts(registryUrl, `tools/project-by?${query}`)\n  );\n\n  return packages;\n}\n\nasync function queryPackagesViaAPI(\n  registryUrl: string,\n  packageName: string\n): Promise<RepologyPackage[]> {\n  // Directly query the package via the API. This will only work if `packageName` has the\n  // same name as the repology project\n  const packages = await queryPackages(\n    joinUrlParts(registryUrl, `api/v1/project`, packageName)\n  );\n\n  return packages;\n}\n\nfunction findPackageInResponse(\n  response: RepologyPackage[],\n  repoName: string,\n  pkgName: string,\n  types: RepologyPackageType[]\n): RepologyPackage[] | undefined {\n  const repoPackages = response.filter((pkg) => pkg.repo === repoName);\n\n  if (repoPackages.length === 0) {\n    // no packages associated with repoName\n    return null;\n  }\n\n  if (repoPackages.length === 1) {\n    // repo contains exactly one package, so we can return them safely\n    return repoPackages;\n  }\n\n  // In some cases Repology bundles multiple packages into a single project, which might result in ambiguous results.\n  // We need to do additional filtering by matching allowed package types passed as params with package description.\n  // Remaining packages are the one we are looking for\n  let packagesWithType: RepologyPackage[];\n  for (const pkgType of types) {\n    packagesWithType = repoPackages.filter(\n      (pkg) => !pkg[pkgType] || pkg[pkgType] === pkgName\n    );\n    if (packagesWithType.length === 1) {\n      break;\n    }\n  }\n\n  return packagesWithType.length > 0 ? packagesWithType : null;\n}\n\nasync function queryPackage(\n  registryUrl: string,\n  repoName: string,\n  pkgName: string\n): Promise<RepologyPackage[]> {\n  let response: RepologyPackage[];\n  let pkg: RepologyPackage[];\n  // Try getting the packages from tools/project-by first for type binname and\n  // afterwards for srcname. This needs to be done first, because some packages\n  // resolve to repology projects which have a different name than the package\n  // e.g. `pulseaudio-utils` resolves to project `pulseaudio`, BUT there is also\n  // a project called `pulseaudio-utils` but it does not contain the package we\n  // are looking for.\n  try {\n    for (const pkgType of packageTypes) {\n      response = await queryPackagesViaResolver(\n        registryUrl,\n        repoName,\n        pkgName,\n        pkgType\n      );\n\n      if (response) {\n        pkg = findPackageInResponse(response, repoName, pkgName, [pkgType]);\n        if (pkg) {\n          // exit immediately if package found\n          return pkg;\n        }\n      }\n    }\n  } catch (err) {\n    if (err.statusCode === 403) {\n      logger.debug(\n        { repoName, pkgName },\n        'Repology does not support tools/project-by lookups for repository. Will try direct API access now'\n      );\n\n      // If the repository is not supported in tools/project-by we try directly accessing the\n      // API. This will support all repositories but requires that the project name is equal to the\n      // package name. This won't be always the case but for a good portion we might be able to resolve\n      // the package this way.\n      response = await queryPackagesViaAPI(registryUrl, pkgName);\n      pkg = findPackageInResponse(response, repoName, pkgName, packageTypes);\n      if (pkg) {\n        // exit immediately if package found\n        return pkg;\n      }\n    } else if (err.statusCode === 300) {\n      logger.warn(\n        { repoName, pkgName },\n        'Ambiguous redirection from package name to project name in Repology. Skipping this package'\n      );\n      return null;\n    }\n\n    throw err;\n  }\n\n  logger.debug(\n    { repoName, pkgName },\n    'Repository or package not found on Repology'\n  );\n\n  return null;\n}\n\nasync function getCachedPackage(\n  registryUrl: string,\n  repoName: string,\n  pkgName: string\n): Promise<RepologyPackage[]> {\n  // Fetch previous result from cache if available\n  const cacheKey = joinUrlParts(registryUrl, repoName, pkgName);\n  const cachedResult = await packageCache.get<RepologyPackage[]>(\n    cacheNamespace,\n    cacheKey\n  );\n  // istanbul ignore if\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  // Attempt a package lookup and return if found non empty list\n  const pkg = await queryPackage(registryUrl, repoName, pkgName);\n  if (pkg && pkg.length > 0) {\n    await packageCache.set(cacheNamespace, cacheKey, pkg, cacheMinutes);\n    return pkg;\n  }\n\n  // No package was found on Repology\n  return null;\n}\n\nexport async function getReleases({\n  lookupName,\n  registryUrl,\n}: GetReleasesConfig): Promise<ReleaseResult | null> {\n  // Ensure lookup name contains both repository and package\n  const [repoName, pkgName] = lookupName.split('/', 2);\n  if (!repoName || !pkgName) {\n    throw new ExternalHostError(\n      new Error(\n        'Repology lookup name must contain repository and package separated by slash (<repo>/<pkg>)'\n      )\n    );\n  }\n\n  logger.trace(`repology.getReleases(${repoName}, ${pkgName})`);\n  try {\n    // Attempt to retrieve (cached) package information from Repology\n    const pkg = await getCachedPackage(registryUrl, repoName, pkgName);\n    if (!pkg) {\n      return null;\n    }\n\n    // Always prefer origversion if available, otherwise default to version\n    // This is required as source packages usually have no origversion\n    const releases = pkg.map((item) => ({\n      version: item.origversion ?? item.version,\n    }));\n    return { releases };\n  } catch (err) {\n    if (err.message === HOST_DISABLED) {\n      // istanbul ignore next\n      logger.trace({ lookupName, err }, 'Host disabled');\n    } else {\n      logger.warn(\n        { lookupName, err },\n        'Repology lookup failed with unexpected error'\n      );\n    }\n\n    throw new ExternalHostError(err);\n  }\n}\n"]}