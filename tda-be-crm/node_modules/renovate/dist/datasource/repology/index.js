"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.registryStrategy = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const tslib_1 = require("tslib");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const http_1 = require("../../util/http");
const url_1 = require("../../util/url");
exports.id = 'repology';
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = ['https://repology.org/'];
exports.registryStrategy = 'hunt';
const http = new http_1.Http(exports.id);
const cacheNamespace = `datasource-${exports.id}-list`;
const cacheMinutes = 60;
const packageTypes = ['binname', 'srcname'];
async function queryPackages(url) {
    try {
        const res = await http.getJson(url);
        return res.body;
    }
    catch (err) {
        if (err.statusCode === 404) {
            // Return an array here because the api does not return proper http codes
            // and instead of an 404 error an empty array with code 200 is returned
            // When querying the resolver 404 is thrown if package could not be resolved
            // and 403 if the repo is not supported
            // 403 is handled later because in this case we are trying the API
            return [];
        }
        throw err;
    }
}
async function queryPackagesViaResolver(registryUrl, repoName, packageName, packageType) {
    const query = (0, url_1.getQueryString)({
        repo: repoName,
        name_type: packageType,
        target_page: 'api_v1_project',
        noautoresolve: 'on',
        name: packageName,
    });
    // Retrieve list of packages by looking up Repology project
    const packages = await queryPackages((0, url_1.joinUrlParts)(registryUrl, `tools/project-by?${query}`));
    return packages;
}
async function queryPackagesViaAPI(registryUrl, packageName) {
    // Directly query the package via the API. This will only work if `packageName` has the
    // same name as the repology project
    const packages = await queryPackages((0, url_1.joinUrlParts)(registryUrl, `api/v1/project`, packageName));
    return packages;
}
function findPackageInResponse(response, repoName, pkgName, types) {
    const repoPackages = response.filter((pkg) => pkg.repo === repoName);
    if (repoPackages.length === 0) {
        // no packages associated with repoName
        return null;
    }
    if (repoPackages.length === 1) {
        // repo contains exactly one package, so we can return them safely
        return repoPackages;
    }
    // In some cases Repology bundles multiple packages into a single project, which might result in ambiguous results.
    // We need to do additional filtering by matching allowed package types passed as params with package description.
    // Remaining packages are the one we are looking for
    let packagesWithType;
    for (const pkgType of types) {
        packagesWithType = repoPackages.filter((pkg) => !pkg[pkgType] || pkg[pkgType] === pkgName);
        if (packagesWithType.length === 1) {
            break;
        }
    }
    return packagesWithType.length > 0 ? packagesWithType : null;
}
async function queryPackage(registryUrl, repoName, pkgName) {
    let response;
    let pkg;
    // Try getting the packages from tools/project-by first for type binname and
    // afterwards for srcname. This needs to be done first, because some packages
    // resolve to repology projects which have a different name than the package
    // e.g. `pulseaudio-utils` resolves to project `pulseaudio`, BUT there is also
    // a project called `pulseaudio-utils` but it does not contain the package we
    // are looking for.
    try {
        for (const pkgType of packageTypes) {
            response = await queryPackagesViaResolver(registryUrl, repoName, pkgName, pkgType);
            if (response) {
                pkg = findPackageInResponse(response, repoName, pkgName, [pkgType]);
                if (pkg) {
                    // exit immediately if package found
                    return pkg;
                }
            }
        }
    }
    catch (err) {
        if (err.statusCode === 403) {
            logger_1.logger.debug({ repoName, pkgName }, 'Repology does not support tools/project-by lookups for repository. Will try direct API access now');
            // If the repository is not supported in tools/project-by we try directly accessing the
            // API. This will support all repositories but requires that the project name is equal to the
            // package name. This won't be always the case but for a good portion we might be able to resolve
            // the package this way.
            response = await queryPackagesViaAPI(registryUrl, pkgName);
            pkg = findPackageInResponse(response, repoName, pkgName, packageTypes);
            if (pkg) {
                // exit immediately if package found
                return pkg;
            }
        }
        else if (err.statusCode === 300) {
            logger_1.logger.warn({ repoName, pkgName }, 'Ambiguous redirection from package name to project name in Repology. Skipping this package');
            return null;
        }
        throw err;
    }
    logger_1.logger.debug({ repoName, pkgName }, 'Repository or package not found on Repology');
    return null;
}
async function getCachedPackage(registryUrl, repoName, pkgName) {
    // Fetch previous result from cache if available
    const cacheKey = (0, url_1.joinUrlParts)(registryUrl, repoName, pkgName);
    const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    // Attempt a package lookup and return if found non empty list
    const pkg = await queryPackage(registryUrl, repoName, pkgName);
    if (pkg && pkg.length > 0) {
        await packageCache.set(cacheNamespace, cacheKey, pkg, cacheMinutes);
        return pkg;
    }
    // No package was found on Repology
    return null;
}
async function getReleases({ lookupName, registryUrl, }) {
    // Ensure lookup name contains both repository and package
    const [repoName, pkgName] = lookupName.split('/', 2);
    if (!repoName || !pkgName) {
        throw new external_host_error_1.ExternalHostError(new Error('Repology lookup name must contain repository and package separated by slash (<repo>/<pkg>)'));
    }
    logger_1.logger.trace(`repology.getReleases(${repoName}, ${pkgName})`);
    try {
        // Attempt to retrieve (cached) package information from Repology
        const pkg = await getCachedPackage(registryUrl, repoName, pkgName);
        if (!pkg) {
            return null;
        }
        // Always prefer origversion if available, otherwise default to version
        // This is required as source packages usually have no origversion
        const releases = pkg.map((item) => {
            var _a;
            return ({
                version: (_a = item.origversion) !== null && _a !== void 0 ? _a : item.version,
            });
        });
        return { releases };
    }
    catch (err) {
        if (err.message === error_messages_1.HOST_DISABLED) {
            // istanbul ignore next
            logger_1.logger.trace({ lookupName, err }, 'Host disabled');
        }
        else {
            logger_1.logger.warn({ lookupName, err }, 'Repology lookup failed with unexpected error');
        }
        throw new external_host_error_1.ExternalHostError(err);
    }
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map