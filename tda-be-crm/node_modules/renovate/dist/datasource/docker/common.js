"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLabels = exports.getManifestResponse = exports.extractDigestFromResponseBody = exports.getRegistryRepository = exports.getAuthHeaders = exports.defaultRegistryUrls = exports.ecrRegex = exports.http = exports.id = void 0;
const tslib_1 = require("tslib");
const client_ecr_1 = require("@aws-sdk/client-ecr");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const auth_header_1 = require("auth-header");
const hasha_1 = (0, tslib_1.__importDefault)(require("hasha"));
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const hostRules = (0, tslib_1.__importStar)(require("../../util/host-rules"));
const http_1 = require("../../util/http");
const regex_1 = require("../../util/regex");
const url_1 = require("../../util/url");
const types_1 = require("./types");
exports.id = 'docker';
exports.http = new http_1.Http(exports.id);
exports.ecrRegex = (0, regex_1.regEx)(/\d+\.dkr\.ecr\.([-a-z0-9]+)\.amazonaws\.com/);
const DOCKER_HUB = 'https://index.docker.io';
exports.defaultRegistryUrls = [DOCKER_HUB];
async function getECRAuthToken(region, opts) {
    var _a, _b;
    const config = { region };
    if (opts.username && opts.password) {
        config.credentials = {
            accessKeyId: opts.username,
            secretAccessKey: opts.password,
            ...(opts.token && { sessionToken: opts.token }),
        };
    }
    const ecr = new client_ecr_1.ECR(config);
    try {
        const data = await ecr.getAuthorizationToken({});
        const authorizationToken = (_b = (_a = data === null || data === void 0 ? void 0 : data.authorizationData) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.authorizationToken;
        if (authorizationToken) {
            return authorizationToken;
        }
        logger_1.logger.warn('Could not extract authorizationToken from ECR getAuthorizationToken response');
    }
    catch (err) {
        logger_1.logger.trace({ err }, 'err');
        logger_1.logger.debug('ECR getAuthorizationToken error');
    }
    return null;
}
async function getAuthHeaders(registryHost, dockerRepository) {
    var _a;
    try {
        const apiCheckUrl = `${registryHost}/v2/`;
        const apiCheckResponse = await exports.http.get(apiCheckUrl, {
            throwHttpErrors: false,
            noAuth: true,
        });
        if (apiCheckResponse.statusCode === 200) {
            logger_1.logger.debug({ registryHost }, 'No registry auth required');
            return {};
        }
        if (apiCheckResponse.statusCode !== 401 ||
            !is_1.default.nonEmptyString(apiCheckResponse.headers['www-authenticate'])) {
            logger_1.logger.warn({ registryHost, res: apiCheckResponse }, 'Invalid registry response');
            return null;
        }
        const authenticateHeader = (0, auth_header_1.parse)(apiCheckResponse.headers['www-authenticate']);
        const opts = hostRules.find({
            hostType: exports.id,
            url: apiCheckUrl,
        });
        if (exports.ecrRegex.test(registryHost)) {
            logger_1.logger.trace({ registryHost, dockerRepository }, `Using ecr auth for Docker registry`);
            const [, region] = exports.ecrRegex.exec(registryHost);
            const auth = await getECRAuthToken(region, opts);
            if (auth) {
                opts.headers = { authorization: `Basic ${auth}` };
            }
        }
        else if (opts.username && opts.password) {
            logger_1.logger.trace({ registryHost, dockerRepository }, `Using basic auth for Docker registry`);
            const auth = Buffer.from(`${opts.username}:${opts.password}`).toString('base64');
            opts.headers = { authorization: `Basic ${auth}` };
        }
        else if (opts.token) {
            const authType = (_a = opts.authType) !== null && _a !== void 0 ? _a : 'Bearer';
            logger_1.logger.trace({ registryHost, dockerRepository }, `Using ${authType} token for Docker registry`);
            opts.headers = { authorization: `${authType} ${opts.token}` };
        }
        delete opts.username;
        delete opts.password;
        delete opts.token;
        // If realm isn't an url, we should directly use auth header
        // Can happen when we get a Basic auth or some other auth type
        // * WWW-Authenticate: Basic realm="Artifactory Realm"
        // * Www-Authenticate: Basic realm="https://123456789.dkr.ecr.eu-central-1.amazonaws.com/",service="ecr.amazonaws.com"
        // * www-authenticate: Bearer realm="https://ghcr.io/token",service="ghcr.io",scope="repository:user/image:pull"
        // * www-authenticate: Bearer realm="https://auth.docker.io/token",service="registry.docker.io"
        if (authenticateHeader.scheme.toUpperCase() !== 'BEARER' ||
            !is_1.default.string(authenticateHeader.params.realm) ||
            !is_1.default.string(authenticateHeader.params.service) ||
            (0, url_1.parseUrl)(authenticateHeader.params.realm) === null) {
            logger_1.logger.trace({ registryHost, dockerRepository, authenticateHeader }, `Invalid realm, testing direct auth`);
            return opts.headers;
        }
        const authUrl = `${authenticateHeader.params.realm}?service=${authenticateHeader.params.service}&scope=repository:${dockerRepository}:pull`;
        logger_1.logger.trace({ registryHost, dockerRepository, authUrl }, `Obtaining docker registry token`);
        opts.noAuth = true;
        const authResponse = (await exports.http.getJson(authUrl, opts)).body;
        const token = authResponse.token || authResponse.access_token;
        // istanbul ignore if
        if (!token) {
            logger_1.logger.warn('Failed to obtain docker registry token');
            return null;
        }
        return {
            authorization: `Bearer ${token}`,
        };
    }
    catch (err) /* istanbul ignore next */ {
        if (err.host === 'quay.io') {
            // TODO: debug why quay throws errors (#9604)
            return null;
        }
        if (err.statusCode === 401) {
            logger_1.logger.debug({ registryHost, dockerRepository }, 'Unauthorized docker lookup');
            logger_1.logger.debug({ err });
            return null;
        }
        if (err.statusCode === 403) {
            logger_1.logger.debug({ registryHost, dockerRepository }, 'Not allowed to access docker registry');
            logger_1.logger.debug({ err });
            return null;
        }
        // prettier-ignore
        if (err.name === 'RequestError' && registryHost.endsWith('docker.io')) { // lgtm [js/incomplete-url-substring-sanitization]
            throw new external_host_error_1.ExternalHostError(err);
        }
        // prettier-ignore
        if (err.statusCode === 429 && registryHost.endsWith('docker.io')) { // lgtm [js/incomplete-url-substring-sanitization]
            throw new external_host_error_1.ExternalHostError(err);
        }
        if (err.statusCode >= 500 && err.statusCode < 600) {
            throw new external_host_error_1.ExternalHostError(err);
        }
        if (err.message === error_messages_1.HOST_DISABLED) {
            logger_1.logger.trace({ registryHost, dockerRepository, err }, 'Host disabled');
            return null;
        }
        logger_1.logger.warn({ registryHost, dockerRepository, err }, 'Error obtaining docker token');
        return null;
    }
}
exports.getAuthHeaders = getAuthHeaders;
function getRegistryRepository(lookupName, registryUrl) {
    if (registryUrl !== DOCKER_HUB) {
        const registryEndingWithSlash = (0, url_1.ensureTrailingSlash)(registryUrl.replace((0, regex_1.regEx)(/^https?:\/\//), ''));
        if (lookupName.startsWith(registryEndingWithSlash)) {
            let registryHost = (0, url_1.trimTrailingSlash)(registryUrl);
            if (!(0, regex_1.regEx)(/^https?:\/\//).test(registryHost)) {
                registryHost = `https://${registryHost}`;
            }
            let dockerRepository = lookupName.replace(registryEndingWithSlash, '');
            const fullUrl = `${registryHost}/${dockerRepository}`;
            const { origin, pathname } = (0, url_1.parseUrl)(fullUrl);
            registryHost = origin;
            dockerRepository = pathname.substring(1);
            return {
                registryHost,
                dockerRepository,
            };
        }
    }
    let registryHost;
    const split = lookupName.split('/');
    if (split.length > 1 && (split[0].includes('.') || split[0].includes(':'))) {
        [registryHost] = split;
        split.shift();
    }
    let dockerRepository = split.join('/');
    if (!registryHost) {
        registryHost = registryUrl.replace('https://docker.io', 'https://index.docker.io');
    }
    if (registryHost === 'docker.io') {
        registryHost = 'index.docker.io';
    }
    if (!(0, regex_1.regEx)(/^https?:\/\//).exec(registryHost)) {
        registryHost = `https://${registryHost}`;
    }
    const opts = hostRules.find({ hostType: exports.id, url: registryHost });
    if (opts === null || opts === void 0 ? void 0 : opts.insecureRegistry) {
        registryHost = registryHost.replace('https', 'http');
    }
    if (registryHost.endsWith('.docker.io') && !dockerRepository.includes('/')) {
        dockerRepository = 'library/' + dockerRepository;
    }
    return {
        registryHost,
        dockerRepository,
    };
}
exports.getRegistryRepository = getRegistryRepository;
function digestFromManifestStr(str) {
    return 'sha256:' + (0, hasha_1.default)(str, { algorithm: 'sha256' });
}
function extractDigestFromResponseBody(manifestResponse) {
    return digestFromManifestStr(manifestResponse.body);
}
exports.extractDigestFromResponseBody = extractDigestFromResponseBody;
// TODO: debug why quay throws errors (#9612)
async function getManifestResponse(registryHost, dockerRepository, tag, mode = 'get') {
    logger_1.logger.debug(`getManifestResponse(${registryHost}, ${dockerRepository}, ${tag})`);
    try {
        const headers = await getAuthHeaders(registryHost, dockerRepository);
        if (!headers) {
            logger_1.logger.debug('No docker auth found - returning');
            return null;
        }
        headers.accept =
            'application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.docker.distribution.manifest.v2+json';
        const url = `${registryHost}/v2/${dockerRepository}/manifests/${tag}`;
        const manifestResponse = await exports.http[mode](url, {
            headers,
            noAuth: true,
        });
        return manifestResponse;
    }
    catch (err) /* istanbul ignore next */ {
        if (err instanceof external_host_error_1.ExternalHostError) {
            throw err;
        }
        if (err.statusCode === 401) {
            logger_1.logger.debug({ registryHost, dockerRepository }, 'Unauthorized docker lookup');
            logger_1.logger.debug({ err });
            return null;
        }
        if (err.statusCode === 404) {
            logger_1.logger.debug({
                err,
                registryHost,
                dockerRepository,
                tag,
            }, 'Docker Manifest is unknown');
            return null;
        }
        // prettier-ignore
        if (err.statusCode === 429 && registryHost.endsWith('docker.io')) { // lgtm [js/incomplete-url-substring-sanitization]
            throw new external_host_error_1.ExternalHostError(err);
        }
        if (err.statusCode >= 500 && err.statusCode < 600) {
            throw new external_host_error_1.ExternalHostError(err);
        }
        if (err.code === 'ETIMEDOUT') {
            logger_1.logger.debug({ registryHost }, 'Timeout when attempting to connect to docker registry');
            logger_1.logger.debug({ err });
            return null;
        }
        logger_1.logger.debug({
            err,
            registryHost,
            dockerRepository,
            tag,
        }, 'Unknown Error looking up docker manifest');
        return null;
    }
}
exports.getManifestResponse = getManifestResponse;
async function getConfigDigest(registry, dockerRepository, tag) {
    var _a;
    const manifestResponse = await getManifestResponse(registry, dockerRepository, tag);
    // If getting the manifest fails here, then abort
    // This means that the latest tag doesn't have a manifest, which shouldn't
    // be possible
    // istanbul ignore if
    if (!manifestResponse) {
        return null;
    }
    const manifest = JSON.parse(manifestResponse.body);
    if (manifest.schemaVersion !== 2) {
        logger_1.logger.debug({ registry, dockerRepository, tag }, 'Manifest schema version is not 2');
        return null;
    }
    if (manifest.mediaType === types_1.MediaType.manifestListV2 &&
        manifest.manifests.length) {
        logger_1.logger.trace({ registry, dockerRepository, tag }, 'Found manifest list, using first image');
        return getConfigDigest(registry, dockerRepository, manifest.manifests[0].digest);
    }
    if (manifest.mediaType === types_1.MediaType.manifestV2) {
        return ((_a = manifest.config) === null || _a === void 0 ? void 0 : _a.digest) || null;
    }
    logger_1.logger.debug({ manifest }, 'Invalid manifest - returning');
    return null;
}
/*
 * docker.getLabels
 *
 * This function will:
 *  - Return the labels for the requested image
 */
async function getLabels(registryHost, dockerRepository, tag) {
    logger_1.logger.debug(`getLabels(${registryHost}, ${dockerRepository}, ${tag})`);
    const cacheNamespace = 'datasource-docker-labels';
    const cacheKey = `${registryHost}:${dockerRepository}:${tag}`;
    const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
    // istanbul ignore if
    if (cachedResult !== undefined) {
        return cachedResult;
    }
    try {
        let labels = {};
        const configDigest = await getConfigDigest(registryHost, dockerRepository, tag);
        if (!configDigest) {
            return {};
        }
        const headers = await getAuthHeaders(registryHost, dockerRepository);
        // istanbul ignore if: Should never be happen
        if (!headers) {
            logger_1.logger.debug('No docker auth found - returning');
            return {};
        }
        const url = `${registryHost}/v2/${dockerRepository}/blobs/${configDigest}`;
        const configResponse = await exports.http.get(url, {
            headers,
            noAuth: true,
        });
        labels = JSON.parse(configResponse.body).config.Labels;
        if (labels) {
            logger_1.logger.debug({
                labels,
            }, 'found labels in manifest');
        }
        const cacheMinutes = 60;
        await packageCache.set(cacheNamespace, cacheKey, labels, cacheMinutes);
        return labels;
    }
    catch (err) /* istanbul ignore next: should be tested in future */ {
        if (err instanceof external_host_error_1.ExternalHostError) {
            throw err;
        }
        if (err.statusCode === 400 || err.statusCode === 401) {
            logger_1.logger.debug({ registryHost, dockerRepository, err }, 'Unauthorized docker lookup');
        }
        else if (err.statusCode === 404) {
            logger_1.logger.warn({
                err,
                registryHost,
                dockerRepository,
                tag,
            }, 'Config Manifest is unknown');
        }
        else if (err.statusCode === 429 &&
            registryHost.endsWith('docker.io') // lgtm [js/incomplete-url-substring-sanitization]
        ) {
            logger_1.logger.warn({ err }, 'docker registry failure: too many requests');
        }
        else if (err.statusCode >= 500 && err.statusCode < 600) {
            logger_1.logger.debug({
                err,
                registryHost,
                dockerRepository,
                tag,
            }, 'docker registry failure: internal error');
        }
        else if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID' ||
            err.code === 'ETIMEDOUT') {
            logger_1.logger.debug({ registryHost, err }, 'Error connecting to docker registry');
        }
        else if (registryHost === 'https://quay.io') {
            // istanbul ignore next
            logger_1.logger.debug('Ignoring quay.io errors until they fully support v2 schema');
        }
        else {
            logger_1.logger.info({ registryHost, dockerRepository, tag, err }, 'Unknown error getting Docker labels');
        }
        return {};
    }
}
exports.getLabels = getLabels;
//# sourceMappingURL=common.js.map