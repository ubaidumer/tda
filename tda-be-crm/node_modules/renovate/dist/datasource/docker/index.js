"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.getDigest = exports.defaultConfig = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const tslib_1 = require("tslib");
const url_1 = (0, tslib_1.__importDefault)(require("url"));
const parse_link_header_1 = (0, tslib_1.__importDefault)(require("parse-link-header"));
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const packageCache = (0, tslib_1.__importStar)(require("../../util/cache/package"));
const object_1 = require("../../util/object");
const regex_1 = require("../../util/regex");
const url_2 = require("../../util/url");
const docker_1 = require("../../versioning/docker");
const common_1 = require("./common");
Object.defineProperty(exports, "defaultRegistryUrls", { enumerable: true, get: function () { return common_1.defaultRegistryUrls; } });
Object.defineProperty(exports, "id", { enumerable: true, get: function () { return common_1.id; } });
const quay_1 = require("./quay");
exports.customRegistrySupport = true;
exports.defaultVersioning = docker_1.id;
exports.registryStrategy = 'first';
exports.defaultConfig = {
    commitMessageTopic: '{{{depName}}} Docker tag',
    commitMessageExtra: 'to v{{#if isMajor}}{{{newMajor}}}{{else}}{{{newVersion}}}{{/if}}',
    digest: {
        branchTopic: '{{{depNameSanitized}}}-{{{currentValue}}}',
        commitMessageExtra: 'to {{newDigestShort}}',
        commitMessageTopic: '{{{depName}}}{{#if currentValue}}:{{{currentValue}}}{{/if}} Docker digest',
        group: {
            commitMessageTopic: '{{{groupName}}}',
            commitMessageExtra: '',
        },
    },
    pin: {
        commitMessageExtra: '',
        groupName: 'Docker digests',
        group: {
            commitMessageTopic: '{{{groupName}}}',
            branchTopic: 'digests-pin',
        },
    },
    group: {
        commitMessageTopic: '{{{groupName}}} Docker tags',
    },
};
async function getDockerApiTags(registryHost, dockerRepository) {
    let tags = [];
    // AWS ECR limits the maximum number of results to 1000
    // See https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_DescribeRepositories.html#ECR-DescribeRepositories-request-maxResults
    const limit = common_1.ecrRegex.test(registryHost) ? 1000 : 10000;
    let url = `${registryHost}/${dockerRepository}/tags/list?n=${limit}`;
    url = (0, url_2.ensurePathPrefix)(url, '/v2');
    const headers = await (0, common_1.getAuthHeaders)(registryHost, dockerRepository);
    if (!headers) {
        logger_1.logger.debug('Failed to get authHeaders for getTags lookup');
        return null;
    }
    let page = 1;
    do {
        const res = await common_1.http.getJson(url, {
            headers,
            noAuth: true,
        });
        tags = tags.concat(res.body.tags);
        const linkHeader = (0, parse_link_header_1.default)(res.headers.link);
        url = (linkHeader === null || linkHeader === void 0 ? void 0 : linkHeader.next) ? url_1.default.resolve(url, linkHeader.next.url) : null;
        page += 1;
    } while (url && page < 20);
    return tags;
}
async function getTags(registryHost, dockerRepository) {
    try {
        const cacheNamespace = 'datasource-docker-tags';
        const cacheKey = `${registryHost}:${dockerRepository}`;
        const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
        // istanbul ignore if
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        const isQuay = (0, regex_1.regEx)(/^https:\/\/quay\.io(?::[1-9][0-9]{0,4})?$/i).test(registryHost);
        let tags;
        if (isQuay) {
            tags = await (0, quay_1.getTagsQuayRegistry)(registryHost, dockerRepository);
        }
        else {
            tags = await getDockerApiTags(registryHost, dockerRepository);
        }
        const cacheMinutes = 30;
        await packageCache.set(cacheNamespace, cacheKey, tags, cacheMinutes);
        return tags;
    }
    catch (err) /* istanbul ignore next */ {
        if (err instanceof external_host_error_1.ExternalHostError) {
            throw err;
        }
        if (err.statusCode === 404 && !dockerRepository.includes('/')) {
            logger_1.logger.debug(`Retrying Tags for ${registryHost}/${dockerRepository} using library/ prefix`);
            return getTags(registryHost, 'library/' + dockerRepository);
        }
        // prettier-ignore
        if (err.statusCode === 429 && registryHost.endsWith('docker.io')) { // lgtm [js/incomplete-url-substring-sanitization]
            logger_1.logger.warn({ registryHost, dockerRepository, err }, 'docker registry failure: too many requests');
            throw new external_host_error_1.ExternalHostError(err);
        }
        // prettier-ignore
        if (err.statusCode === 401 && registryHost.endsWith('docker.io')) { // lgtm [js/incomplete-url-substring-sanitization]
            logger_1.logger.warn({ registryHost, dockerRepository, err }, 'docker registry failure: unauthorized');
            throw new external_host_error_1.ExternalHostError(err);
        }
        if (err.statusCode >= 500 && err.statusCode < 600) {
            logger_1.logger.warn({ registryHost, dockerRepository, err }, 'docker registry failure: internal error');
            throw new external_host_error_1.ExternalHostError(err);
        }
        throw err;
    }
}
function findLatestStable(tags) {
    var _a;
    const versions = tags
        .filter((v) => docker_1.api.isValid(v) && docker_1.api.isStable(v))
        .sort((a, b) => docker_1.api.sortVersions(a, b));
    return (_a = versions.pop()) !== null && _a !== void 0 ? _a : tags.slice(-1).pop();
}
/**
 * docker.getDigest
 *
 * The `newValue` supplied here should be a valid tag for the docker image.
 *
 * This function will:
 *  - Look up a sha256 digest for a tag on its registry
 *  - Return the digest as a string
 */
async function getDigest({ registryUrl, lookupName }, newValue) {
    const { registryHost, dockerRepository } = (0, common_1.getRegistryRepository)(lookupName, registryUrl);
    logger_1.logger.debug(`getDigest(${registryHost}, ${dockerRepository}, ${newValue})`);
    const newTag = newValue || 'latest';
    const cacheNamespace = 'datasource-docker-digest';
    const cacheKey = `${registryHost}:${dockerRepository}:${newTag}`;
    let digest = null;
    try {
        const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
        // istanbul ignore if
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        let manifestResponse = await (0, common_1.getManifestResponse)(registryHost, dockerRepository, newTag, 'head');
        if (manifestResponse) {
            if ((0, object_1.hasKey)('docker-content-digest', manifestResponse.headers)) {
                digest = manifestResponse.headers['docker-content-digest'] || null;
            }
            else {
                logger_1.logger.debug({ registryHost }, 'Missing docker content digest header, pulling full manifest');
                manifestResponse = await (0, common_1.getManifestResponse)(registryHost, dockerRepository, newTag);
                digest = (0, common_1.extractDigestFromResponseBody)(manifestResponse);
            }
            logger_1.logger.debug({ digest }, 'Got docker digest');
        }
    }
    catch (err) /* istanbul ignore next */ {
        if (err instanceof external_host_error_1.ExternalHostError) {
            throw err;
        }
        logger_1.logger.debug({
            err,
            lookupName,
            newTag,
        }, 'Unknown Error looking up docker image digest');
    }
    const cacheMinutes = 30;
    await packageCache.set(cacheNamespace, cacheKey, digest, cacheMinutes);
    return digest;
}
exports.getDigest = getDigest;
/**
 * docker.getReleases
 *
 * A docker image usually looks something like this: somehost.io/owner/repo:8.1.0-alpine
 * In the above:
 *  - 'somehost.io' is the registry
 *  - 'owner/repo' is the package name
 *  - '8.1.0-alpine' is the tag
 *
 * This function will filter only tags that contain a semver version
 */
async function getReleases({ lookupName, registryUrl, }) {
    const { registryHost, dockerRepository } = (0, common_1.getRegistryRepository)(lookupName, registryUrl);
    const tags = await getTags(registryHost, dockerRepository);
    if (!tags) {
        return null;
    }
    const releases = tags.map((version) => ({ version }));
    const ret = {
        registryUrl: registryHost,
        releases,
    };
    const latestTag = tags.includes('latest') ? 'latest' : findLatestStable(tags);
    const labels = await (0, common_1.getLabels)(registryHost, dockerRepository, latestTag);
    if (labels && 'org.opencontainers.image.source' in labels) {
        ret.sourceUrl = labels['org.opencontainers.image.source'];
    }
    return ret;
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map