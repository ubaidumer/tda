"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformProviderDatasource = void 0;
const tslib_1 = require("tslib");
const p_map_1 = (0, tslib_1.__importDefault)(require("p-map"));
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const decorator_1 = require("../../util/cache/package/decorator");
const regex_1 = require("../../util/regex");
const url_1 = require("../../util/url");
const hashicorpVersioning = (0, tslib_1.__importStar)(require("../../versioning/hashicorp"));
const base_1 = require("../terraform-module/base");
class TerraformProviderDatasource extends base_1.TerraformDatasource {
    constructor() {
        super(TerraformProviderDatasource.id);
        this.defaultRegistryUrls = TerraformProviderDatasource.defaultRegistryUrls;
        this.defaultVersioning = hashicorpVersioning.id;
        this.registryStrategy = 'hunt';
    }
    async getReleases({ lookupName, registryUrl, }) {
        logger_1.logger.debug({ lookupName }, 'terraform-provider.getDependencies()');
        let dep = null;
        const registryHost = (0, url_1.parseUrl)(registryUrl).host;
        if (registryHost === 'releases.hashicorp.com') {
            dep = await this.queryReleaseBackend(lookupName, registryUrl);
        }
        else {
            const repository = TerraformProviderDatasource.getRepository({
                lookupName,
            });
            dep = await this.queryRegistry(registryUrl, repository);
        }
        return dep;
    }
    static getRepository({ lookupName }) {
        return lookupName.includes('/') ? lookupName : `hashicorp/${lookupName}`;
    }
    async queryRegistry(registryURL, repository) {
        const serviceDiscovery = await this.getTerraformServiceDiscoveryResult(registryURL);
        const backendURL = `${registryURL}${serviceDiscovery['providers.v1']}${repository}`;
        const res = (await this.http.getJson(backendURL)).body;
        const dep = {
            releases: null,
        };
        if (res.source) {
            dep.sourceUrl = res.source;
        }
        dep.releases = res.versions.map((version) => ({
            version,
        }));
        // set published date for latest release
        const latestVersion = dep.releases.find((release) => res.version === release.version);
        // istanbul ignore else
        if (latestVersion) {
            latestVersion.releaseTimestamp = res.published_at;
        }
        dep.homepage = `${registryURL}/providers/${repository}`;
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
    // TODO: add long term cache (#9590)
    async queryReleaseBackend(lookupName, registryURL) {
        const backendLookUpName = `terraform-provider-${lookupName}`;
        const backendURL = registryURL + `/index.json`;
        const res = (await this.http.getJson(backendURL)).body;
        if (!res[backendLookUpName]) {
            return null;
        }
        const dep = {
            releases: null,
            sourceUrl: `https://github.com/terraform-providers/${backendLookUpName}`,
        };
        dep.releases = Object.keys(res[backendLookUpName].versions).map((version) => ({
            version,
        }));
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
    async getBuilds(registryURL, repository, version) {
        if (registryURL === TerraformProviderDatasource.defaultRegistryUrls[1]) {
            // check if registryURL === secondary backend
            const repositoryRegexResult = TerraformProviderDatasource.repositoryRegex.exec(repository);
            if (!repositoryRegexResult) {
                // non hashicorp builds are not supported with releases.hashicorp.com
                return null;
            }
            const lookupName = repositoryRegexResult.groups.lookupName;
            const backendLookUpName = `terraform-provider-${lookupName}`;
            let versionReleaseBackend;
            try {
                versionReleaseBackend = await this.getReleaseBackendIndex(backendLookUpName, version);
            }
            catch (err) {
                /* istanbul ignore next */
                if (err instanceof external_host_error_1.ExternalHostError) {
                    throw err;
                }
                logger_1.logger.debug({ err, backendLookUpName, version }, `Failed to retrieve builds for ${backendLookUpName} ${version}`);
                return null;
            }
            return versionReleaseBackend.builds;
        }
        // check public or private Terraform registry
        const serviceDiscovery = await this.getTerraformServiceDiscoveryResult(registryURL);
        if (!serviceDiscovery) {
            logger_1.logger.trace(`Failed to retrieve service discovery from ${registryURL}`);
            return null;
        }
        const backendURL = `${registryURL}${serviceDiscovery['providers.v1']}${repository}`;
        const versionsResponse = (await this.http.getJson(`${backendURL}/versions`)).body;
        if (!versionsResponse.versions) {
            logger_1.logger.trace(`Failed to retrieve version list for ${backendURL}`);
            return null;
        }
        const builds = versionsResponse.versions.find((value) => value.version === version);
        if (!builds) {
            logger_1.logger.trace(`No builds found for ${repository}:${version} on ${registryURL}`);
            return null;
        }
        const result = await (0, p_map_1.default)(builds.platforms, async (platform) => {
            const buildURL = `${backendURL}/${version}/download/${platform.os}/${platform.arch}`;
            try {
                const res = (await this.http.getJson(buildURL)).body;
                const newBuild = {
                    name: repository,
                    url: res.download_url,
                    version,
                    ...res,
                };
                return newBuild;
            }
            catch (err) {
                /* istanbul ignore next */
                if (err instanceof external_host_error_1.ExternalHostError) {
                    throw err;
                }
                logger_1.logger.debug({ err, url: buildURL }, 'Failed to retrieve build');
                return null;
            }
        }, { concurrency: 4 });
        // if any of the requests to build details have failed, return null
        if (result.some((value) => Boolean(value) === false)) {
            return null;
        }
        return result;
    }
    async getReleaseBackendIndex(backendLookUpName, version) {
        return (await this.http.getJson(`${TerraformProviderDatasource.defaultRegistryUrls[1]}/${backendLookUpName}/${version}/index.json`)).body;
    }
}
TerraformProviderDatasource.id = 'terraform-provider';
TerraformProviderDatasource.defaultRegistryUrls = [
    'https://registry.terraform.io',
    'https://releases.hashicorp.com',
];
TerraformProviderDatasource.repositoryRegex = (0, regex_1.regEx)(/^hashicorp\/(?<lookupName>\S+)$/);
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}`,
        key: (getReleasesConfig) => `${getReleasesConfig.registryUrl}/${TerraformProviderDatasource.getRepository(getReleasesConfig)}`,
    })
], TerraformProviderDatasource.prototype, "getReleases", null);
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}-builds`,
        key: (registryURL, repository, version) => `${registryURL}/${repository}/${version}`,
    })
], TerraformProviderDatasource.prototype, "getBuilds", null);
(0, tslib_1.__decorate)([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}-releaseBackendIndex`,
        key: (backendLookUpName, version) => `${backendLookUpName}/${version}`,
    })
], TerraformProviderDatasource.prototype, "getReleaseBackendIndex", null);
exports.TerraformProviderDatasource = TerraformProviderDatasource;
//# sourceMappingURL=index.js.map