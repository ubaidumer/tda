"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUrl = exports.commitFiles = exports.hasDiff = exports.getFile = exports.getBranchFiles = exports.getBranchLastCommitTime = exports.mergeBranch = exports.deleteBranch = exports.isBranchModified = exports.isBranchStale = exports.getBranchList = exports.getFileList = exports.checkoutBranch = exports.getCommitMessages = exports.getBranchParentSha = exports.getBranchCommit = exports.branchExists = exports.getRepoStatus = exports.syncGit = exports.getSubmodules = exports.setUserRepoConfig = exports.writeGitAuthor = exports.setGitAuthor = exports.initRepo = exports.setPrivateKey = exports.setNoVerify = void 0;
const tslib_1 = require("tslib");
const url_1 = (0, tslib_1.__importDefault)(require("url"));
const fs_extra_1 = (0, tslib_1.__importDefault)(require("fs-extra"));
const simple_git_1 = (0, tslib_1.__importStar)(require("simple-git"));
const upath_1 = require("upath");
const app_strings_1 = require("../../config/app-strings");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const limits_1 = require("../../workers/global/limits");
const regex_1 = require("../regex");
const author_1 = require("./author");
const config_1 = require("./config");
const private_key_1 = require("./private-key");
var config_2 = require("./config");
Object.defineProperty(exports, "setNoVerify", { enumerable: true, get: function () { return config_2.setNoVerify; } });
var private_key_2 = require("./private-key");
Object.defineProperty(exports, "setPrivateKey", { enumerable: true, get: function () { return private_key_2.setPrivateKey; } });
// istanbul ignore next
function checkForPlatformFailure(err) {
    if (process.env.NODE_ENV === 'test') {
        return;
    }
    const externalHostFailureStrings = [
        'remote: Invalid username or password',
        'gnutls_handshake() failed',
        'The requested URL returned error: 5',
        'The remote end hung up unexpectedly',
        'access denied or repository not exported',
        'Could not write new index file',
        'Failed to connect to',
        'Connection timed out',
        'malformed object name',
        'Could not resolve host',
        'early EOF',
        'fatal: bad config',
        'expected flush after ref listing',
    ];
    for (const errorStr of externalHostFailureStrings) {
        if (err.message.includes(errorStr)) {
            logger_1.logger.debug({ err }, 'Converting git error to ExternalHostError');
            throw new external_host_error_1.ExternalHostError(err, 'git');
        }
    }
    const configErrorStrings = [
        {
            error: 'GitLab: Branch name does not follow the pattern',
            message: "Cannot push because branch name does not follow project's push rules",
        },
        {
            error: 'GitLab: Commit message does not follow the pattern',
            message: "Cannot push because commit message does not follow project's push rules",
        },
        {
            error: ' is not a member of team',
            message: 'The `Restrict commits to existing GitLab users` rule is blocking Renovate push. Check the Renovate `gitAuthor` setting',
        },
        {
            error: 'TF401027:',
            message: 'You need the Git `GenericContribute` permission to perform this action',
        },
        {
            error: 'matches more than one',
            message: "Renovate cannot push branches if there are tags with names the same as Renovate's branches. Please remove conflicting tag names or change Renovate's branchPrefix to avoid conflicts.",
        },
    ];
    for (const { error, message } of configErrorStrings) {
        if (err.message.includes(error)) {
            logger_1.logger.debug({ err }, 'Converting git error to CONFIG_VALIDATION error');
            const res = new Error(error_messages_1.CONFIG_VALIDATION);
            res.validationError = message;
            res.validationMessage = err.message;
            throw res;
        }
    }
}
function localName(branchName) {
    return branchName.replace((0, regex_1.regEx)(/^origin\//), ''); // TODO #12071
}
async function isDirectory(dir) {
    try {
        return (await fs_extra_1.default.stat(dir)).isDirectory();
    }
    catch (err) {
        return false;
    }
}
async function getDefaultBranch(git) {
    // see https://stackoverflow.com/a/62352647/3005034
    try {
        const res = await git.raw(['rev-parse', '--abbrev-ref', 'origin/HEAD']);
        return res.replace('origin/', '').trim();
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        if (err.message.startsWith('fatal: ref refs/remotes/origin/HEAD is not a symbolic ref')) {
            throw new Error(error_messages_1.REPOSITORY_EMPTY);
        }
        // istanbul ignore if
        if (err.message.includes("fatal: ambiguous argument 'origin/HEAD'")) {
            logger_1.logger.warn({ err }, 'Error getting default branch');
            throw new Error(error_messages_1.TEMPORARY_ERROR);
        }
        throw err;
    }
}
let config = {};
let git;
let gitInitialized;
let privateKeySet = false;
async function fetchBranchCommits() {
    var _a;
    config.branchCommits = {};
    const opts = ['ls-remote', '--heads', config.url];
    if (config.extraCloneOpts) {
        Object.entries(config.extraCloneOpts).forEach((e) => opts.unshift(e[0], `${e[1]}`));
    }
    try {
        (await git.raw(opts))
            .split('\n')
            .filter(Boolean)
            .map((line) => line.trim().split((0, regex_1.regEx)(/\s+/))) // TODO #12071
            .forEach(([sha, ref]) => {
            config.branchCommits[ref.replace('refs/heads/', '')] = sha;
        });
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        logger_1.logger.debug({ err }, 'git error');
        if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('Please ask the owner to check their account')) {
            throw new Error(error_messages_1.REPOSITORY_DISABLED);
        }
        throw err;
    }
}
async function initRepo(args) {
    config = { ...args };
    config.ignoredAuthors = [];
    config.additionalBranches = [];
    config.branchIsModified = {};
    const { localDir } = global_1.GlobalConfig.get();
    git = (0, simple_git_1.default)(localDir, (0, config_1.simpleGitConfig)());
    gitInitialized = false;
    await fetchBranchCommits();
}
exports.initRepo = initRepo;
async function resetToBranch(branchName) {
    logger_1.logger.debug(`resetToBranch(${branchName})`);
    await git.raw(['reset', '--hard']);
    await git.checkout(branchName);
    await git.raw(['reset', '--hard', 'origin/' + branchName]);
    await git.raw(['clean', '-fd']);
}
async function deleteLocalBranch(branchName) {
    await git.branch(['-D', branchName]);
}
async function cleanLocalBranches() {
    const existingBranches = (await git.raw(['branch']))
        .split('\n')
        .map((branch) => branch.trim())
        .filter((branch) => branch.length)
        .filter((branch) => !branch.startsWith('* '));
    logger_1.logger.debug({ existingBranches });
    for (const branchName of existingBranches) {
        await deleteLocalBranch(branchName);
    }
}
function setGitAuthor(gitAuthor) {
    const gitAuthorParsed = (0, author_1.parseGitAuthor)(gitAuthor || 'Renovate Bot <renovate@whitesourcesoftware.com>');
    if (!gitAuthorParsed) {
        const error = new Error(error_messages_1.CONFIG_VALIDATION);
        error.validationSource = 'None';
        error.validationError = 'Invalid gitAuthor';
        error.validationMessage = `gitAuthor is not parsed as valid RFC5322 format: ${gitAuthor}`;
        throw error;
    }
    config.gitAuthorName = gitAuthorParsed.name;
    config.gitAuthorEmail = gitAuthorParsed.address;
}
exports.setGitAuthor = setGitAuthor;
async function writeGitAuthor() {
    const { gitAuthorName, gitAuthorEmail } = config;
    try {
        if (gitAuthorName) {
            logger_1.logger.debug({ gitAuthorName }, 'Setting git author name');
            await git.addConfig('user.name', gitAuthorName);
        }
        if (gitAuthorEmail) {
            logger_1.logger.debug({ gitAuthorEmail }, 'Setting git author email');
            await git.addConfig('user.email', gitAuthorEmail);
        }
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        logger_1.logger.debug({ err, gitAuthorName, gitAuthorEmail }, 'Error setting git author config');
        throw new Error(error_messages_1.TEMPORARY_ERROR);
    }
}
exports.writeGitAuthor = writeGitAuthor;
function setUserRepoConfig({ gitIgnoredAuthors, gitAuthor, }) {
    config.ignoredAuthors = gitIgnoredAuthors !== null && gitIgnoredAuthors !== void 0 ? gitIgnoredAuthors : [];
    setGitAuthor(gitAuthor);
}
exports.setUserRepoConfig = setUserRepoConfig;
async function getSubmodules() {
    try {
        return ((await git.raw([
            'config',
            '--file',
            '.gitmodules',
            '--get-regexp',
            '\\.path',
        ])) || '')
            .trim()
            .split((0, regex_1.regEx)(/[\n\s]/))
            .filter((_e, i) => i % 2);
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.warn({ err }, 'Error getting submodules');
        return [];
    }
}
exports.getSubmodules = getSubmodules;
async function syncGit() {
    var _a;
    if (gitInitialized) {
        return;
    }
    gitInitialized = true;
    const { localDir } = global_1.GlobalConfig.get();
    logger_1.logger.debug('Initializing git repository into ' + localDir);
    const gitHead = (0, upath_1.join)(localDir, '.git/HEAD');
    let clone = true;
    if (await fs_extra_1.default.exists(gitHead)) {
        try {
            await git.raw(['remote', 'set-url', 'origin', config.url]);
            await resetToBranch(await getDefaultBranch(git));
            const fetchStart = Date.now();
            await git.pull();
            await git.fetch();
            config.currentBranch =
                config.currentBranch || (await getDefaultBranch(git));
            await resetToBranch(config.currentBranch);
            await cleanLocalBranches();
            await git.raw(['remote', 'prune', 'origin']);
            const durationMs = Math.round(Date.now() - fetchStart);
            logger_1.logger.info({ durationMs }, 'git fetch completed');
            clone = false;
        }
        catch (err) /* istanbul ignore next */ {
            if (err.message === error_messages_1.REPOSITORY_EMPTY) {
                throw err;
            }
            logger_1.logger.info({ err }, 'git fetch error');
        }
    }
    if (clone) {
        await fs_extra_1.default.emptyDir(localDir);
        const cloneStart = Date.now();
        try {
            const opts = [];
            if (config.fullClone) {
                logger_1.logger.debug('Performing full clone');
            }
            else {
                logger_1.logger.debug('Performing blobless clone');
                opts.push('--filter=blob:none');
            }
            if (config.extraCloneOpts) {
                Object.entries(config.extraCloneOpts).forEach((e) => opts.push(e[0], `${e[1]}`));
            }
            await git.clone(config.url, '.', opts);
        }
        catch (err) /* istanbul ignore next */ {
            logger_1.logger.debug({ err }, 'git clone error');
            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('No space left on device')) {
                throw new Error(error_messages_1.SYSTEM_INSUFFICIENT_DISK_SPACE);
            }
            if (err.message === error_messages_1.REPOSITORY_EMPTY) {
                throw err;
            }
            throw new external_host_error_1.ExternalHostError(err, 'git');
        }
        const durationMs = Math.round(Date.now() - cloneStart);
        logger_1.logger.debug({ durationMs }, 'git clone completed');
    }
    config.currentBranchSha = (await git.raw(['rev-parse', 'HEAD'])).trim();
    if (config.cloneSubmodules) {
        const submodules = await getSubmodules();
        for (const submodule of submodules) {
            try {
                logger_1.logger.debug(`Cloning git submodule at ${submodule}`);
                await git.submoduleUpdate(['--init', submodule]);
            }
            catch (err) {
                logger_1.logger.warn({ err }, `Unable to initialise git submodule at ${submodule}`);
            }
        }
    }
    try {
        const latestCommit = (await git.log({ n: 1 })).latest;
        logger_1.logger.debug({ latestCommit }, 'latest repository commit');
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        if (err.message.includes('does not have any commits yet')) {
            throw new Error(error_messages_1.REPOSITORY_EMPTY);
        }
        logger_1.logger.warn({ err }, 'Cannot retrieve latest commit');
    }
    config.currentBranch = config.currentBranch || (await getDefaultBranch(git));
}
exports.syncGit = syncGit;
// istanbul ignore next
async function getRepoStatus() {
    await syncGit();
    return git.status();
}
exports.getRepoStatus = getRepoStatus;
function branchExists(branchName) {
    return !!config.branchCommits[branchName];
}
exports.branchExists = branchExists;
// Return the commit SHA for a branch
function getBranchCommit(branchName) {
    return config.branchCommits[branchName] || null;
}
exports.getBranchCommit = getBranchCommit;
// Return the parent commit SHA for a branch
async function getBranchParentSha(branchName) {
    try {
        const branchSha = getBranchCommit(branchName);
        const parentSha = await git.revparse([`${branchSha}^`]);
        return parentSha;
    }
    catch (err) {
        logger_1.logger.debug({ err }, 'Error getting branch parent sha');
        return null;
    }
}
exports.getBranchParentSha = getBranchParentSha;
async function getCommitMessages() {
    await syncGit();
    logger_1.logger.debug('getCommitMessages');
    const res = await git.log({
        n: 10,
        format: { message: '%s' },
    });
    return res.all.map((commit) => commit.message);
}
exports.getCommitMessages = getCommitMessages;
async function checkoutBranch(branchName) {
    var _a, _b, _c;
    logger_1.logger.debug(`Setting current branch to ${branchName}`);
    await syncGit();
    try {
        config.currentBranch = branchName;
        config.currentBranchSha = (await git.raw(['rev-parse', 'origin/' + branchName])).trim();
        await git.checkout(['-f', branchName, '--']);
        const latestCommitDate = (_b = (_a = (await git.log({ n: 1 }))) === null || _a === void 0 ? void 0 : _a.latest) === null || _b === void 0 ? void 0 : _b.date;
        if (latestCommitDate) {
            logger_1.logger.debug({ branchName, latestCommitDate }, 'latest commit');
        }
        await git.reset(simple_git_1.ResetMode.HARD);
        return config.currentBranchSha;
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        if ((_c = err.message) === null || _c === void 0 ? void 0 : _c.includes('fatal: ambiguous argument')) {
            logger_1.logger.warn({ err }, 'Failed to checkout branch');
            throw new Error(error_messages_1.TEMPORARY_ERROR);
        }
        throw err;
    }
}
exports.checkoutBranch = checkoutBranch;
async function getFileList() {
    var _a;
    await syncGit();
    const branch = config.currentBranch;
    const submodules = await getSubmodules();
    let files;
    try {
        files = await git.raw(['ls-tree', '-r', branch]);
    }
    catch (err) /* istanbul ignore next */ {
        if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('fatal: Not a valid object name')) {
            logger_1.logger.debug({ err }, 'Branch not found when checking branch list - aborting');
            throw new Error(error_messages_1.REPOSITORY_CHANGED);
        }
        throw err;
    }
    // istanbul ignore if
    if (!files) {
        return [];
    }
    return files
        .split('\n')
        .filter(Boolean)
        .filter((line) => line.startsWith('100'))
        .map((line) => line.split((0, regex_1.regEx)(/\t/)).pop()) // TODO #12071
        .filter((file) => submodules.every((submodule) => !file.startsWith(submodule)));
}
exports.getFileList = getFileList;
function getBranchList() {
    return Object.keys(config.branchCommits);
}
exports.getBranchList = getBranchList;
async function isBranchStale(branchName) {
    await syncGit();
    try {
        const { currentBranchSha, currentBranch } = config;
        const branches = await git.branch([
            '--remotes',
            '--verbose',
            '--contains',
            config.currentBranchSha,
        ]);
        const isStale = !branches.all.map(localName).includes(branchName);
        logger_1.logger.debug({ isStale, currentBranch, currentBranchSha }, `isBranchStale=${isStale}`);
        return isStale;
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        throw err;
    }
}
exports.isBranchStale = isBranchStale;
async function isBranchModified(branchName) {
    var _a;
    await syncGit();
    // First check cache
    if (config.branchIsModified[branchName] !== undefined) {
        return config.branchIsModified[branchName];
    }
    if (!branchExists(branchName)) {
        logger_1.logger.debug({ branchName }, 'Branch does not exist - cannot check isModified');
        return false;
    }
    // Retrieve the author of the most recent commit
    let lastAuthor;
    try {
        lastAuthor = (await git.raw([
            'log',
            '-1',
            '--pretty=format:%ae',
            `origin/${branchName}`,
            '--',
        ])).trim();
    }
    catch (err) /* istanbul ignore next */ {
        if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('fatal: bad revision')) {
            logger_1.logger.debug({ err }, 'Remote branch not found when checking last commit author - aborting run');
            throw new Error(error_messages_1.REPOSITORY_CHANGED);
        }
        logger_1.logger.warn({ err }, 'Error checking last author for isBranchModified');
    }
    const { gitAuthorEmail } = config;
    if (lastAuthor === gitAuthorEmail ||
        config.ignoredAuthors.some((ignoredAuthor) => lastAuthor === ignoredAuthor)) {
        // author matches - branch has not been modified
        config.branchIsModified[branchName] = false;
        return false;
    }
    logger_1.logger.debug({ branchName, lastAuthor, gitAuthorEmail }, 'Last commit author does not match git author email - branch has been modified');
    config.branchIsModified[branchName] = true;
    return true;
}
exports.isBranchModified = isBranchModified;
async function deleteBranch(branchName) {
    await syncGit();
    try {
        await git.raw(['push', '--delete', 'origin', branchName]);
        logger_1.logger.debug({ branchName }, 'Deleted remote branch');
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        logger_1.logger.debug({ branchName }, 'No remote branch to delete');
    }
    try {
        await deleteLocalBranch(branchName);
        // istanbul ignore next
        logger_1.logger.debug({ branchName }, 'Deleted local branch');
    }
    catch (err) {
        checkForPlatformFailure(err);
        logger_1.logger.debug({ branchName }, 'No local branch to delete');
    }
    delete config.branchCommits[branchName];
}
exports.deleteBranch = deleteBranch;
async function mergeBranch(branchName) {
    let status;
    try {
        await syncGit();
        await git.reset(simple_git_1.ResetMode.HARD);
        await git.checkout(['-B', branchName, 'origin/' + branchName]);
        await git.checkout([
            '-B',
            config.currentBranch,
            'origin/' + config.currentBranch,
        ]);
        status = await git.status();
        await git.merge(['--ff-only', branchName]);
        await git.push('origin', config.currentBranch);
        (0, limits_1.incLimitedValue)(limits_1.Limit.Commits);
    }
    catch (err) {
        logger_1.logger.debug({
            baseBranch: config.currentBranch,
            baseSha: config.currentBranchSha,
            branchName,
            branchSha: getBranchCommit(branchName),
            status,
            err,
        }, 'mergeBranch error');
        throw err;
    }
}
exports.mergeBranch = mergeBranch;
async function getBranchLastCommitTime(branchName) {
    await syncGit();
    try {
        const time = await git.show(['-s', '--format=%ai', 'origin/' + branchName]);
        return new Date(Date.parse(time));
    }
    catch (err) {
        checkForPlatformFailure(err);
        return new Date();
    }
}
exports.getBranchLastCommitTime = getBranchLastCommitTime;
async function getBranchFiles(branchName) {
    await syncGit();
    try {
        const diff = await git.diffSummary([
            `origin/${branchName}`,
            `origin/${branchName}^`,
        ]);
        return diff.files.map((file) => file.file);
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.warn({ err }, 'getBranchFiles error');
        checkForPlatformFailure(err);
        return null;
    }
}
exports.getBranchFiles = getBranchFiles;
async function getFile(filePath, branchName) {
    await syncGit();
    try {
        const content = await git.show([
            'origin/' + (branchName || config.currentBranch) + ':' + filePath,
        ]);
        return content;
    }
    catch (err) {
        checkForPlatformFailure(err);
        return null;
    }
}
exports.getFile = getFile;
async function hasDiff(branchName) {
    await syncGit();
    try {
        return (await git.diff(['HEAD', branchName])) !== '';
    }
    catch (err) {
        return true;
    }
}
exports.hasDiff = hasDiff;
async function commitFiles({ branchName, files, message, force = false, }) {
    await syncGit();
    logger_1.logger.debug(`Committing files to branch ${branchName}`);
    if (!privateKeySet) {
        await (0, private_key_1.writePrivateKey)();
        privateKeySet = true;
    }
    const { localDir } = global_1.GlobalConfig.get();
    await (0, private_key_1.configSigningKey)(localDir);
    await writeGitAuthor();
    try {
        await git.reset(simple_git_1.ResetMode.HARD);
        await git.raw(['clean', '-fd']);
        await git.checkout(['-B', branchName, 'origin/' + config.currentBranch]);
        const deletedFiles = [];
        const addedModifiedFiles = [];
        const ignoredFiles = [];
        for (const file of files) {
            let fileName = file.name;
            // istanbul ignore if
            if (fileName === '|delete|') {
                fileName = file.contents;
                try {
                    await git.rm([fileName]);
                    deletedFiles.push(fileName);
                }
                catch (err) /* istanbul ignore next */ {
                    checkForPlatformFailure(err);
                    logger_1.logger.trace({ err, fileName }, 'Cannot delete file');
                    ignoredFiles.push(fileName);
                }
            }
            else {
                if (await isDirectory((0, upath_1.join)(localDir, fileName))) {
                    // This is usually a git submodule update
                    logger_1.logger.trace({ fileName }, 'Adding directory commit');
                }
                else {
                    let contents;
                    // istanbul ignore else
                    if (typeof file.contents === 'string') {
                        contents = Buffer.from(file.contents);
                    }
                    else {
                        contents = file.contents;
                    }
                    // some file systems including Windows don't support the mode
                    // so the index should be manually updated after adding the file
                    await fs_extra_1.default.outputFile((0, upath_1.join)(localDir, fileName), contents, {
                        mode: file.executable ? 0o777 : 0o666,
                    });
                }
                try {
                    // istanbul ignore next
                    const addParams = fileName === app_strings_1.configFileNames[0] ? ['-f', fileName] : fileName;
                    await git.add(addParams);
                    if (file.executable) {
                        await git.raw(['update-index', '--chmod=+x', fileName]);
                    }
                    addedModifiedFiles.push(fileName);
                }
                catch (err) /* istanbul ignore next */ {
                    if (!err.message.includes('The following paths are ignored by one of your .gitignore files')) {
                        throw err;
                    }
                    logger_1.logger.debug({ fileName }, 'Cannot commit ignored file');
                    ignoredFiles.push(file.name);
                }
            }
        }
        const commitOptions = {};
        if ((0, config_1.getNoVerify)().includes('commit')) {
            commitOptions['--no-verify'] = null;
        }
        const commitRes = await git.commit(message, [], commitOptions);
        if (commitRes.summary &&
            commitRes.summary.changes === 0 &&
            commitRes.summary.insertions === 0 &&
            commitRes.summary.deletions === 0) {
            logger_1.logger.warn({ commitRes }, 'Detected empty commit - aborting git push');
            return null;
        }
        logger_1.logger.debug({ deletedFiles, ignoredFiles, result: commitRes }, `git commit`);
        const commit = (commitRes === null || commitRes === void 0 ? void 0 : commitRes.commit) || 'unknown';
        if (!force && !(await hasDiff(`origin/${branchName}`))) {
            logger_1.logger.debug({ branchName, deletedFiles, addedModifiedFiles, ignoredFiles }, 'No file changes detected. Skipping commit');
            return null;
        }
        const pushOptions = {
            '--force-with-lease': null,
            '-u': null,
        };
        if ((0, config_1.getNoVerify)().includes('push')) {
            pushOptions['--no-verify'] = null;
        }
        const pushRes = await git.push('origin', `${branchName}:${branchName}`, pushOptions);
        delete pushRes.repo;
        logger_1.logger.debug({ result: pushRes }, 'git push');
        // Fetch it after create
        const ref = `refs/heads/${branchName}:refs/remotes/origin/${branchName}`;
        await git.fetch(['origin', ref, '--force']);
        config.branchCommits[branchName] = (await git.revparse([branchName])).trim();
        config.branchIsModified[branchName] = false;
        (0, limits_1.incLimitedValue)(limits_1.Limit.Commits);
        return commit;
    }
    catch (err) /* istanbul ignore next */ {
        checkForPlatformFailure(err);
        if (err.message.includes(`'refs/heads/renovate' exists`)) {
            const error = new Error(error_messages_1.CONFIG_VALIDATION);
            error.validationSource = 'None';
            error.validationError = 'An existing branch is blocking Renovate';
            error.validationMessage = `Renovate needs to create the branch "${branchName}" but is blocked from doing so because of an existing branch called "renovate". Please remove it so that Renovate can proceed.`;
            throw error;
        }
        if (err.message.includes('refusing to allow a GitHub App to create or update workflow')) {
            logger_1.logger.warn('App has not been granted permissions to update Workflows - aborting branch.');
            return null;
        }
        if ((err.message.includes('remote rejected') ||
            err.message.includes('403')) &&
            (files === null || files === void 0 ? void 0 : files.some((file) => { var _a; return (_a = file.name) === null || _a === void 0 ? void 0 : _a.startsWith('.github/workflows/'); }))) {
            logger_1.logger.debug({ err }, 'commitFiles error');
            logger_1.logger.info('Workflows update rejection - aborting branch.');
            return null;
        }
        if (err.message.includes('protected branch hook declined')) {
            const error = new Error(error_messages_1.CONFIG_VALIDATION);
            error.validationSource = branchName;
            error.validationError = 'Renovate branch is protected';
            error.validationMessage = `Renovate cannot push to its branch because branch protection has been enabled.`;
            throw error;
        }
        if (err.message.includes('can only push your own commits')) {
            const error = new Error(error_messages_1.CONFIG_VALIDATION);
            error.validationSource = branchName;
            error.validationError = 'Bitbucket committer error';
            error.validationMessage = `Renovate has experienced the following error when attempting to push its branch to the server: "${String(err.message)}"`;
            throw error;
        }
        if (err.message.includes('remote: error: cannot lock ref')) {
            logger_1.logger.error({ err }, 'Error committing files.');
            return null;
        }
        if (err.message.includes('[rejected] (stale info)')) {
            logger_1.logger.info('Branch update was rejected because local copy is not up-to-date.');
            return null;
        }
        if (err.message.includes('denying non-fast-forward') ||
            err.message.includes('GH003: Sorry, force-pushing')) {
            logger_1.logger.debug({ err }, 'Permission denied to update branch');
            const error = new Error(error_messages_1.CONFIG_VALIDATION);
            error.validationSource = branchName;
            error.validationError = 'Force push denied';
            error.validationMessage = `Renovate is unable to update branch(es) due to force pushes being disallowed.`;
            throw error;
        }
        logger_1.logger.debug({ err }, 'Unknown error committing files');
        // We don't know why this happened, so this will cause bubble up to a branch error
        throw err;
    }
}
exports.commitFiles = commitFiles;
function getUrl({ protocol, auth, hostname, host, repository, }) {
    if (protocol === 'ssh') {
        return `git@${hostname}:${repository}.git`;
    }
    return url_1.default.format({
        protocol: protocol || 'https',
        auth,
        hostname,
        host,
        pathname: repository + '.git',
    });
}
exports.getUrl = getUrl;
//# sourceMappingURL=index.js.map