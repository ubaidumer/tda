{"version":3,"file":"modules.js","sourceRoot":"","sources":["../../lib/util/modules.ts"],"names":[],"mappings":";;;;AAAA,yDAAoB;AACpB,iCAA4C;AAC5C,mCAAgC;AAEhC,SAAS,UAAU,CAAC,IAAY,EAAE,KAAa;IAC7C,MAAM,UAAU,GAAG,IAAA,qBAAa,EAAC,KAAK,CAAC,CAAC,KAAK,CAAC,IAAA,aAAK,EAAC,OAAO,CAAC,CAAC,CAAC;IAC9D,MAAM,SAAS,GAAG,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAA,aAAK,EAAC,OAAO,CAAC,CAAC,CAAC;IAE5D,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,OACE,OAAO,UAAU,CAAC,GAAG,CAAC,KAAK,QAAQ;QACnC,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,QAAQ;QAClC,UAAU,CAAC,GAAG,CAAC,KAAK,SAAS,CAAC,GAAG,CAAC,EAClC;QACA,GAAG,IAAI,CAAC,CAAC;KACV;IAED,MAAM,MAAM,GAAG,EAAE,CAAC;IAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE;QAClD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACnB;IACD,KAAK,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;QAC/C,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;KAC9B;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1B,CAAC;AAED,SAAgB,WAAW,CACzB,OAAe,EACf,QAAsD,EACtD,SAA2C,GAAG,EAAE,CAAC,IAAI;IAErD,MAAM,MAAM,GAAsB,EAAE,CAAC;IAErC,MAAM,WAAW,GAAa,YAAE;SAC7B,WAAW,CAAC,OAAO,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,CAAC;SAC7C,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;SACxC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC;SAC5B,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SACxC,MAAM,CAAC,MAAM,CAAC;SACd,IAAI,EAAE,CAAC;IAEV,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;QACpC,MAAM,UAAU,GAAG,IAAA,YAAI,EAAC,UAAU,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC;QACpE,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,sBAAsB;QAC1D,qBAAqB;QACrB,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC,EAAE;YAC1D,MAAM,IAAI,KAAK,CAAC,mBAAmB,UAAU,EAAE,CAAC,CAAC;SAClD;QACD,MAAM,CAAC,UAAU,CAAC,GAAG,MAAW,CAAC;KAClC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AA1BD,kCA0BC","sourcesContent":["import fs from 'fs';\nimport { join, normalizeTrim } from 'upath';\nimport { regEx } from './regex';\n\nfunction relatePath(here: string, there: string): string {\n  const thereParts = normalizeTrim(there).split(regEx(/[\\\\/]/));\n  const hereParts = normalizeTrim(here).split(regEx(/[\\\\/]/));\n\n  let idx = 0;\n  while (\n    typeof thereParts[idx] === 'string' &&\n    typeof hereParts[idx] === 'string' &&\n    thereParts[idx] === hereParts[idx]\n  ) {\n    idx += 1;\n  }\n\n  const result = [];\n  for (let x = 0; x < hereParts.length - idx; x += 1) {\n    result.push('..');\n  }\n  for (let y = idx; y < thereParts.length; y += 1) {\n    result.push(thereParts[idx]);\n  }\n  return result.join('/');\n}\n\nexport function loadModules<T>(\n  dirname: string,\n  validate?: (module: T, moduleName?: string) => boolean,\n  filter: (moduleName?: string) => boolean = () => true\n): Record<string, T> {\n  const result: Record<string, T> = {};\n\n  const moduleNames: string[] = fs\n    .readdirSync(dirname, { withFileTypes: true })\n    .filter((dirent) => dirent.isDirectory())\n    .map((dirent) => dirent.name)\n    .filter((name) => !name.startsWith('__'))\n    .filter(filter)\n    .sort();\n\n  for (const moduleName of moduleNames) {\n    const modulePath = join(relatePath(__dirname, dirname), moduleName);\n    const module = require(modulePath); // eslint-disable-line\n    // istanbul ignore if\n    if (!module || (validate && !validate(module, moduleName))) {\n      throw new Error(`Invalid module: ${modulePath}`);\n    }\n    result[moduleName] = module as T;\n  }\n\n  return result;\n}\n"]}