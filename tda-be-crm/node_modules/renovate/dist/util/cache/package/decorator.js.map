{"version":3,"file":"decorator.js","sourceRoot":"","sources":["../../../../lib/util/cache/package/decorator.ts"],"names":[],"mappings":";;;;AAAA,uEAAkC;AAClC,6DAAkC;AA2BlC;;;GAGG;AACH,SAAS,QAAQ,CAAI,EAAc;IACjC,MAAM,MAAM,GAAiB,CAC3B,MAAM,EACN,GAAG,EACH,UAIC,EACD,EAAE;;mCALF,EAAA,mBAAa,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,GAAG,CAAC,mCAAI;YAC3D,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;YAClB,QAAQ,EAAE,IAAI;SACf;QAED,MAAM,EAAE,KAAK,EAAE,GAAG,UAAU,CAAC;QAE7B,OAAO,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE;YAC/B,KAAK,CAAU,GAAG,IAAW;gBAC3B,OAAO,EAAE,CAAC;oBACR,IAAI;oBACJ,QAAQ,EAAE,IAAI;oBACd,QAAQ,EAAE,GAAG,EAAE,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;iBACzC,CAAC,CAAC;YACL,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC;AAChB,CAAC;AAiCD;;GAEG;AACH,SAAgB,KAAK,CAAI,EACvB,SAAS,EACT,GAAG,EACH,SAAS,GAAG,GAAG,EAAE,CAAC,IAAI,EACtB,UAAU,GAAG,EAAE,GACC;IAChB,OAAO,QAAQ,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE;QACrD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE;YACpC,OAAO,QAAQ,EAAE,CAAC;SACnB;QAED,IAAI,cAAkC,CAAC;QACvC,IAAI,YAAE,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE;YACxB,cAAc,GAAG,SAAS,CAAC;SAC5B;aAAM,IAAI,YAAE,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;YAClC,cAAc,GAAG,SAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SAClD;QAED,IAAI,QAA4B,CAAC;QACjC,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YAClB,QAAQ,GAAG,GAAG,CAAC;SAChB;aAAM,IAAI,YAAE,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;YAC5B,QAAQ,GAAG,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SACtC;QAED,qBAAqB;QACrB,IAAI,CAAC,cAAc,IAAI,CAAC,QAAQ,EAAE;YAChC,OAAO,QAAQ,EAAE,CAAC;SACnB;QAED,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC,GAAG,CACzC,cAAc,EACd,QAAQ,CACT,CAAC;QAEF,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,OAAO,YAAY,CAAC;SACrB;QAED,MAAM,MAAM,GAAG,MAAM,QAAQ,EAAE,CAAC;QAEhC,sCAAsC;QACtC,IAAI,MAAM,KAAK,SAAS,EAAE;YACxB,MAAM,YAAY,CAAC,GAAG,CAAC,cAAc,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;SACtE;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC,CAAC;AACL,CAAC;AA/CD,sBA+CC","sourcesContent":["import is from '@sindresorhus/is';\nimport * as packageCache from '.';\n\ntype Handler<T> = (parameters: DecoratorParameters<T>) => Promise<unknown>;\ntype Method<T> = (this: T, ...args: any[]) => Promise<any>;\ntype Decorator<T> = <U extends T>(\n  target: U,\n  key: keyof U,\n  descriptor: TypedPropertyDescriptor<Method<T>>\n) => TypedPropertyDescriptor<Method<T>>;\n\ninterface DecoratorParameters<T, U extends any[] = any[]> {\n  /**\n   * Current call arguments.\n   */\n  args: U;\n\n  /**\n   * A callback to call the decorated method with the current arguments.\n   */\n  callback(): unknown;\n\n  /**\n   * Current call context.\n   */\n  instance: T;\n}\n\n/**\n * Applies decorating function to intercept decorated method calls.\n * @param fn - The decorating function.\n */\nfunction decorate<T>(fn: Handler<T>): Decorator<T> {\n  const result: Decorator<T> = (\n    target,\n    key,\n    descriptor = Object.getOwnPropertyDescriptor(target, key) ?? {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    }\n  ) => {\n    const { value } = descriptor;\n\n    return Object.assign(descriptor, {\n      value(this: T, ...args: any[]) {\n        return fn({\n          args,\n          instance: this,\n          callback: () => value?.apply(this, args),\n        });\n      },\n    });\n  };\n\n  return result;\n}\n\ntype HashFunction<T extends any[] = any[]> = (...args: T) => string;\ntype BooleanFunction<T extends any[] = any[]> = (...args: T) => boolean;\n\n/**\n * The cache decorator parameters.\n */\ninterface CacheParameters {\n  /**\n   * The cache namespace\n   * Either a string or a hash function that generates a string\n   */\n  namespace: string | HashFunction;\n\n  /**\n   * The cache key\n   * Either a string or a hash function that generates a string\n   */\n  key: string | HashFunction;\n\n  /**\n   * A function that returns true if a result is cacheable\n   * Used to prevent caching of private, sensitive, results\n   */\n  cacheable?: BooleanFunction;\n\n  /**\n   * The TTL (or expiry) of the key in minutes\n   */\n  ttlMinutes?: number;\n}\n\n/**\n * caches the result of a decorated method.\n */\nexport function cache<T>({\n  namespace,\n  key,\n  cacheable = () => true,\n  ttlMinutes = 30,\n}: CacheParameters): Decorator<T> {\n  return decorate(async ({ args, instance, callback }) => {\n    if (!cacheable.apply(instance, args)) {\n      return callback();\n    }\n\n    let finalNamespace: string | undefined;\n    if (is.string(namespace)) {\n      finalNamespace = namespace;\n    } else if (is.function_(namespace)) {\n      finalNamespace = namespace.apply(instance, args);\n    }\n\n    let finalKey: string | undefined;\n    if (is.string(key)) {\n      finalKey = key;\n    } else if (is.function_(key)) {\n      finalKey = key.apply(instance, args);\n    }\n\n    // istanbul ignore if\n    if (!finalNamespace || !finalKey) {\n      return callback();\n    }\n\n    const cachedResult = await packageCache.get<unknown>(\n      finalNamespace,\n      finalKey\n    );\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    const result = await callback();\n\n    // only cache if we got a valid result\n    if (result !== undefined) {\n      await packageCache.set(finalNamespace, finalKey, result, ttlMinutes);\n    }\n    return result;\n  });\n}\n"]}