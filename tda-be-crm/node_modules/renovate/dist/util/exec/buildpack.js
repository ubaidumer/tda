"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInstallCommands = exports.resolveConstraint = void 0;
const tslib_1 = require("tslib");
const shlex_1 = require("shlex");
const datasource_1 = require("../../datasource");
const logger_1 = require("../../logger");
const allVersioning = (0, tslib_1.__importStar)(require("../../versioning"));
const composer_1 = require("../../versioning/composer");
const semver_1 = require("../../versioning/semver");
const allToolConfig = {
    composer: {
        datasource: 'github-releases',
        depName: 'composer/composer',
        versioning: composer_1.id,
    },
    jb: {
        datasource: 'github-releases',
        depName: 'jsonnet-bundler/jsonnet-bundler',
        versioning: semver_1.id,
    },
};
async function resolveConstraint(toolConstraint) {
    var _a;
    const { toolName } = toolConstraint;
    const toolConfig = allToolConfig[toolName];
    if (!toolConfig) {
        throw new Error(`Invalid tool to install: ${toolName}`);
    }
    const versioning = allVersioning.get(toolConfig.versioning);
    let constraint = toolConstraint.constraint;
    if (constraint) {
        if (versioning.isValid(constraint)) {
            if (versioning.isSingleVersion(constraint)) {
                return constraint;
            }
        }
        else {
            logger_1.logger.warn({ toolName, constraint }, 'Invalid tool constraint');
            constraint = undefined;
        }
    }
    const pkgReleases = await (0, datasource_1.getPkgReleases)(toolConfig);
    if (!((_a = pkgReleases === null || pkgReleases === void 0 ? void 0 : pkgReleases.releases) === null || _a === void 0 ? void 0 : _a.length)) {
        throw new Error('No tool releases found.');
    }
    const allVersions = pkgReleases.releases.map((r) => r.version);
    const matchingVersions = allVersions.filter((v) => !constraint || versioning.matches(v, constraint));
    if (matchingVersions.length) {
        const resolvedVersion = matchingVersions.pop();
        logger_1.logger.debug({ toolName, constraint, resolvedVersion }, 'Resolved version');
        return resolvedVersion;
    }
    const latestVersion = allVersions.filter((v) => versioning.isStable(v)).pop();
    logger_1.logger.warn({ toolName, constraint, latestVersion }, 'No matching tool versions found for constraint - using latest version');
    return latestVersion;
}
exports.resolveConstraint = resolveConstraint;
async function generateInstallCommands(toolConstraints) {
    const installCommands = [];
    if (toolConstraints === null || toolConstraints === void 0 ? void 0 : toolConstraints.length) {
        for (const toolConstraint of toolConstraints) {
            const toolVersion = await resolveConstraint(toolConstraint);
            const installCommand = `install-tool ${toolConstraint.toolName} ${(0, shlex_1.quote)(toolVersion)}`;
            installCommands.push(installCommand);
        }
    }
    return installCommands;
}
exports.generateInstallCommands = generateInstallCommands;
//# sourceMappingURL=buildpack.js.map