"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exec = void 0;
const upath_1 = require("upath");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const buildpack_1 = require("./buildpack");
const common_1 = require("./common");
const docker_1 = require("./docker");
const env_1 = require("./env");
function getChildEnv({ extraEnv = {}, env: forcedEnv = {}, }) {
    const globalConfigEnv = global_1.GlobalConfig.get('customEnvVariables');
    const inheritedKeys = Object.entries(extraEnv).reduce((acc, [key, val]) => val === null || val === undefined ? acc : [...acc, key], []);
    const parentEnv = (0, env_1.getChildProcessEnv)(inheritedKeys);
    const childEnv = Object.entries({
        ...extraEnv,
        ...parentEnv,
        ...globalConfigEnv,
        ...forcedEnv,
    }).reduce((acc, [key, val]) => val === null || val === undefined
        ? acc
        : { ...acc, [key]: val.toString() }, {});
    return childEnv;
}
function dockerEnvVars(extraEnv, childEnv) {
    const extraEnvKeys = Object.keys(extraEnv || {});
    return extraEnvKeys.filter((key) => typeof childEnv[key] === 'string' && childEnv[key].length > 0);
}
function getCwd({ cwd, cwdFile }) {
    const defaultCwd = global_1.GlobalConfig.get('localDir');
    const paramCwd = cwdFile ? (0, upath_1.join)(defaultCwd, (0, upath_1.dirname)(cwdFile)) : cwd;
    return paramCwd || defaultCwd;
}
function getRawExecOptions(opts) {
    const defaultExecutionTimeout = global_1.GlobalConfig.get('executionTimeout');
    const execOptions = { ...opts };
    delete execOptions.extraEnv;
    delete execOptions.docker;
    delete execOptions.cwdFile;
    delete execOptions.toolConstraints;
    const childEnv = getChildEnv(opts);
    const cwd = getCwd(opts);
    const rawExecOptions = {
        encoding: 'utf-8',
        ...execOptions,
        env: childEnv,
        cwd,
    };
    // Set default timeout config.executionTimeout if specified; othrwise to 15 minutes
    if (!rawExecOptions.timeout) {
        if (defaultExecutionTimeout) {
            rawExecOptions.timeout = defaultExecutionTimeout * 60 * 1000;
        }
        else {
            rawExecOptions.timeout = 15 * 60 * 1000;
        }
    }
    // Set default max buffer size to 10MB
    rawExecOptions.maxBuffer = rawExecOptions.maxBuffer || 10 * 1024 * 1024;
    return rawExecOptions;
}
function isDocker({ docker }) {
    const { binarySource } = global_1.GlobalConfig.get();
    return binarySource === 'docker' && !!docker;
}
async function prepareRawExec(cmd, opts = {}) {
    const { docker } = opts;
    const { customEnvVariables } = global_1.GlobalConfig.get();
    const rawOptions = getRawExecOptions(opts);
    let rawCommands = typeof cmd === 'string' ? [cmd] : cmd;
    if (isDocker(opts)) {
        logger_1.logger.debug('Using docker to execute');
        const extraEnv = { ...opts.extraEnv, ...customEnvVariables };
        const childEnv = getChildEnv(opts);
        const envVars = dockerEnvVars(extraEnv, childEnv);
        const cwd = getCwd(opts);
        const dockerOptions = { ...docker, cwd, envVars };
        dockerOptions.preCommands = [
            ...(await (0, buildpack_1.generateInstallCommands)(opts.toolConstraints)),
            ...(dockerOptions.preCommands || []),
        ];
        const dockerCommand = await (0, docker_1.generateDockerCommand)(rawCommands, dockerOptions);
        rawCommands = [dockerCommand];
    }
    return { rawCommands, rawOptions };
}
async function exec(cmd, opts = {}) {
    const { docker } = opts;
    const { dockerChildPrefix } = global_1.GlobalConfig.get();
    const { rawCommands, rawOptions } = await prepareRawExec(cmd, opts);
    const useDocker = isDocker(opts);
    let res = null;
    for (const rawCmd of rawCommands) {
        const startTime = Date.now();
        if (useDocker) {
            await (0, docker_1.removeDockerContainer)(docker.image, dockerChildPrefix);
        }
        logger_1.logger.debug({ command: rawCommands }, 'Executing command');
        logger_1.logger.trace({ commandOptions: rawOptions }, 'Command options');
        try {
            res = await (0, common_1.rawExec)(rawCmd, rawOptions);
        }
        catch (err) {
            logger_1.logger.debug({ err }, 'rawExec err');
            if (useDocker) {
                await (0, docker_1.removeDockerContainer)(docker.image, dockerChildPrefix).catch((removeErr) => {
                    const message = err.message;
                    throw new Error(`Error: "${removeErr.message}" - Original Error: "${message}"`);
                });
            }
            if (err.signal === `SIGTERM`) {
                logger_1.logger.debug({ err }, 'exec interrupted by SIGTERM - run needs to be aborted');
                throw new Error(error_messages_1.TEMPORARY_ERROR);
            }
            throw err;
        }
        const durationMs = Math.round(Date.now() - startTime);
        if (res) {
            logger_1.logger.debug({
                cmd: rawCmd,
                durationMs,
                stdout: res.stdout,
                stderr: res.stderr,
            }, 'exec completed');
        }
    }
    return res;
}
exports.exec = exec;
//# sourceMappingURL=index.js.map