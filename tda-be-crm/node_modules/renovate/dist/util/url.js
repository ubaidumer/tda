"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createURLFromHostOrURL = exports.parseUrl = exports.validateUrl = exports.getQueryString = exports.resolveBaseUrl = exports.trimTrailingSlash = exports.ensureTrailingSlash = exports.ensurePathPrefix = exports.joinUrlParts = void 0;
const tslib_1 = require("tslib");
const url_join_1 = (0, tslib_1.__importDefault)(require("url-join"));
const regex_1 = require("./regex");
function joinUrlParts(...parts) {
    return (0, url_join_1.default)(...parts);
}
exports.joinUrlParts = joinUrlParts;
function ensurePathPrefix(url, prefix) {
    const parsed = new URL(url);
    const fullPath = parsed.pathname + parsed.search;
    if (fullPath.startsWith(prefix)) {
        return url;
    }
    return parsed.origin + prefix + fullPath;
}
exports.ensurePathPrefix = ensurePathPrefix;
function ensureTrailingSlash(url) {
    return url.replace(/\/?$/, '/'); // TODO #12070 adds slash at the front when re2 is used
}
exports.ensureTrailingSlash = ensureTrailingSlash;
function trimTrailingSlash(url) {
    return url.replace((0, regex_1.regEx)(/\/+$/), '');
}
exports.trimTrailingSlash = trimTrailingSlash;
function resolveBaseUrl(baseUrl, input) {
    const inputString = input.toString();
    let host;
    let pathname;
    try {
        ({ host, pathname } = new URL(inputString));
    }
    catch (e) {
        pathname = inputString;
    }
    return host ? inputString : (0, url_join_1.default)(baseUrl, pathname || '');
}
exports.resolveBaseUrl = resolveBaseUrl;
function getQueryString(params) {
    const usp = new URLSearchParams();
    for (const [k, v] of Object.entries(params)) {
        if (Array.isArray(v)) {
            for (const item of v) {
                usp.append(k, item.toString());
            }
        }
        else {
            usp.append(k, v.toString());
        }
    }
    const res = usp.toString();
    return res;
}
exports.getQueryString = getQueryString;
function validateUrl(url, httpOnly = true) {
    if (!url) {
        return false;
    }
    try {
        const { protocol } = new URL(url);
        return httpOnly ? !!protocol.startsWith('http') : !!protocol;
    }
    catch (err) {
        return false;
    }
}
exports.validateUrl = validateUrl;
function parseUrl(url) {
    try {
        return new URL(url);
    }
    catch (err) {
        return null;
    }
}
exports.parseUrl = parseUrl;
/**
 * Tries to create an URL object from either a full URL string or a hostname
 * @param url either the full url or a hostname
 * @returns an URL object or null
 */
function createURLFromHostOrURL(url) {
    var _a;
    return (_a = parseUrl(url)) !== null && _a !== void 0 ? _a : parseUrl(`https://${url}`);
}
exports.createURLFromHostOrURL = createURLFromHostOrURL;
//# sourceMappingURL=url.js.map