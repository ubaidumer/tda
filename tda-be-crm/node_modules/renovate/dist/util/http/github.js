"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GithubHttp = exports.setBaseUrl = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const p_all_1 = (0, tslib_1.__importDefault)(require("p-all"));
const parse_link_header_1 = (0, tslib_1.__importDefault)(require("parse-link-header"));
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const mask_1 = require("../mask");
const regex_1 = require("../regex");
const _1 = require(".");
const githubBaseUrl = 'https://api.github.com/';
let baseUrl = githubBaseUrl;
const setBaseUrl = (url) => {
    baseUrl = url;
};
exports.setBaseUrl = setBaseUrl;
function handleGotError(err, url, opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const path = url.toString();
    let message = err.message || '';
    if (is_1.default.plainObject((_a = err.response) === null || _a === void 0 ? void 0 : _a.body) && 'message' in err.response.body) {
        message = String(err.response.body.message);
    }
    if (err.code === 'ENOTFOUND' ||
        err.code === 'ETIMEDOUT' ||
        err.code === 'EAI_AGAIN' ||
        err.code === 'ECONNRESET') {
        logger_1.logger.debug({ err }, 'GitHub failure: RequestError');
        throw new external_host_error_1.ExternalHostError(err, "github" /* Github */);
    }
    if (err.name === 'ParseError') {
        logger_1.logger.debug({ err }, '');
        throw new external_host_error_1.ExternalHostError(err, "github" /* Github */);
    }
    if (err.statusCode >= 500 && err.statusCode < 600) {
        logger_1.logger.debug({ err }, 'GitHub failure: 5xx');
        throw new external_host_error_1.ExternalHostError(err, "github" /* Github */);
    }
    if (err.statusCode === 403 &&
        message.startsWith('You have triggered an abuse detection mechanism')) {
        logger_1.logger.debug({ err }, 'GitHub failure: abuse detection');
        throw new Error(error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED);
    }
    if (err.statusCode === 403 &&
        message.startsWith('You have exceeded a secondary rate limit')) {
        logger_1.logger.debug({ err }, 'GitHub failure: secondary rate limit');
        throw new Error(error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED);
    }
    if (err.statusCode === 403 && message.includes('Upgrade to GitHub Pro')) {
        logger_1.logger.debug({ path }, 'Endpoint needs paid GitHub plan');
        throw err;
    }
    if (err.statusCode === 403 && message.includes('rate limit exceeded')) {
        logger_1.logger.debug({ err }, 'GitHub failure: rate limit');
        throw new Error(error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED);
    }
    if (err.statusCode === 403 &&
        message.startsWith('Resource not accessible by integration')) {
        logger_1.logger.debug({ err }, 'GitHub failure: Resource not accessible by integration');
        throw new Error(error_messages_1.PLATFORM_INTEGRATION_UNAUTHORIZED);
    }
    if (err.statusCode === 401 && message.includes('Bad credentials')) {
        const rateLimit = (_c = (_b = err.headers) === null || _b === void 0 ? void 0 : _b['x-ratelimit-limit']) !== null && _c !== void 0 ? _c : -1;
        logger_1.logger.debug({
            token: (0, mask_1.maskToken)(opts.token),
            err,
        }, 'GitHub failure: Bad credentials');
        if (rateLimit === '60') {
            throw new external_host_error_1.ExternalHostError(err, "github" /* Github */);
        }
        throw new Error(error_messages_1.PLATFORM_BAD_CREDENTIALS);
    }
    if (err.statusCode === 422) {
        if (message.includes('Review cannot be requested from pull request author')) {
            throw err;
        }
        else if ((_e = (_d = err.body) === null || _d === void 0 ? void 0 : _d.errors) === null || _e === void 0 ? void 0 : _e.find((e) => e.code === 'invalid')) {
            logger_1.logger.debug({ err }, 'Received invalid response - aborting');
            throw new Error(error_messages_1.REPOSITORY_CHANGED);
        }
        else if ((_g = (_f = err.body) === null || _f === void 0 ? void 0 : _f.errors) === null || _g === void 0 ? void 0 : _g.find((e) => { var _a; return (_a = e.message) === null || _a === void 0 ? void 0 : _a.startsWith('A pull request already exists'); })) {
            throw err;
        }
        logger_1.logger.debug({ err }, '422 Error thrown from GitHub');
        throw new external_host_error_1.ExternalHostError(err, "github" /* Github */);
    }
    if (err.statusCode === 410 &&
        ((_h = err.body) === null || _h === void 0 ? void 0 : _h.message) === 'Issues are disabled for this repo') {
        throw err;
    }
    if (err.statusCode === 404) {
        logger_1.logger.debug({ url: path }, 'GitHub 404');
    }
    else {
        logger_1.logger.debug({ err }, 'Unknown GitHub error');
    }
    throw err;
}
function constructAcceptString(input) {
    const defaultAccept = 'application/vnd.github.v3+json';
    const acceptStrings = typeof input === 'string' ? input.split((0, regex_1.regEx)(/\s*,\s*/)) : [];
    if (!acceptStrings.some((x) => x.startsWith('application/vnd.github.')) ||
        acceptStrings.length < 2) {
        acceptStrings.push(defaultAccept);
    }
    return acceptStrings.join(', ');
}
class GithubHttp extends _1.Http {
    constructor(hostType = "github" /* Github */, options) {
        super(hostType, options);
    }
    async request(url, options, okToRetry = true) {
        var _a, _b;
        let result = null;
        const opts = {
            baseUrl,
            ...options,
            throwHttpErrors: true,
        };
        const accept = constructAcceptString((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.accept);
        opts.headers = {
            ...opts.headers,
            accept,
        };
        try {
            result = await super.request(url, opts);
            // istanbul ignore else: Can result be null ???
            if (result !== null) {
                if (opts.paginate) {
                    // Check if result is paginated
                    const pageLimit = opts.pageLimit || 10;
                    const linkHeader = ((_b = result === null || result === void 0 ? void 0 : result.headers) === null || _b === void 0 ? void 0 : _b.link) &&
                        (0, parse_link_header_1.default)(result.headers.link);
                    if ((linkHeader === null || linkHeader === void 0 ? void 0 : linkHeader.next) && (linkHeader === null || linkHeader === void 0 ? void 0 : linkHeader.last)) {
                        let lastPage = +linkHeader.last.page;
                        // istanbul ignore else: needs a test
                        if (!process.env.RENOVATE_PAGINATE_ALL && opts.paginate !== 'all') {
                            lastPage = Math.min(pageLimit, lastPage);
                        }
                        const pageNumbers = Array.from(new Array(lastPage), (x, i) => i + 1).slice(1);
                        const queue = pageNumbers.map((page) => () => {
                            const nextUrl = new URL(linkHeader.next.url, baseUrl);
                            delete nextUrl.search;
                            nextUrl.searchParams.set('page', page.toString());
                            return this.request(nextUrl, { ...opts, paginate: false }, okToRetry);
                        });
                        const pages = await (0, p_all_1.default)(queue, { concurrency: 5 });
                        if (opts.paginationField) {
                            result.body[opts.paginationField] = result.body[opts.paginationField].concat(...pages
                                .filter(Boolean)
                                .map((page) => page.body[opts.paginationField]));
                        }
                        else {
                            result.body = result.body.concat(...pages.filter(Boolean).map((page) => page.body));
                        }
                    }
                }
            }
        }
        catch (err) {
            handleGotError(err, url, opts);
        }
        return result;
    }
    async requestGraphql(query, options = {}) {
        let result = null;
        const path = 'graphql';
        const { paginate, count = 100, cursor = null } = options;
        let { variables } = options;
        if (paginate) {
            variables = {
                ...variables,
                count,
                cursor,
            };
        }
        const body = variables ? { query, variables } : { query };
        const opts = {
            baseUrl: baseUrl.replace('/v3/', '/'),
            body,
            headers: { accept: options === null || options === void 0 ? void 0 : options.acceptHeader },
        };
        logger_1.logger.trace(`Performing Github GraphQL request`);
        try {
            const res = await this.postJson('graphql', opts);
            result = res === null || res === void 0 ? void 0 : res.body;
        }
        catch (err) {
            logger_1.logger.debug({ err, query, options }, 'Unexpected GraphQL Error');
            if (err instanceof external_host_error_1.ExternalHostError && count && count > 10) {
                logger_1.logger.info('Reducing pagination count to workaround graphql errors');
                return null;
            }
            handleGotError(err, path, opts);
        }
        return result;
    }
    async queryRepoField(query, fieldName, options = {}) {
        var _a, _b;
        const result = [];
        const { paginate = true } = options;
        let optimalCount = null;
        const initialCount = options.count || 100;
        let count = initialCount;
        let limit = options.limit || 1000;
        let cursor = null;
        let isIterating = true;
        while (isIterating) {
            const res = await this.requestGraphql(query, {
                ...options,
                count: Math.min(count, limit),
                cursor,
                paginate,
            });
            const fieldData = (_b = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.repository) === null || _b === void 0 ? void 0 : _b[fieldName];
            if (fieldData) {
                optimalCount = count;
                const { nodes = [], edges = [], pageInfo } = fieldData;
                result.push(...nodes);
                result.push(...edges);
                limit = Math.max(0, limit - nodes.length - edges.length);
                if (limit === 0) {
                    isIterating = false;
                }
                else if (paginate && pageInfo) {
                    const { hasNextPage, endCursor } = pageInfo;
                    if (hasNextPage && endCursor) {
                        cursor = endCursor;
                    }
                    else {
                        isIterating = false;
                    }
                }
            }
            else {
                count = Math.floor(count / 2);
                if (count === 0) {
                    logger_1.logger.warn({ query, options, res }, 'Error fetching GraphQL nodes');
                    isIterating = false;
                }
            }
            if (!paginate) {
                isIterating = false;
            }
        }
        // See: https://github.com/renovatebot/renovate/issues/12703
        // istanbul ignore if
        if (optimalCount &&
            optimalCount < initialCount && // log only shrinked results
            baseUrl === githubBaseUrl) {
            logger_1.logger.debug({ optimalCount }, 'Successful GraphQL query with shrinked pagination size');
        }
        return result;
    }
}
exports.GithubHttp = GithubHttp;
//# sourceMappingURL=github.js.map