"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clear = exports.getAll = exports.findAll = exports.hosts = exports.find = exports.add = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const deepmerge_1 = (0, tslib_1.__importDefault)(require("deepmerge"));
const logger_1 = require("../logger");
const clone_1 = require("./clone");
const sanitize = (0, tslib_1.__importStar)(require("./sanitize"));
const url_1 = require("./url");
let hostRules = [];
function migrateRule(rule) {
    const cloned = (0, clone_1.clone)(rule);
    delete cloned.hostName;
    delete cloned.domainName;
    delete cloned.baseUrl;
    const result = cloned;
    const { matchHost } = result;
    const { hostName, domainName, baseUrl } = rule;
    const hostValues = [matchHost, hostName, domainName, baseUrl].filter(Boolean);
    if (hostValues.length === 1) {
        const [matchHost] = hostValues;
        result.matchHost = matchHost;
    }
    else if (hostValues.length > 1) {
        throw new Error(`hostRules cannot contain more than one host-matching field - use "matchHost" only.`);
    }
    return result;
}
function add(params) {
    var _a;
    const rule = migrateRule(params);
    const confidentialFields = ['password', 'token'];
    if (rule.matchHost) {
        const parsedUrl = (0, url_1.parseUrl)(rule.matchHost);
        rule.resolvedHost = (_a = parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.hostname) !== null && _a !== void 0 ? _a : rule.matchHost;
        confidentialFields.forEach((field) => {
            if (rule[field]) {
                logger_1.logger.debug(`Adding ${field} authentication for ${rule.matchHost} to hostRules`);
            }
        });
    }
    confidentialFields.forEach((field) => {
        const secret = rule[field];
        if (is_1.default.string(secret) && secret.length > 3) {
            sanitize.add(secret);
        }
    });
    if (rule.username && rule.password) {
        const secret = Buffer.from(`${rule.username}:${rule.password}`).toString('base64');
        sanitize.add(secret);
    }
    hostRules.push(rule);
}
exports.add = add;
function isEmptyRule(rule) {
    return !rule.hostType && !rule.resolvedHost;
}
function isHostTypeRule(rule) {
    return !!rule.hostType && !rule.resolvedHost;
}
function isHostOnlyRule(rule) {
    return !rule.hostType && !!rule.matchHost;
}
function isMultiRule(rule) {
    return !!rule.hostType && !!rule.resolvedHost;
}
function matchesHostType(rule, search) {
    return rule.hostType === search.hostType;
}
function matchesHost(rule, search) {
    // istanbul ignore if
    if (!rule.matchHost) {
        return false;
    }
    if (search.url && (0, url_1.validateUrl)(rule.matchHost)) {
        return search.url.startsWith(rule.matchHost);
    }
    const parsedUrl = search.url ? (0, url_1.parseUrl)(search.url) : null;
    if (!(parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.hostname)) {
        return false;
    }
    const { hostname } = parsedUrl;
    const dotPrefixedMatchHost = rule.matchHost.startsWith('.')
        ? rule.matchHost
        : `.${rule.matchHost}`;
    return hostname === rule.matchHost || hostname.endsWith(dotPrefixedMatchHost);
}
function find(search) {
    if (!(search.hostType || search.url)) {
        logger_1.logger.warn({ search }, 'Invalid hostRules search');
        return {};
    }
    let res = {};
    // First, apply empty rule matches
    hostRules
        .filter((rule) => isEmptyRule(rule))
        .forEach((rule) => {
        res = (0, deepmerge_1.default)(res, rule);
    });
    // Next, find hostType-only matches
    hostRules
        .filter((rule) => isHostTypeRule(rule) && matchesHostType(rule, search))
        .forEach((rule) => {
        res = (0, deepmerge_1.default)(res, rule);
    });
    hostRules
        .filter((rule) => isHostOnlyRule(rule) && matchesHost(rule, search))
        .forEach((rule) => {
        res = (0, deepmerge_1.default)(res, rule);
    });
    // Finally, find combination matches
    hostRules
        .filter((rule) => isMultiRule(rule) &&
        matchesHostType(rule, search) &&
        matchesHost(rule, search))
        .forEach((rule) => {
        res = (0, deepmerge_1.default)(res, rule);
    });
    delete res.hostType;
    delete res.resolvedHost;
    delete res.matchHost;
    return res;
}
exports.find = find;
function hosts({ hostType }) {
    const result = [];
    for (const rule of hostRules) {
        if (rule.hostType === hostType && rule.resolvedHost) {
            result.push(rule.resolvedHost);
        }
    }
    return result;
}
exports.hosts = hosts;
function findAll({ hostType }) {
    return hostRules.filter((rule) => rule.hostType === hostType);
}
exports.findAll = findAll;
/**
 * @returns a deep copy of all known host rules without any filtering
 */
function getAll() {
    return (0, clone_1.clone)(hostRules);
}
exports.getAll = getAll;
function clear() {
    logger_1.logger.debug('Clearing hostRules');
    hostRules = [];
    sanitize.clear();
}
exports.clear = clear;
//# sourceMappingURL=host-rules.js.map