{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../lib/platform/bitbucket/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import url from 'url';\nimport type { MergeStrategy } from '../../config/types';\nimport { BranchStatus, PrState } from '../../types';\nimport { HttpOptions, HttpPostOptions, HttpResponse } from '../../util/http';\nimport { BitbucketHttp } from '../../util/http/bitbucket';\nimport type { Pr } from '../types';\nimport type { BitbucketMergeStrategy, MergeRequestBody } from './types';\n\nconst bitbucketHttp = new BitbucketHttp();\n\nexport interface Config {\n  defaultBranch: string;\n  has_issues: boolean;\n  mergeMethod: string;\n  owner: string;\n  prList: Pr[];\n  repository: string;\n  username: string;\n  userUuid: string;\n  ignorePrAuthor: boolean;\n}\n\nexport interface PagedResult<T = any> {\n  pagelen: number;\n  size?: number;\n  next?: string;\n  values: T[];\n}\n\nexport interface RepoInfo {\n  isFork: boolean;\n  owner: string;\n  mainbranch: string;\n  mergeMethod: string;\n  has_issues: boolean;\n}\n\nexport type BitbucketBranchState = 'SUCCESSFUL' | 'FAILED' | 'INPROGRESS';\nexport interface BitbucketStatus {\n  key: string;\n  state: BitbucketBranchState;\n}\n\nexport interface RepoInfoBody {\n  parent?: any;\n  owner: { username: string };\n  mainbranch: { name: string };\n  has_issues: boolean;\n}\n\nexport function repoInfoTransformer(repoInfoBody: RepoInfoBody): RepoInfo {\n  return {\n    isFork: !!repoInfoBody.parent,\n    owner: repoInfoBody.owner.username,\n    mainbranch: repoInfoBody.mainbranch.name,\n    mergeMethod: 'merge',\n    has_issues: repoInfoBody.has_issues,\n  };\n}\n\nconst bitbucketMergeStrategies: Map<MergeStrategy, BitbucketMergeStrategy> =\n  new Map([\n    ['squash', 'squash'],\n    ['merge-commit', 'merge_commit'],\n    ['fast-forward', 'fast_forward'],\n  ]);\n\nexport function mergeBodyTransformer(\n  mergeStrategy: MergeStrategy\n): MergeRequestBody {\n  const body: MergeRequestBody = {\n    close_source_branch: true,\n    message: 'auto merged',\n  };\n\n  // The `auto` strategy will use the strategy configured inside Bitbucket.\n  if (mergeStrategy !== 'auto') {\n    body.merge_strategy = bitbucketMergeStrategies.get(mergeStrategy);\n  }\n\n  return body;\n}\n\nexport const prStates = {\n  open: ['OPEN'],\n  notOpen: ['MERGED', 'DECLINED', 'SUPERSEDED'],\n  merged: ['MERGED'],\n  closed: ['DECLINED', 'SUPERSEDED'],\n  all: ['OPEN', 'MERGED', 'DECLINED', 'SUPERSEDED'],\n};\n\nexport const buildStates: Record<BranchStatus, BitbucketBranchState> = {\n  green: 'SUCCESSFUL',\n  red: 'FAILED',\n  yellow: 'INPROGRESS',\n};\n\nconst addMaxLength = (inputUrl: string, pagelen = 100): string => {\n  const { search, ...parsedUrl } = url.parse(inputUrl, true); // eslint-disable-line @typescript-eslint/no-unused-vars\n  const maxedUrl = url.format({\n    ...parsedUrl,\n    query: { ...parsedUrl.query, pagelen },\n  });\n  return maxedUrl;\n};\n\nfunction callApi<T>(\n  apiUrl: string,\n  method: string,\n  options?: HttpOptions | HttpPostOptions\n): Promise<HttpResponse<T>> {\n  /* istanbul ignore next */\n  switch (method.toLowerCase()) {\n    case 'post':\n      return bitbucketHttp.postJson<T>(apiUrl, options as HttpPostOptions);\n    case 'put':\n      return bitbucketHttp.putJson<T>(apiUrl, options as HttpPostOptions);\n    case 'patch':\n      return bitbucketHttp.patchJson<T>(apiUrl, options as HttpPostOptions);\n    case 'head':\n      return bitbucketHttp.headJson<T>(apiUrl, options);\n    case 'delete':\n      return bitbucketHttp.deleteJson<T>(apiUrl, options as HttpPostOptions);\n    case 'get':\n    default:\n      return bitbucketHttp.getJson<T>(apiUrl, options);\n  }\n}\n\nexport async function accumulateValues<T = any>(\n  reqUrl: string,\n  method = 'get',\n  options?: HttpOptions | HttpPostOptions,\n  pagelen?: number\n): Promise<T[]> {\n  let accumulator: T[] = [];\n  let nextUrl = addMaxLength(reqUrl, pagelen);\n\n  while (typeof nextUrl !== 'undefined') {\n    const { body } = await callApi<{ values: T[]; next: string }>(\n      nextUrl,\n      method,\n      options\n    );\n    accumulator = [...accumulator, ...body.values];\n    nextUrl = body.next;\n  }\n\n  return accumulator;\n}\n\ninterface Files {\n  chunks: {\n    changes: {\n      content: string;\n    }[];\n  }[];\n}\n\nexport function isConflicted(files: Files[]): boolean {\n  for (const file of files) {\n    for (const chunk of file.chunks) {\n      for (const change of chunk.changes) {\n        if (change.content === '+=======') {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport interface PrResponse {\n  id: number;\n  title: string;\n  state: string;\n  links: {\n    commits: {\n      href: string;\n    };\n  };\n  summary?: { raw: string };\n  source: {\n    branch: {\n      name: string;\n    };\n  };\n  destination: {\n    branch: {\n      name: string;\n    };\n  };\n  reviewers: Array<PrReviewer>;\n  created_on: string;\n}\n\nexport function prInfo(pr: PrResponse): Pr {\n  return {\n    number: pr.id,\n    displayNumber: `Pull Request #${pr.id}`,\n    body: pr.summary?.raw,\n    sourceBranch: pr.source?.branch?.name,\n    targetBranch: pr.destination?.branch?.name,\n    title: pr.title,\n    state: prStates.closed?.includes(pr.state)\n      ? /* istanbul ignore next */ PrState.Closed\n      : pr.state?.toLowerCase(),\n    createdAt: pr.created_on,\n  };\n}\n\nexport interface UserResponse {\n  display_name: string;\n  account_id: string;\n  nickname: string;\n  account_status: string;\n}\n\nexport interface PrReviewer {\n  display_name: string;\n  account_id: string;\n  nickname: string;\n}\n"]}