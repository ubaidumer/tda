"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRepoByName = exports.getProjectAndRepo = exports.max4000Chars = exports.getStorageExtraCloneOpts = exports.streamToString = exports.getRenovatePRFormat = exports.getBranchNameWithoutRefsPrefix = exports.getBranchNameWithoutRefsheadsPrefix = exports.getGitStatusContextFromCombinedName = exports.getGitStatusContextCombinedName = exports.getNewBranchName = void 0;
const GitInterfaces_1 = require("azure-devops-node-api/interfaces/GitInterfaces");
const logger_1 = require("../../logger");
const types_1 = require("../../types");
const sanitize_1 = require("../../util/sanitize");
function getNewBranchName(branchName) {
    if (branchName && !branchName.startsWith('refs/heads/')) {
        return `refs/heads/${branchName}`;
    }
    return branchName;
}
exports.getNewBranchName = getNewBranchName;
function getGitStatusContextCombinedName(context) {
    if (!context) {
        return undefined;
    }
    const combinedName = `${context.genre ? `${context.genre}/` : ''}${context.name}`;
    logger_1.logger.trace(`Got combined context name of ${combinedName}`);
    return combinedName;
}
exports.getGitStatusContextCombinedName = getGitStatusContextCombinedName;
function getGitStatusContextFromCombinedName(context) {
    if (!context) {
        return undefined;
    }
    let name = context;
    let genre;
    const lastSlash = context.lastIndexOf('/');
    if (lastSlash > 0) {
        name = context.substr(lastSlash + 1);
        genre = context.substr(0, lastSlash);
    }
    return {
        genre,
        name,
    };
}
exports.getGitStatusContextFromCombinedName = getGitStatusContextFromCombinedName;
function getBranchNameWithoutRefsheadsPrefix(branchPath) {
    if (!branchPath) {
        logger_1.logger.error(`getBranchNameWithoutRefsheadsPrefix(${branchPath})`);
        return undefined;
    }
    if (!branchPath.startsWith('refs/heads/')) {
        logger_1.logger.trace(`The refs/heads/ name should have started with 'refs/heads/' but it didn't. (${branchPath})`);
        return branchPath;
    }
    return branchPath.substring(11, branchPath.length);
}
exports.getBranchNameWithoutRefsheadsPrefix = getBranchNameWithoutRefsheadsPrefix;
function getBranchNameWithoutRefsPrefix(branchPath) {
    if (!branchPath) {
        logger_1.logger.error(`getBranchNameWithoutRefsPrefix(${branchPath})`);
        return undefined;
    }
    if (!branchPath.startsWith('refs/')) {
        logger_1.logger.trace(`The ref name should have started with 'refs/' but it didn't. (${branchPath})`);
        return branchPath;
    }
    return branchPath.substring(5, branchPath.length);
}
exports.getBranchNameWithoutRefsPrefix = getBranchNameWithoutRefsPrefix;
function getRenovatePRFormat(azurePr) {
    var _a;
    const number = azurePr.pullRequestId;
    const displayNumber = `Pull Request #${number}`;
    const sourceBranch = getBranchNameWithoutRefsheadsPrefix(azurePr.sourceRefName);
    const targetBranch = getBranchNameWithoutRefsheadsPrefix(azurePr.targetRefName);
    const body = azurePr.description;
    const createdAt = (_a = azurePr.creationDate) === null || _a === void 0 ? void 0 : _a.toISOString();
    const state = {
        [GitInterfaces_1.PullRequestStatus.Abandoned]: types_1.PrState.Closed,
        [GitInterfaces_1.PullRequestStatus.Completed]: types_1.PrState.Merged,
    }[azurePr.status] || types_1.PrState.Open;
    const sourceRefName = azurePr.sourceRefName;
    const isConflicted = azurePr.mergeStatus === GitInterfaces_1.PullRequestAsyncStatus.Conflicts;
    return {
        ...azurePr,
        sourceBranch,
        state,
        number,
        displayNumber,
        body,
        sourceRefName,
        targetBranch,
        createdAt,
        ...(isConflicted && { isConflicted }),
    };
}
exports.getRenovatePRFormat = getRenovatePRFormat;
async function streamToString(stream) {
    const chunks = [];
    const p = await new Promise((resolve, reject) => {
        stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
        stream.on('error', (err) => reject(err));
    });
    return p;
}
exports.streamToString = streamToString;
function toBase64(from) {
    return Buffer.from(from).toString('base64');
}
function getStorageExtraCloneOpts(config) {
    let authType;
    let authValue;
    if (!config.token && config.username && config.password) {
        authType = 'basic';
        authValue = toBase64(`${config.username}:${config.password}`);
    }
    else if (config.token.length === 52) {
        authType = 'basic';
        authValue = toBase64(`:${config.token}`);
    }
    else {
        authType = 'bearer';
        authValue = config.token;
    }
    (0, sanitize_1.add)(authValue);
    return {
        '-c': `http.extraheader=AUTHORIZATION: ${authType} ${authValue}`,
    };
}
exports.getStorageExtraCloneOpts = getStorageExtraCloneOpts;
function max4000Chars(str) {
    if (str && str.length >= 4000) {
        return str.substring(0, 3999);
    }
    return str;
}
exports.max4000Chars = max4000Chars;
function getProjectAndRepo(str) {
    logger_1.logger.trace(`getProjectAndRepo(${str})`);
    const strSplit = str.split(`/`);
    if (strSplit.length === 1) {
        return {
            project: str,
            repo: str,
        };
    }
    if (strSplit.length === 2) {
        return {
            project: strSplit[0],
            repo: strSplit[1],
        };
    }
    const msg = `${str} can be only structured this way : 'repository' or 'projectName/repository'!`;
    logger_1.logger.error(msg);
    throw new Error(msg);
}
exports.getProjectAndRepo = getProjectAndRepo;
function getRepoByName(name, repos) {
    logger_1.logger.trace(`getRepoByName(${name})`);
    let { project, repo } = getProjectAndRepo(name);
    project = project.toLowerCase();
    repo = repo.toLowerCase();
    return ((repos === null || repos === void 0 ? void 0 : repos.find((r) => {
        var _a, _b, _c;
        return project === ((_b = (_a = r === null || r === void 0 ? void 0 : r.project) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toLowerCase()) &&
            repo === ((_c = r === null || r === void 0 ? void 0 : r.name) === null || _c === void 0 ? void 0 : _c.toLowerCase());
    })) || null);
}
exports.getRepoByName = getRepoByName;
//# sourceMappingURL=util.js.map