"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlepr = void 0;
const global_1 = require("../../config/global");
const logger_1 = require("../../logger");
const platform_1 = require("../../platform");
const types_1 = require("../../types");
const git_1 = require("../../util/git");
async function handlepr(config, pr) {
    if (pr.state === types_1.PrState.Closed) {
        let content;
        if (config.updateType === 'major') {
            content = `As this PR has been closed unmerged, Renovate will ignore this upgrade and you will not receive PRs for *any* future ${config.newMajor}.x releases. However, if you upgrade to ${config.newMajor}.x manually then Renovate will then reenable updates for minor and patch updates automatically.`;
        }
        else if (config.updateType === 'digest') {
            content = `As this PR has been closed unmerged, Renovate will ignore this upgrade updateType and you will not receive PRs for *any* future ${config.depName}:${config.currentValue} digest updates. Digest updates will resume if you update the specified tag at any time.`;
        }
        else {
            content = `As this PR has been closed unmerged, Renovate will now ignore this update (${config.newValue}). You will still receive a PR once a newer version is released, so if you wish to permanently ignore this dependency, please add it to the \`ignoreDeps\` array of your renovate config.`;
        }
        content +=
            '\n\nIf this PR was closed by mistake or you changed your mind, you can simply rename this PR and you will soon get a fresh replacement PR opened.';
        if (!config.suppressNotifications.includes('prIgnoreNotification')) {
            const ignoreTopic = `Renovate Ignore Notification`;
            if (global_1.GlobalConfig.get('dryRun')) {
                logger_1.logger.info(`DRY-RUN: Would ensure closed PR comment in PR #${pr.number}`);
            }
            else {
                await platform_1.platform.ensureComment({
                    number: pr.number,
                    topic: ignoreTopic,
                    content,
                });
            }
        }
        if ((0, git_1.branchExists)(config.branchName)) {
            if (global_1.GlobalConfig.get('dryRun')) {
                logger_1.logger.info('DRY-RUN: Would delete branch ' + config.branchName);
            }
            else {
                await (0, git_1.deleteBranch)(config.branchName);
            }
        }
    }
    else if (pr.state === types_1.PrState.Merged) {
        logger_1.logger.debug({ pr: pr.number }, 'Merged PR is blocking this branch');
    }
}
exports.handlepr = handlepr;
//# sourceMappingURL=handle-existing.js.map