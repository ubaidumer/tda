"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isScheduledNow = exports.hasValidSchedule = exports.hasValidTimezone = void 0;
const tslib_1 = require("tslib");
const later_1 = (0, tslib_1.__importDefault)(require("@breejs/later"));
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const luxon_1 = require("luxon");
const logger_1 = require("../../logger");
const regex_1 = require("../../util/regex");
const scheduleMappings = {
    'every month': 'before 3am on the first day of the month',
    monthly: 'before 3am on the first day of the month',
};
function fixShortHours(input) {
    return input.replace((0, regex_1.regEx)(/( \d?\d)((a|p)m)/g), '$1:00$2');
}
function hasValidTimezone(timezone) {
    if (!luxon_1.DateTime.local().setZone(timezone).isValid) {
        return [false, `Invalid schedule: Unsupported timezone ${timezone}`];
    }
    return [true];
}
exports.hasValidTimezone = hasValidTimezone;
function hasValidSchedule(schedule) {
    let message;
    if (!schedule ||
        schedule === 'at any time' ||
        schedule[0] === 'at any time') {
        return [true];
    }
    // check if any of the schedules fail to parse
    const hasFailedSchedules = schedule.some((scheduleText) => {
        const massagedText = fixShortHours(scheduleMappings[scheduleText] || scheduleText);
        const parsedSchedule = later_1.default.parse.text(massagedText);
        if (parsedSchedule.error !== -1) {
            message = `Invalid schedule: Failed to parse "${scheduleText}"`;
            // It failed to parse
            return true;
        }
        if (parsedSchedule.schedules.some((s) => s.m)) {
            message = `Invalid schedule: "${scheduleText}" should not specify minutes`;
            return true;
        }
        if (!parsedSchedule.schedules.some((s) => s.M || s.d !== undefined || s.D || s.t_a !== undefined || s.t_b)) {
            message = `Invalid schedule: "${scheduleText}" has no months, days of week or time of day`;
            return true;
        }
        // It must be OK
        return false;
    });
    if (hasFailedSchedules) {
        // If any fail then we invalidate the whole thing
        return [false, message];
    }
    return [true, ''];
}
exports.hasValidSchedule = hasValidSchedule;
function isScheduledNow(config) {
    let configSchedule = config.schedule;
    logger_1.logger.debug(`Checking schedule(${String(configSchedule)}, ${config.timezone})`);
    if (!configSchedule ||
        configSchedule.length === 0 ||
        configSchedule[0] === '' ||
        configSchedule === 'at any time' ||
        configSchedule[0] === 'at any time') {
        logger_1.logger.debug('No schedule defined');
        return true;
    }
    if (!is_1.default.array(configSchedule)) {
        logger_1.logger.warn(`config schedule is not an array: ${JSON.stringify(configSchedule)}`);
        configSchedule = [configSchedule];
    }
    const [validSchedule, errorMessage] = hasValidSchedule(configSchedule);
    if (!validSchedule) {
        logger_1.logger.warn(errorMessage);
        return true;
    }
    let now = luxon_1.DateTime.local();
    logger_1.logger.trace(`now=${now.toISO()}`);
    // Adjust the time if repo is in a different timezone to renovate
    if (config.timezone) {
        logger_1.logger.debug({ timezone: config.timezone }, 'Found timezone');
        const [validTimezone, error] = hasValidTimezone(config.timezone);
        if (!validTimezone) {
            logger_1.logger.warn(error);
            return true;
        }
        logger_1.logger.debug('Adjusting now for timezone');
        now = now.setZone(config.timezone);
        logger_1.logger.trace(`now=${now.toISO()}`);
    }
    const currentDay = now.weekday;
    logger_1.logger.trace(`currentDay=${currentDay}`);
    // Get the number of seconds since midnight
    const currentSeconds = now
        .startOf('second')
        .diff(now.startOf('day'), 'seconds').seconds;
    logger_1.logger.trace(`currentSeconds=${currentSeconds}`);
    // Support a single string but massage to array for processing
    logger_1.logger.debug(`Checking ${configSchedule.length} schedule(s)`);
    // later is timezone agnostic (as in, it purely relies on the underlying UTC date/time that is stored in the Date),
    // which means we have to pass it a Date that has an underlying UTC date/time in the same timezone as the schedule
    const jsNow = now.setZone('utc', { keepLocalTime: true }).toJSDate();
    // We run if any schedule matches
    const isWithinSchedule = configSchedule.some((scheduleText) => {
        const massagedText = scheduleMappings[scheduleText] || scheduleText;
        const parsedSchedule = later_1.default.parse.text(fixShortHours(massagedText));
        logger_1.logger.debug({ parsedSchedule }, `Checking schedule "${scheduleText}"`);
        if (later_1.default.schedule(parsedSchedule).isValid(jsNow)) {
            logger_1.logger.debug(`Matches schedule ${scheduleText}`);
            return true;
        }
        return false;
    });
    if (!isWithinSchedule) {
        logger_1.logger.debug('Package not scheduled');
        return false;
    }
    return true;
}
exports.isScheduledNow = isScheduledNow;
//# sourceMappingURL=schedule.js.map