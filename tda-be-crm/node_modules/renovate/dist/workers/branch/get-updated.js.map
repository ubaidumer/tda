{"version":3,"file":"get-updated.js","sourceRoot":"","sources":["../../../lib/workers/branch/get-updated.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { WORKER_FILE_UPDATE_FAILED } from '../../constants/error-messages';\nimport { logger } from '../../logger';\nimport { get } from '../../manager';\nimport type { ArtifactError, PackageDependency } from '../../manager/types';\nimport { getFile } from '../../util/git';\nimport { File } from '../../util/git/types';\nimport type { BranchConfig } from '../types';\nimport { doAutoReplace } from './auto-replace';\n\nexport interface PackageFilesResult {\n  artifactErrors: ArtifactError[];\n  reuseExistingBranch?: boolean;\n  updatedPackageFiles: File[];\n  updatedArtifacts: File[];\n}\n\nexport async function getUpdatedPackageFiles(\n  config: BranchConfig\n): Promise<PackageFilesResult> {\n  logger.trace({ config });\n  const { reuseExistingBranch } = config;\n  logger.debug(\n    `manager.getUpdatedPackageFiles() reuseExistinbranch=${reuseExistingBranch}`\n  );\n  let updatedFileContents: Record<string, string> = {};\n  const nonUpdatedFileContents: Record<string, string> = {};\n  const packageFileManagers: Record<string, string> = {};\n  const packageFileUpdatedDeps: Record<string, PackageDependency[]> = {};\n  const lockFileMaintenanceFiles = [];\n  for (const upgrade of config.upgrades) {\n    const { manager, packageFile, lockFile, depName } = upgrade;\n    packageFileManagers[packageFile] = manager;\n    packageFileUpdatedDeps[packageFile] =\n      packageFileUpdatedDeps[packageFile] || [];\n    packageFileUpdatedDeps[packageFile].push({ ...upgrade });\n    let packageFileContent = updatedFileContents[packageFile];\n    if (!packageFileContent) {\n      packageFileContent = await getFile(\n        packageFile,\n        reuseExistingBranch ? config.branchName : config.baseBranch\n      );\n    }\n    // istanbul ignore if\n    if (reuseExistingBranch && !packageFileContent) {\n      logger.debug(\n        { packageFile, depName },\n        'Rebasing branch after file not found'\n      );\n      return getUpdatedPackageFiles({\n        ...config,\n        reuseExistingBranch: false,\n      });\n    }\n    if (upgrade.updateType === 'lockFileMaintenance') {\n      lockFileMaintenanceFiles.push(packageFile);\n    } else if (upgrade.isRemediation) {\n      let lockFileContent = updatedFileContents[lockFile];\n      if (!lockFileContent) {\n        lockFileContent = await getFile(\n          lockFile,\n          reuseExistingBranch ? config.branchName : config.baseBranch\n        );\n      }\n      // istanbul ignore if: to hard to test\n      if (reuseExistingBranch && !lockFileContent) {\n        logger.debug(\n          { lockFile, depName },\n          'Rebasing branch after lock file not found'\n        );\n        return getUpdatedPackageFiles({\n          ...config,\n          reuseExistingBranch: false,\n        });\n      }\n      const updateLockedDependency = get(manager, 'updateLockedDependency');\n      const files = await updateLockedDependency({\n        ...upgrade,\n        packageFileContent,\n        lockFileContent,\n      });\n      if (files) {\n        if (reuseExistingBranch) {\n          // This ensure it's always 1 commit from the bot\n          logger.debug(\n            { lockFile, depName },\n            'Need to update file(s) so will rebase first'\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        updatedFileContents = { ...updatedFileContents, ...files };\n      }\n    } else {\n      const bumpPackageVersion = get(manager, 'bumpPackageVersion');\n      const updateDependency = get(manager, 'updateDependency');\n      if (!updateDependency) {\n        let res = await doAutoReplace(\n          upgrade,\n          packageFileContent,\n          reuseExistingBranch\n        );\n        if (res) {\n          if (bumpPackageVersion && upgrade.bumpVersion) {\n            const { bumpedContent } = await bumpPackageVersion(\n              res,\n              upgrade.packageFileVersion,\n              upgrade.bumpVersion\n            );\n            res = bumpedContent;\n          }\n          if (res === packageFileContent) {\n            logger.debug({ packageFile, depName }, 'No content changed');\n            if (upgrade.rangeStrategy === 'update-lockfile') {\n              logger.debug({ packageFile, depName }, 'update-lockfile add');\n              nonUpdatedFileContents[packageFile] = res;\n            }\n          } else {\n            logger.debug({ packageFile, depName }, 'Contents updated');\n            updatedFileContents[packageFile] = res;\n          }\n          continue;\n        } else if (reuseExistingBranch) {\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.error({ packageFile, depName }, 'Could not autoReplace');\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      let newContent = await updateDependency({\n        fileContent: packageFileContent,\n        upgrade,\n      });\n      if (bumpPackageVersion && upgrade.bumpVersion) {\n        const { bumpedContent } = await bumpPackageVersion(\n          newContent,\n          upgrade.packageFileVersion,\n          upgrade.bumpVersion\n        );\n        newContent = bumpedContent;\n      }\n      if (!newContent) {\n        if (reuseExistingBranch) {\n          logger.debug(\n            { packageFile, depName },\n            'Rebasing branch after error updating content'\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          { existingContent: packageFileContent, config: upgrade },\n          'Error updating file'\n        );\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      if (newContent !== packageFileContent) {\n        if (reuseExistingBranch) {\n          // This ensure it's always 1 commit from the bot\n          logger.debug(\n            { packageFile, depName },\n            'Need to update package file so will rebase first'\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(`Updating ${depName} in ${packageFile || lockFile}`);\n        updatedFileContents[packageFile] = newContent;\n      }\n      if (newContent === packageFileContent) {\n        // istanbul ignore else\n        if (upgrade.manager === 'git-submodules') {\n          updatedFileContents[packageFile] = newContent;\n        } else if (upgrade.rangeStrategy === 'update-lockfile') {\n          nonUpdatedFileContents[packageFile] = newContent;\n        }\n      }\n    }\n  }\n  const updatedPackageFiles = Object.keys(updatedFileContents).map((name) => ({\n    name,\n    contents: updatedFileContents[name],\n  }));\n  const updatedArtifacts: File[] = [];\n  const artifactErrors: ArtifactError[] = [];\n  for (const packageFile of updatedPackageFiles) {\n    const manager = packageFileManagers[packageFile.name];\n    const updatedDeps = packageFileUpdatedDeps[packageFile.name];\n    const updateArtifacts = get(manager, 'updateArtifacts');\n    if (updateArtifacts) {\n      const results = await updateArtifacts({\n        packageFileName: packageFile.name,\n        updatedDeps,\n        newPackageFileContent: packageFile.contents,\n        config,\n      });\n      if (is.nonEmptyArray(results)) {\n        for (const res of results) {\n          const { file, artifactError } = res;\n          if (file) {\n            updatedArtifacts.push(file);\n          } else if (artifactError) {\n            artifactErrors.push(artifactError);\n          }\n        }\n      }\n    }\n  }\n  const nonUpdatedPackageFiles = Object.keys(nonUpdatedFileContents).map(\n    (name) => ({\n      name,\n      contents: nonUpdatedFileContents[name],\n    })\n  );\n  for (const packageFile of nonUpdatedPackageFiles) {\n    const manager = packageFileManagers[packageFile.name];\n    const updatedDeps = packageFileUpdatedDeps[packageFile.name];\n    const updateArtifacts = get(manager, 'updateArtifacts');\n    if (updateArtifacts) {\n      const results = await updateArtifacts({\n        packageFileName: packageFile.name,\n        updatedDeps,\n        newPackageFileContent: packageFile.contents,\n        config,\n      });\n      if (is.nonEmptyArray(results)) {\n        updatedPackageFiles.push(packageFile);\n        for (const res of results) {\n          const { file, artifactError } = res;\n          // istanbul ignore else\n          if (file) {\n            updatedArtifacts.push(file);\n          } else if (artifactError) {\n            artifactErrors.push(artifactError);\n          }\n        }\n      }\n    }\n  }\n  if (!reuseExistingBranch) {\n    // Only perform lock file maintenance if it's a fresh commit\n    for (const packageFile of lockFileMaintenanceFiles) {\n      const manager = packageFileManagers[packageFile];\n      const updateArtifacts = get(manager, 'updateArtifacts');\n      if (updateArtifacts) {\n        const packageFileContents =\n          updatedFileContents[packageFile] ||\n          (await getFile(\n            packageFile,\n            reuseExistingBranch ? config.branchName : config.baseBranch\n          ));\n        const results = await updateArtifacts({\n          packageFileName: packageFile,\n          updatedDeps: [],\n          newPackageFileContent: packageFileContents,\n          config,\n        });\n        if (is.nonEmptyArray(results)) {\n          for (const res of results) {\n            const { file, artifactError } = res;\n            if (file) {\n              updatedArtifacts.push(file);\n            } else if (artifactError) {\n              artifactErrors.push(artifactError);\n            }\n          }\n        }\n      }\n    }\n  }\n  return {\n    reuseExistingBranch, // Need to overwrite original config\n    updatedPackageFiles,\n    updatedArtifacts,\n    artifactErrors,\n  };\n}\n"]}