{"version":3,"file":"reuse.js","sourceRoot":"","sources":["../../../lib/workers/branch/reuse.ts"],"names":[],"mappings":"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","sourcesContent":["import { GlobalConfig } from '../../config/global';\nimport { logger } from '../../logger';\nimport { platform } from '../../platform';\nimport type { RangeStrategy } from '../../types';\nimport { branchExists, isBranchModified, isBranchStale } from '../../util/git';\nimport type { BranchConfig } from '../types';\n\ntype ParentBranch = {\n  reuseExistingBranch: boolean;\n  isModified?: boolean;\n};\n\nexport async function shouldReuseExistingBranch(\n  config: BranchConfig\n): Promise<ParentBranch> {\n  const { branchName } = config;\n  // Check if branch exists\n  if (!branchExists(branchName)) {\n    logger.debug(`Branch needs creating`);\n    return { reuseExistingBranch: false };\n  }\n  logger.debug(`Branch already exists`);\n\n  // Check for existing PR\n  const pr = await platform.getBranchPr(branchName);\n\n  if (pr) {\n    if (pr.title?.startsWith('rebase!')) {\n      logger.debug(`Manual rebase requested via PR title for #${pr.number}`);\n      return { reuseExistingBranch: false };\n    }\n    if (pr.body?.includes(`- [x] <!-- rebase-check -->`)) {\n      logger.debug(`Manual rebase requested via PR checkbox for #${pr.number}`);\n      return { reuseExistingBranch: false };\n    }\n    if (pr.labels?.includes(config.rebaseLabel)) {\n      logger.debug(`Manual rebase requested via PR labels for #${pr.number}`);\n      // istanbul ignore if\n      if (GlobalConfig.get('dryRun')) {\n        logger.info(\n          `DRY-RUN: Would delete label ${config.rebaseLabel} from #${pr.number}`\n        );\n      } else {\n        await platform.deleteLabel(pr.number, config.rebaseLabel);\n      }\n      return { reuseExistingBranch: false };\n    }\n  }\n\n  if (\n    config.rebaseWhen === 'behind-base-branch' ||\n    (config.rebaseWhen === 'auto' &&\n      (config.automerge || (await platform.getRepoForceRebase())))\n  ) {\n    if (await isBranchStale(branchName)) {\n      logger.debug(`Branch is stale and needs rebasing`);\n      // We can rebase the branch only if no PR or PR can be rebased\n      if (await isBranchModified(branchName)) {\n        // TODO: Warn here so that it appears in PR body (#9720)\n        logger.debug('Cannot rebase branch as it has been modified');\n        return { reuseExistingBranch: true, isModified: true };\n      }\n      return { reuseExistingBranch: false };\n    }\n    logger.debug('Branch is up-to-date');\n  } else {\n    logger.debug(\n      `Skipping stale branch check due to rebaseWhen=${config.rebaseWhen}`\n    );\n  }\n\n  // Now check if PR is unmergeable. If so then we also rebase\n  if (pr?.isConflicted) {\n    logger.debug('PR is conflicted');\n\n    if ((await isBranchModified(branchName)) === false) {\n      logger.debug(`Branch is not mergeable and needs rebasing`);\n      if (config.rebaseWhen === 'never') {\n        logger.debug('Rebasing disabled by config');\n        return { reuseExistingBranch: true, isModified: false };\n      }\n      // Setting reuseExistingBranch back to undefined means that we'll use the default branch\n      return { reuseExistingBranch: false };\n    }\n    // Don't do anything different, but warn\n    // TODO: Add warning to PR (#9720)\n    logger.debug(`Branch is not mergeable but can't be rebased`);\n  }\n  logger.debug(`Branch does not need rebasing`);\n\n  // Branches can get in an inconsistent state if \"update-lockfile\" is used at the same time as other strategies\n  // On the first execution, everything is executed, but if on a second execution the package.json modification is\n  // skipped but the lockfile update is executed, the lockfile will have a different result than if it was executed\n  // along with the changes to the package.json. Thus ending up with an incomplete branch update\n  // This is why we are skipping branch reuse in this case (#10050)\n  const groupedByPackageFile: Record<string, Set<RangeStrategy>> = {};\n  for (const upgrade of config.upgrades) {\n    groupedByPackageFile[upgrade.packageFile] =\n      groupedByPackageFile[upgrade.packageFile] || new Set();\n    groupedByPackageFile[upgrade.packageFile].add(upgrade.rangeStrategy);\n\n    if (\n      groupedByPackageFile[upgrade.packageFile].size > 1 &&\n      groupedByPackageFile[upgrade.packageFile].has('update-lockfile')\n    ) {\n      logger.debug(\n        `Detected multiple rangeStrategies along with update-lockfile`\n      );\n      return {\n        reuseExistingBranch: false,\n        isModified: false,\n      };\n    }\n  }\n\n  return { reuseExistingBranch: true, isModified: false };\n}\n"]}