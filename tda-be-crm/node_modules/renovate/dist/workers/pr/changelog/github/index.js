"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleaseList = exports.getReleaseNotesMd = exports.getTags = void 0;
const tslib_1 = require("tslib");
const changelog_filename_regex_1 = (0, tslib_1.__importDefault)(require("changelog-filename-regex"));
const logger_1 = require("../../../../logger");
const github_1 = require("../../../../util/http/github");
const url_1 = require("../../../../util/url");
const http = new github_1.GithubHttp();
async function getTags(endpoint, repository) {
    var _a;
    logger_1.logger.trace('github.getTags()');
    const url = `${endpoint}repos/${repository}/tags?per_page=100`;
    try {
        const res = await http.getJson(url, {
            paginate: true,
        });
        const tags = res.body;
        if (!tags.length) {
            logger_1.logger.debug({ repository }, 'repository has no Github tags');
        }
        return tags.map((tag) => tag.name).filter(Boolean);
    }
    catch (err) {
        logger_1.logger.debug({ sourceRepo: repository, err }, 'Failed to fetch Github tags');
        // istanbul ignore if
        if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('Bad credentials')) {
            logger_1.logger.warn('Bad credentials triggering tag fail lookup in changelog');
            throw err;
        }
        return [];
    }
}
exports.getTags = getTags;
async function getReleaseNotesMd(repository, apiBaseUrl, sourceDirectory) {
    logger_1.logger.trace('github.getReleaseNotesMd()');
    const apiPrefix = `${(0, url_1.ensureTrailingSlash)(apiBaseUrl)}repos/${repository}`;
    const { default_branch: defaultBranch = 'master' } = (await http.getJson(apiPrefix)).body;
    // https://docs.github.com/en/rest/reference/git#get-a-tree
    const res = await http.getJson(`${apiPrefix}/git/trees/${defaultBranch}${sourceDirectory ? '?recursive=1' : ''}`);
    // istanbul ignore if
    if (res.body.truncated) {
        logger_1.logger.debug({ repository }, 'Git tree truncated');
    }
    const allFiles = res.body.tree.filter((f) => f.type === 'blob');
    let files = [];
    if (sourceDirectory === null || sourceDirectory === void 0 ? void 0 : sourceDirectory.length) {
        files = allFiles
            .filter((f) => f.path.startsWith(sourceDirectory))
            .filter((f) => changelog_filename_regex_1.default.test(f.path.replace((0, url_1.ensureTrailingSlash)(sourceDirectory), '')));
    }
    if (!files.length) {
        files = allFiles.filter((f) => changelog_filename_regex_1.default.test(f.path));
    }
    if (!files.length) {
        logger_1.logger.trace('no changelog file found');
        return null;
    }
    const { path: changelogFile, sha } = files.shift();
    /* istanbul ignore if */
    if (files.length !== 0) {
        logger_1.logger.debug(`Multiple candidates for changelog file, using ${changelogFile}`);
    }
    // https://docs.github.com/en/rest/reference/git#get-a-blob
    const fileRes = await http.getJson(`${apiPrefix}/git/blobs/${sha}`);
    const changelogMd = Buffer.from(fileRes.body.content, 'base64').toString() + '\n#\n##';
    return { changelogFile, changelogMd };
}
exports.getReleaseNotesMd = getReleaseNotesMd;
async function getReleaseList(apiBaseUrl, repository) {
    logger_1.logger.trace('github.getReleaseList()');
    const url = `${(0, url_1.ensureTrailingSlash)(apiBaseUrl)}repos/${repository}/releases`;
    const res = await http.getJson(`${url}?per_page=100`, {
        paginate: true,
    });
    return res.body.map((release) => ({
        url: release.html_url,
        notesSourceUrl: url,
        id: release.id,
        tag: release.tag_name,
        name: release.name,
        body: release.body,
    }));
}
exports.getReleaseList = getReleaseList;
//# sourceMappingURL=index.js.map