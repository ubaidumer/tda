"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensurePr = exports.getPlatformPrOptions = exports.addAssigneesReviewers = void 0;
const tslib_1 = require("tslib");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const platform_1 = require("../../platform");
const types_1 = require("../../types");
const external_host_error_1 = require("../../types/errors/external-host-error");
const util_1 = require("../../util");
const emoji_1 = require("../../util/emoji");
const git_1 = require("../../util/git");
const regex_1 = require("../../util/regex");
const template = (0, tslib_1.__importStar)(require("../../util/template"));
const status_checks_1 = require("../branch/status-checks");
const limits_1 = require("../global/limits");
const body_1 = require("./body");
const types_2 = require("./changelog/types");
const code_owners_1 = require("./code-owners");
function noWhitespaceOrHeadings(input) {
    return input.replace((0, regex_1.regEx)(/\r?\n|\r|\s|#/g), '');
}
function noLeadingAtSymbol(input) {
    return input.length && input.startsWith('@') ? input.slice(1) : input;
}
async function addCodeOwners(assigneesOrReviewers, pr) {
    return [...new Set(assigneesOrReviewers.concat(await (0, code_owners_1.codeOwnersForPr)(pr)))];
}
function filterUnavailableUsers(config, users) {
    return config.filterUnavailableUsers && platform_1.platform.filterUnavailableUsers
        ? platform_1.platform.filterUnavailableUsers(users)
        : Promise.resolve(users);
}
function prepareAssigneesReviewers(config, usernames) {
    const normalizedUsernames = [...new Set(usernames.map(noLeadingAtSymbol))];
    return filterUnavailableUsers(config, normalizedUsernames);
}
async function addAssigneesReviewers(config, pr) {
    let assignees = config.assignees;
    logger_1.logger.debug(`addAssigneesReviewers(pr=${pr === null || pr === void 0 ? void 0 : pr.number})`);
    if (config.assigneesFromCodeOwners) {
        assignees = await addCodeOwners(assignees, pr);
    }
    if (assignees.length > 0) {
        try {
            assignees = await prepareAssigneesReviewers(config, assignees);
            if (config.assigneesSampleSize !== null) {
                assignees = (0, util_1.sampleSize)(assignees, config.assigneesSampleSize);
            }
            if (assignees.length > 0) {
                // istanbul ignore if
                if (global_1.GlobalConfig.get('dryRun')) {
                    logger_1.logger.info(`DRY-RUN: Would add assignees to PR #${pr.number}`);
                }
                else {
                    await platform_1.platform.addAssignees(pr.number, assignees);
                    logger_1.logger.debug({ assignees }, 'Added assignees');
                }
            }
        }
        catch (err) {
            logger_1.logger.debug({ assignees: config.assignees, err }, 'Failed to add assignees');
        }
    }
    let reviewers = config.reviewers;
    if (config.reviewersFromCodeOwners) {
        reviewers = await addCodeOwners(reviewers, pr);
    }
    if (config.additionalReviewers.length > 0) {
        reviewers = reviewers.concat(config.additionalReviewers);
    }
    if (reviewers.length > 0) {
        try {
            reviewers = await prepareAssigneesReviewers(config, reviewers);
            if (config.reviewersSampleSize !== null) {
                reviewers = (0, util_1.sampleSize)(reviewers, config.reviewersSampleSize);
            }
            if (reviewers.length > 0) {
                // istanbul ignore if
                if (global_1.GlobalConfig.get('dryRun')) {
                    logger_1.logger.info(`DRY-RUN: Would add reviewers to PR #${pr.number}`);
                }
                else {
                    await platform_1.platform.addReviewers(pr.number, reviewers);
                    logger_1.logger.debug({ reviewers }, 'Added reviewers');
                }
            }
        }
        catch (err) {
            logger_1.logger.debug({ reviewers: config.reviewers, err }, 'Failed to add reviewers');
        }
    }
}
exports.addAssigneesReviewers = addAssigneesReviewers;
function getPlatformPrOptions(config) {
    const usePlatformAutomerge = Boolean(config.automerge &&
        (config.automergeType === 'pr' || config.automergeType === 'branch') &&
        config.platformAutomerge);
    return {
        azureAutoApprove: config.azureAutoApprove,
        azureWorkItemId: config.azureWorkItemId,
        bbUseDefaultReviewers: config.bbUseDefaultReviewers,
        gitLabIgnoreApprovals: config.gitLabIgnoreApprovals,
        usePlatformAutomerge,
    };
}
exports.getPlatformPrOptions = getPlatformPrOptions;
// Ensures that PR exists with matching title/body
async function ensurePr(prConfig) {
    var _a, _b, _c, _d, _e, _f;
    let branchStatus;
    async function getBranchStatus() {
        if (branchStatus) {
            return branchStatus;
        }
        branchStatus = await (0, status_checks_1.resolveBranchStatus)(branchName, ignoreTests);
        logger_1.logger.debug(`Branch status is: ${branchStatus}`);
        return branchStatus;
    }
    const config = { ...prConfig };
    logger_1.logger.trace({ config }, 'ensurePr');
    // If there is a group, it will use the config of the first upgrade in the array
    const { branchName, ignoreTests, prTitle, upgrades } = config;
    const dependencyDashboardCheck = (config.dependencyDashboardChecks || {})[config.branchName];
    // Check if existing PR exists
    const existingPr = await platform_1.platform.getBranchPr(branchName);
    if (existingPr) {
        logger_1.logger.debug('Found existing PR');
    }
    config.upgrades = [];
    if ((_a = config.artifactErrors) === null || _a === void 0 ? void 0 : _a.length) {
        logger_1.logger.debug('Forcing PR because of artifact errors');
        config.forcePr = true;
    }
    // Only create a PR if a branch automerge has failed
    if (config.automerge === true &&
        config.automergeType.startsWith('branch') &&
        !config.forcePr) {
        logger_1.logger.debug(`Branch automerge is enabled`);
        if (config.stabilityStatus !== types_1.BranchStatus.yellow &&
            (await getBranchStatus()) === types_1.BranchStatus.yellow) {
            logger_1.logger.debug('Checking how long this branch has been pending');
            const lastCommitTime = await (0, git_1.getBranchLastCommitTime)(branchName);
            const currentTime = new Date();
            const millisecondsPerHour = 1000 * 60 * 60;
            const elapsedHours = Math.round((currentTime.getTime() - lastCommitTime.getTime()) / millisecondsPerHour);
            if (elapsedHours >= config.prNotPendingHours) {
                logger_1.logger.debug('Branch exceeds prNotPending hours - forcing PR creation');
                config.forcePr = true;
            }
        }
        if (config.forcePr || (await getBranchStatus()) === types_1.BranchStatus.red) {
            logger_1.logger.debug(`Branch tests failed, so will create PR`);
        }
        else {
            // Branch should be automerged, so we don't want to create a PR
            return { prBlockedBy: 'BranchAutomerge' };
        }
    }
    if (config.prCreation === 'status-success') {
        logger_1.logger.debug('Checking branch combined status');
        if ((await getBranchStatus()) !== types_1.BranchStatus.green) {
            logger_1.logger.debug(`Branch status isn't green - not creating PR`);
            return { prBlockedBy: 'AwaitingTests' };
        }
        logger_1.logger.debug('Branch status success');
    }
    else if (config.prCreation === 'approval' &&
        !existingPr &&
        dependencyDashboardCheck !== 'approvePr') {
        return { prBlockedBy: 'NeedsApproval' };
    }
    else if (config.prCreation === 'not-pending' &&
        !existingPr &&
        !config.forcePr) {
        logger_1.logger.debug('Checking branch combined status');
        if ((await getBranchStatus()) === types_1.BranchStatus.yellow) {
            logger_1.logger.debug(`Branch status is yellow - checking timeout`);
            const lastCommitTime = await (0, git_1.getBranchLastCommitTime)(branchName);
            const currentTime = new Date();
            const millisecondsPerHour = 1000 * 60 * 60;
            const elapsedHours = Math.round((currentTime.getTime() - lastCommitTime.getTime()) / millisecondsPerHour);
            if (!dependencyDashboardCheck &&
                ((config.stabilityStatus &&
                    config.stabilityStatus !== types_1.BranchStatus.yellow) ||
                    elapsedHours < config.prNotPendingHours)) {
                logger_1.logger.debug(`Branch is ${elapsedHours} hours old - skipping PR creation`);
                return {
                    prBlockedBy: 'AwaitingTests',
                };
            }
            const prNotPendingHours = String(config.prNotPendingHours);
            logger_1.logger.debug(`prNotPendingHours=${prNotPendingHours} threshold hit - creating PR`);
        }
        logger_1.logger.debug('Branch status success');
    }
    const processedUpgrades = [];
    const commitRepos = [];
    function getRepoNameWithSourceDirectory(upgrade) {
        return `${upgrade.repoName}${upgrade.sourceDirectory ? `:${upgrade.sourceDirectory}` : ''}`;
    }
    // Get changelog and then generate template strings
    for (const upgrade of upgrades) {
        const upgradeKey = `${upgrade.depType}-${upgrade.depName}-${upgrade.manager}-${upgrade.currentVersion || upgrade.currentValue}-${upgrade.newVersion}`;
        if (processedUpgrades.includes(upgradeKey)) {
            continue;
        }
        processedUpgrades.push(upgradeKey);
        const logJSON = upgrade.logJSON;
        if (logJSON) {
            if (typeof logJSON.error === 'undefined') {
                if (logJSON.project) {
                    upgrade.repoName = logJSON.project.repository;
                }
                upgrade.hasReleaseNotes = logJSON.hasReleaseNotes;
                upgrade.releases = [];
                if (upgrade.hasReleaseNotes &&
                    upgrade.repoName &&
                    !commitRepos.includes(getRepoNameWithSourceDirectory(upgrade))) {
                    commitRepos.push(getRepoNameWithSourceDirectory(upgrade));
                    if (logJSON.versions) {
                        logJSON.versions.forEach((version) => {
                            const release = { ...version };
                            upgrade.releases.push(release);
                        });
                    }
                }
            }
            else if (logJSON.error === types_2.ChangeLogError.MissingGithubToken) {
                upgrade.prBodyNotes = [
                    ...upgrade.prBodyNotes,
                    [
                        '\n',
                        ':warning: Release Notes retrieval for this PR were skipped because no github.com credentials were available.',
                        'If you are self-hosted, please see [this instruction](https://github.com/renovatebot/renovate/blob/master/docs/usage/examples/self-hosting.md#githubcom-token-for-release-notes).',
                        '\n',
                    ].join('\n'),
                ];
            }
        }
        config.upgrades.push(upgrade);
    }
    config.hasReleaseNotes = config.upgrades.some((upg) => upg.hasReleaseNotes);
    const releaseNotesSources = [];
    for (const upgrade of config.upgrades) {
        const notesSourceUrl = ((_d = (_c = (_b = upgrade.releases) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.releaseNotes) === null || _d === void 0 ? void 0 : _d.notesSourceUrl) || upgrade.sourceUrl;
        if (upgrade.hasReleaseNotes && notesSourceUrl) {
            if (releaseNotesSources.includes(notesSourceUrl)) {
                logger_1.logger.debug({ depName: upgrade.depName }, 'Removing duplicate release notes');
                upgrade.hasReleaseNotes = false;
            }
            else {
                releaseNotesSources.push(notesSourceUrl);
            }
        }
    }
    const prBody = await (0, body_1.getPrBody)(config);
    try {
        if (existingPr) {
            logger_1.logger.debug('Processing existing PR');
            // istanbul ignore if
            if (!existingPr.hasAssignees &&
                !existingPr.hasReviewers &&
                config.automerge &&
                (await getBranchStatus()) === types_1.BranchStatus.red) {
                logger_1.logger.debug(`Setting assignees and reviewers as status checks failed`);
                await addAssigneesReviewers(config, existingPr);
            }
            // Check if existing PR needs updating
            const reviewableIndex = existingPr.body.indexOf('<!-- Reviewable:start -->');
            let existingPrBody = existingPr.body;
            if (reviewableIndex > -1) {
                logger_1.logger.debug('Stripping Reviewable content');
                existingPrBody = existingPrBody.slice(0, reviewableIndex);
            }
            const existingPrTitle = (0, emoji_1.stripEmojis)(existingPr.title);
            const newPrTitle = (0, emoji_1.stripEmojis)(prTitle);
            existingPrBody = existingPrBody.trim();
            if (existingPrTitle === newPrTitle &&
                noWhitespaceOrHeadings((0, emoji_1.stripEmojis)(existingPrBody)) ===
                    noWhitespaceOrHeadings((0, emoji_1.stripEmojis)(prBody))) {
                logger_1.logger.debug(`${existingPr.displayNumber} does not need updating`);
                return { pr: existingPr };
            }
            // PR must need updating
            if (existingPrTitle !== newPrTitle) {
                logger_1.logger.debug({
                    branchName,
                    oldPrTitle: existingPr.title,
                    newPrTitle: prTitle,
                }, 'PR title changed');
            }
            else if (!config.committedFiles && !config.rebaseRequested) {
                logger_1.logger.debug({
                    prTitle,
                }, 'PR body changed');
            }
            // istanbul ignore if
            if (global_1.GlobalConfig.get('dryRun')) {
                logger_1.logger.info(`DRY-RUN: Would update PR #${existingPr.number}`);
            }
            else {
                await platform_1.platform.updatePr({
                    number: existingPr.number,
                    prTitle,
                    prBody,
                    platformOptions: getPlatformPrOptions(config),
                });
                logger_1.logger.info({ pr: existingPr.number, prTitle }, `PR updated`);
            }
            return {
                pr: existingPr,
            };
        }
        logger_1.logger.debug({ branch: branchName, prTitle }, `Creating PR`);
        // istanbul ignore if
        if (config.updateType === 'rollback') {
            logger_1.logger.info('Creating Rollback PR');
        }
        let pr;
        try {
            // istanbul ignore if
            if (global_1.GlobalConfig.get('dryRun')) {
                logger_1.logger.info('DRY-RUN: Would create PR: ' + prTitle);
                pr = { number: 0, displayNumber: 'Dry run PR' };
            }
            else {
                if (!dependencyDashboardCheck &&
                    (0, limits_1.isLimitReached)(limits_1.Limit.PullRequests) &&
                    !config.isVulnerabilityAlert) {
                    logger_1.logger.debug('Skipping PR - limit reached');
                    return { prBlockedBy: 'RateLimited' };
                }
                pr = await platform_1.platform.createPr({
                    sourceBranch: branchName,
                    targetBranch: config.baseBranch,
                    prTitle,
                    prBody,
                    labels: [...new Set([...config.labels, ...config.addLabels])].map((label) => template.compile(label, config)),
                    platformOptions: getPlatformPrOptions(config),
                    draftPR: config.draftPR,
                });
                (0, limits_1.incLimitedValue)(limits_1.Limit.PullRequests);
                logger_1.logger.info({ pr: pr.number, prTitle }, 'PR created');
            }
        }
        catch (err) /* istanbul ignore next */ {
            logger_1.logger.debug({ err }, 'Pull request creation error');
            if (((_e = err.body) === null || _e === void 0 ? void 0 : _e.message) === 'Validation failed' &&
                ((_f = err.body.errors) === null || _f === void 0 ? void 0 : _f.length) &&
                err.body.errors.some((error) => { var _a; return (_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith('A pull request already exists'); })) {
                logger_1.logger.warn('A pull requests already exists');
                return { prBlockedBy: 'Error' };
            }
            if (err.statusCode === 502) {
                logger_1.logger.warn({ branch: branchName }, 'Deleting branch due to server error');
                if (global_1.GlobalConfig.get('dryRun')) {
                    logger_1.logger.info('DRY-RUN: Would delete branch: ' + config.branchName);
                }
                else {
                    await (0, git_1.deleteBranch)(branchName);
                }
            }
            return { prBlockedBy: 'Error' };
        }
        if (config.branchAutomergeFailureMessage &&
            !config.suppressNotifications.includes('branchAutomergeFailure')) {
            const topic = 'Branch automerge failure';
            let content = 'This PR was configured for branch automerge, however this is not possible so it has been raised as a PR instead.';
            if (config.branchAutomergeFailureMessage === 'branch status error') {
                content += '\n___\n * Branch has one or more failed status checks';
            }
            content = platform_1.platform.massageMarkdown(content);
            logger_1.logger.debug('Adding branch automerge failure message to PR');
            // istanbul ignore if
            if (global_1.GlobalConfig.get('dryRun')) {
                logger_1.logger.info(`DRY-RUN: Would add comment to PR #${pr.number}`);
            }
            else {
                await platform_1.platform.ensureComment({
                    number: pr.number,
                    topic,
                    content,
                });
            }
        }
        // Skip assign and review if automerging PR
        if (config.automerge &&
            !config.assignAutomerge &&
            (await getBranchStatus()) !== types_1.BranchStatus.red) {
            logger_1.logger.debug(`Skipping assignees and reviewers as automerge=${config.automerge}`);
        }
        else {
            await addAssigneesReviewers(config, pr);
        }
        logger_1.logger.debug(`Created ${pr.displayNumber}`);
        return { pr };
    }
    catch (err) {
        // istanbul ignore if
        if (err instanceof external_host_error_1.ExternalHostError ||
            err.message === error_messages_1.REPOSITORY_CHANGED ||
            err.message === error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED ||
            err.message === error_messages_1.PLATFORM_INTEGRATION_UNAUTHORIZED) {
            logger_1.logger.debug('Passing error up');
            throw err;
        }
        logger_1.logger.error({ err }, 'Failed to ensure PR: ' + prTitle);
    }
    if (existingPr) {
        return { pr: existingPr };
    }
    // istanbul ignore next
    return { prBlockedBy: 'Error' };
}
exports.ensurePr = ensurePr;
//# sourceMappingURL=index.js.map