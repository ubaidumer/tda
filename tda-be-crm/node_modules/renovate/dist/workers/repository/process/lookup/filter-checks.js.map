{"version":3,"file":"filter-checks.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/process/lookup/filter-checks.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { mergeChildConfig } from '../../../../config';\nimport type { Release } from '../../../../datasource';\nimport { logger } from '../../../../logger';\nimport { getElapsedDays } from '../../../../util/date';\nimport {\n  getMergeConfidenceLevel,\n  isActiveConfidenceLevel,\n  satisfiesConfidenceLevel,\n} from '../../../../util/merge-confidence';\nimport { applyPackageRules } from '../../../../util/package-rules';\nimport type { VersioningApi } from '../../../../versioning';\nimport type { LookupUpdateConfig, UpdateResult } from './types';\nimport { getUpdateType } from './update-type';\n\nexport interface InternalChecksResult {\n  release: Release;\n  pendingChecks: boolean;\n  pendingReleases?: Release[];\n}\n\nexport async function filterInternalChecks(\n  config: Partial<LookupUpdateConfig & UpdateResult>,\n  versioning: VersioningApi,\n  bucket: string,\n  sortedReleases: Release[]\n): Promise<InternalChecksResult> {\n  const { currentVersion, datasource, depName, internalChecksFilter } = config;\n  let release: Release;\n  let pendingChecks = false;\n  let pendingReleases: Release[] = [];\n  if (internalChecksFilter === 'none') {\n    // Don't care if stabilityDays or minimumConfidence are unmet\n    release = sortedReleases.pop();\n  } else {\n    // iterate through releases from highest to lowest, looking for the first which will pass checks if present\n    for (const candidateRelease of sortedReleases.reverse()) {\n      // merge the release data into dependency config\n      let releaseConfig = mergeChildConfig(config, candidateRelease);\n      // calculate updateType and then apply it\n      releaseConfig.updateType = getUpdateType(\n        releaseConfig,\n        versioning,\n        currentVersion,\n        candidateRelease.version\n      );\n      releaseConfig = mergeChildConfig(\n        releaseConfig,\n        releaseConfig[releaseConfig.updateType]\n      );\n      // Apply packageRules in case any apply to updateType\n      releaseConfig = applyPackageRules(releaseConfig);\n      // Now check for a stabilityDays config\n      const {\n        minimumConfidence,\n        stabilityDays,\n        releaseTimestamp,\n        version: newVersion,\n        updateType,\n      } = releaseConfig;\n      if (is.integer(stabilityDays) && releaseTimestamp) {\n        if (getElapsedDays(releaseTimestamp) < stabilityDays) {\n          // Skip it if it doesn't pass checks\n          logger.debug(\n            { depName, check: 'stabilityDays' },\n            `Release ${candidateRelease.version} is pending status checks`\n          );\n          pendingReleases.unshift(candidateRelease);\n          continue;\n        }\n      }\n      if (isActiveConfidenceLevel(minimumConfidence)) {\n        const confidenceLevel = await getMergeConfidenceLevel(\n          datasource,\n          depName,\n          currentVersion,\n          newVersion,\n          updateType\n        );\n        if (!satisfiesConfidenceLevel(confidenceLevel, minimumConfidence)) {\n          logger.debug(\n            { depName, check: 'minimumConfidence' },\n            `Release ${candidateRelease.version} is pending status checks`\n          );\n          pendingReleases.unshift(candidateRelease);\n          continue;\n        }\n      }\n      // If we get to here, then the release is OK and we can stop iterating\n      release = candidateRelease;\n      break;\n    }\n    if (!release) {\n      if (pendingReleases.length) {\n        // If all releases were pending then just take the highest\n        logger.debug(\n          { depName, bucket },\n          'All releases are pending - using latest'\n        );\n        release = pendingReleases.pop();\n        // None are pending anymore because we took the latest, so empty the array\n        pendingReleases = [];\n        if (internalChecksFilter === 'strict') {\n          pendingChecks = true;\n        }\n      }\n    }\n  }\n  return { release, pendingChecks, pendingReleases };\n}\n"]}