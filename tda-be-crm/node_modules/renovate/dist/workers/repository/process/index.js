"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRepo = exports.extractDependencies = void 0;
const config_1 = require("../../../config");
const logger_1 = require("../../../logger");
const git_1 = require("../../../util/git");
const split_1 = require("../../../util/split");
const dependency_dashboard_1 = require("../dependency-dashboard");
const extract_update_1 = require("./extract-update");
function getBaseBranchConfig(baseBranch, config) {
    logger_1.logger.debug(`baseBranch: ${baseBranch}`);
    const baseBranchConfig = (0, config_1.mergeChildConfig)(config, { baseBranch });
    if (config.baseBranches.length > 1) {
        baseBranchConfig.branchPrefix += `${baseBranch}-`;
        baseBranchConfig.hasBaseBranches = true;
    }
    return baseBranchConfig;
}
async function extractDependencies(config) {
    var _a;
    await (0, dependency_dashboard_1.readDashboardBody)(config);
    let res = {
        branches: [],
        branchList: [],
        packageFiles: null,
    };
    if ((_a = config.baseBranches) === null || _a === void 0 ? void 0 : _a.length) {
        logger_1.logger.debug({ baseBranches: config.baseBranches }, 'baseBranches');
        const extracted = {};
        for (const baseBranch of config.baseBranches) {
            if ((0, git_1.branchExists)(baseBranch)) {
                const baseBranchConfig = getBaseBranchConfig(baseBranch, config);
                extracted[baseBranch] = await (0, extract_update_1.extract)(baseBranchConfig);
            }
            else {
                logger_1.logger.warn({ baseBranch }, 'Base branch does not exist - skipping');
            }
        }
        (0, split_1.addSplit)('extract');
        for (const baseBranch of config.baseBranches) {
            if ((0, git_1.branchExists)(baseBranch)) {
                const baseBranchConfig = getBaseBranchConfig(baseBranch, config);
                const packageFiles = extracted[baseBranch];
                const baseBranchRes = await (0, extract_update_1.lookup)(baseBranchConfig, packageFiles);
                res.branches = res.branches.concat(baseBranchRes === null || baseBranchRes === void 0 ? void 0 : baseBranchRes.branches);
                res.branchList = res.branchList.concat(baseBranchRes === null || baseBranchRes === void 0 ? void 0 : baseBranchRes.branchList);
                res.packageFiles = res.packageFiles || (baseBranchRes === null || baseBranchRes === void 0 ? void 0 : baseBranchRes.packageFiles); // Use the first branch
            }
        }
    }
    else {
        logger_1.logger.debug('No baseBranches');
        const packageFiles = await (0, extract_update_1.extract)(config);
        (0, split_1.addSplit)('extract');
        res = await (0, extract_update_1.lookup)(config, packageFiles);
    }
    (0, split_1.addSplit)('lookup');
    return res;
}
exports.extractDependencies = extractDependencies;
function updateRepo(config, branches) {
    logger_1.logger.debug('processRepo()');
    return (0, extract_update_1.update)(config, branches);
}
exports.updateRepo = updateRepo;
//# sourceMappingURL=index.js.map