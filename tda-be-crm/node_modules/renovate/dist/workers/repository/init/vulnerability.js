"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectVulnerabilityAlerts = void 0;
const tslib_1 = require("tslib");
const error_messages_1 = require("../../../constants/error-messages");
const datasourceMaven = (0, tslib_1.__importStar)(require("../../../datasource/maven"));
const npm_1 = require("../../../datasource/npm");
const datasourceNuget = (0, tslib_1.__importStar)(require("../../../datasource/nuget"));
const pypi_1 = require("../../../datasource/pypi");
const rubygems_1 = require("../../../datasource/rubygems");
const logger_1 = require("../../../logger");
const platform_1 = require("../../../platform");
const markdown_1 = require("../../../util/markdown");
const regex_1 = require("../../../util/regex");
const allVersioning = (0, tslib_1.__importStar)(require("../../../versioning"));
const mavenVersioning = (0, tslib_1.__importStar)(require("../../../versioning/maven"));
const npmVersioning = (0, tslib_1.__importStar)(require("../../../versioning/npm"));
const pep440Versioning = (0, tslib_1.__importStar)(require("../../../versioning/pep440"));
const rubyVersioning = (0, tslib_1.__importStar)(require("../../../versioning/ruby"));
const semverVersioning = (0, tslib_1.__importStar)(require("../../../versioning/semver"));
async function detectVulnerabilityAlerts(input) {
    var _a, _b, _c;
    var _d, _e, _f, _g;
    if (!(input === null || input === void 0 ? void 0 : input.vulnerabilityAlerts)) {
        return input;
    }
    if (input.vulnerabilityAlerts.enabled === false) {
        logger_1.logger.debug('Vulnerability alerts are disabled');
        return input;
    }
    const alerts = await platform_1.platform.getVulnerabilityAlerts();
    if (!alerts.length) {
        logger_1.logger.debug('No vulnerability alerts found');
        if (input.vulnerabilityAlertsOnly) {
            throw new Error(error_messages_1.NO_VULNERABILITY_ALERTS);
        }
        return input;
    }
    const config = { ...input };
    const versionings = {
        maven: mavenVersioning.id,
        npm: npmVersioning.id,
        nuget: semverVersioning.id,
        pypi: pep440Versioning.id,
        rubygems: rubyVersioning.id,
    };
    const combinedAlerts = {};
    for (const alert of alerts) {
        if (((_b = (_a = alert.securityVulnerability) === null || _a === void 0 ? void 0 : _a.package) === null || _b === void 0 ? void 0 : _b.name) === 'yargs-parser' &&
            (alert.vulnerableRequirements === '= 5.0.0-security.0' ||
                alert.vulnerableRequirements === '= 5.0.1')) {
            continue;
        }
        try {
            if (alert.dismissReason) {
                continue;
            }
            if (!alert.securityVulnerability.firstPatchedVersion) {
                logger_1.logger.debug({ alert }, 'Vulnerability alert has no firstPatchedVersion - skipping');
                continue;
            }
            const datasourceMapping = {
                MAVEN: datasourceMaven.id,
                NPM: npm_1.id,
                NUGET: datasourceNuget.id,
                PIP: pypi_1.PypiDatasource.id,
                RUBYGEMS: rubygems_1.RubyGemsDatasource.id,
            };
            const datasource = datasourceMapping[alert.securityVulnerability.package.ecosystem];
            const depName = alert.securityVulnerability.package.name;
            const fileName = alert.vulnerableManifestPath;
            const fileType = alert.vulnerableManifestFilename;
            const firstPatchedVersion = alert.securityVulnerability.firstPatchedVersion.identifier;
            const advisory = alert.securityAdvisory;
            let { vulnerableRequirements } = alert;
            // istanbul ignore if
            if (!vulnerableRequirements.length) {
                if (datasource === datasourceMaven.id) {
                    vulnerableRequirements = `(,${firstPatchedVersion})`;
                }
                else {
                    vulnerableRequirements = `< ${firstPatchedVersion}`;
                }
            }
            if (datasource === pypi_1.PypiDatasource.id) {
                vulnerableRequirements = vulnerableRequirements.replace((0, regex_1.regEx)(/^= /), '== '); // TODO #12071
            }
            combinedAlerts[fileName] || (combinedAlerts[fileName] = {});
            (_d = combinedAlerts[fileName])[datasource] || (_d[datasource] = {});
            (_e = combinedAlerts[fileName][datasource])[depName] || (_e[depName] = {});
            (_f = combinedAlerts[fileName][datasource][depName])[vulnerableRequirements] || (_f[vulnerableRequirements] = {
                advisories: [],
            });
            const alertDetails = combinedAlerts[fileName][datasource][depName][vulnerableRequirements];
            alertDetails.advisories.push(advisory);
            const version = allVersioning.get(versionings[datasource]);
            if (version.isVersion(firstPatchedVersion)) {
                if (!alertDetails.firstPatchedVersion ||
                    version.isGreaterThan(firstPatchedVersion, alertDetails.firstPatchedVersion)) {
                    alertDetails.firstPatchedVersion = firstPatchedVersion;
                }
            }
            else {
                logger_1.logger.debug('Invalid firstPatchedVersion: ' + firstPatchedVersion);
            }
            alertDetails.fileType = fileType;
        }
        catch (err) {
            logger_1.logger.warn({ err }, 'Error parsing vulnerability alert');
        }
    }
    const alertPackageRules = [];
    config.remediations = {};
    for (const [fileName, files] of Object.entries(combinedAlerts)) {
        for (const [datasource, dependencies] of Object.entries(files)) {
            for (const [depName, currentValues] of Object.entries(dependencies)) {
                for (const [matchCurrentVersion, val] of Object.entries(currentValues)) {
                    let prBodyNotes = [];
                    try {
                        prBodyNotes = ['### GitHub Vulnerability Alerts'].concat(val.advisories.map((advisory) => {
                            let content = '#### ';
                            let heading;
                            if (advisory.identifiers.some((id) => id.type === 'CVE')) {
                                heading = advisory.identifiers
                                    .filter((id) => id.type === 'CVE')
                                    .map((id) => id.value)
                                    .join(' / ');
                            }
                            else {
                                heading = advisory.identifiers
                                    .map((id) => id.value)
                                    .join(' / ');
                            }
                            if (advisory.references.length) {
                                heading = `[${heading}](${advisory.references[0].url})`;
                            }
                            content += heading;
                            content += '\n\n';
                            content += (0, markdown_1.sanitizeMarkdown)(advisory.description);
                            return content;
                        }));
                    }
                    catch (err) /* istanbul ignore next */ {
                        logger_1.logger.warn({ err }, 'Error generating vulnerability PR notes');
                    }
                    const allowedVersions = datasource === pypi_1.PypiDatasource.id
                        ? `==${val.firstPatchedVersion}`
                        : val.firstPatchedVersion;
                    let matchRule = {
                        matchDatasources: [datasource],
                        matchPackageNames: [depName],
                        matchCurrentVersion,
                        matchFiles: [fileName],
                    };
                    const supportedRemediationFileTypes = ['package-lock.json'];
                    if (config.transitiveRemediation &&
                        supportedRemediationFileTypes.includes(val.fileType)) {
                        (_g = config.remediations)[fileName] || (_g[fileName] = []);
                        const currentVersion = matchCurrentVersion.replace('=', '').trim();
                        const newVersion = allowedVersions;
                        const remediation = {
                            datasource,
                            depName,
                            currentVersion,
                            newVersion,
                            prBodyNotes,
                        };
                        config.remediations[fileName].push(remediation);
                        // Disable the package rule as all vulnerabilities will be remediated via the lock file
                        matchRule.enabled = false;
                    }
                    else {
                        // Remediate only direct dependencies
                        matchRule = {
                            ...matchRule,
                            allowedVersions,
                            prBodyNotes,
                            isVulnerabilityAlert: true,
                            force: {
                                ...config.vulnerabilityAlerts,
                            },
                        };
                        // istanbul ignore if
                        if (config.transitiveRemediation &&
                            ((_c = matchRule.matchFiles) === null || _c === void 0 ? void 0 : _c[0]) === 'package.json') {
                            matchRule.force.rangeStrategy = 'replace';
                        }
                    }
                    alertPackageRules.push(matchRule);
                }
            }
        }
    }
    logger_1.logger.debug({ alertPackageRules }, 'alert package rules');
    config.packageRules = (config.packageRules || []).concat(alertPackageRules);
    return config;
}
exports.detectVulnerabilityAlerts = detectVulnerabilityAlerts;
//# sourceMappingURL=vulnerability.js.map