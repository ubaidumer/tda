"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = exports.mergeExtractionTemplate = exports.defaultConfig = void 0;
const tslib_1 = require("tslib");
const url_1 = require("url");
const logger_1 = require("../../logger");
const regex_1 = require("../../util/regex");
const template = (0, tslib_1.__importStar)(require("../../util/template"));
exports.defaultConfig = {
    pinDigests: false,
};
const validMatchFields = [
    'depName',
    'lookupName',
    'currentValue',
    'currentDigest',
    'datasource',
    'versioning',
    'extractVersion',
    'registryUrl',
    'depType',
];
function regexMatchAll(regex, content) {
    const matches = [];
    let matchResult;
    do {
        matchResult = regex.exec(content);
        if (matchResult) {
            matches.push(matchResult);
        }
    } while (matchResult);
    return matches;
}
function createDependency(extractionTemplate, config, dep) {
    const dependency = dep || {};
    const { groups, replaceString } = extractionTemplate;
    function updateDependency(field, value) {
        switch (field) {
            case 'registryUrl':
                // check if URL is valid and pack inside an array
                try {
                    const url = new url_1.URL(value).toString();
                    dependency.registryUrls = [url];
                }
                catch (err) {
                    logger_1.logger.warn({ value }, 'Invalid regex manager registryUrl');
                }
                break;
            default:
                dependency[field] = value;
                break;
        }
    }
    for (const field of validMatchFields) {
        const fieldTemplate = `${field}Template`;
        if (config[fieldTemplate]) {
            try {
                const compiled = template.compile(config[fieldTemplate], groups, false);
                updateDependency(field, compiled);
            }
            catch (err) {
                logger_1.logger.warn({ template: config[fieldTemplate] }, 'Error compiling template for custom manager');
                return null;
            }
        }
        else if (groups[field]) {
            updateDependency(field, groups[field]);
        }
    }
    dependency.replaceString = replaceString;
    return dependency;
}
function handleAny(content, packageFile, config) {
    return config.matchStrings
        .map((matchString) => (0, regex_1.regEx)(matchString, 'g'))
        .flatMap((regex) => regexMatchAll(regex, content)) // match all regex to content, get all matches, reduce to single array
        .map((matchResult) => createDependency({ groups: matchResult.groups, replaceString: matchResult[0] }, config));
}
function mergeGroups(mergedGroup, secondGroup) {
    return { ...mergedGroup, ...secondGroup };
}
function mergeExtractionTemplate(base, addition) {
    var _a;
    return {
        groups: mergeGroups(base.groups, addition.groups),
        replaceString: (_a = addition.replaceString) !== null && _a !== void 0 ? _a : base.replaceString,
    };
}
exports.mergeExtractionTemplate = mergeExtractionTemplate;
function handleCombination(content, packageFile, config) {
    const matches = config.matchStrings
        .map((matchString) => (0, regex_1.regEx)(matchString, 'g'))
        .flatMap((regex) => regexMatchAll(regex, content)); // match all regex to content, get all matches, reduce to single array
    if (!matches.length) {
        return [];
    }
    const extraction = matches
        .map((match) => {
        var _a;
        return ({
            groups: match.groups,
            replaceString: ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.currentValue) ? match[0] : undefined,
        });
    })
        .reduce((base, addition) => mergeExtractionTemplate(base, addition));
    return [createDependency(extraction, config)];
}
function handleRecursive(content, packageFile, config, index = 0, combinedGroups = {}) {
    const regexes = config.matchStrings.map((matchString) => (0, regex_1.regEx)(matchString, 'g'));
    // abort if we have no matchString anymore
    if (!regexes[index]) {
        return [];
    }
    return regexMatchAll(regexes[index], content).flatMap((match) => {
        var _a, _b;
        // if we have a depName and a currentValue which have the minimal viable definition
        if (((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.depName) && ((_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.currentValue)) {
            return createDependency({
                groups: mergeGroups(combinedGroups, match.groups),
                replaceString: match[0],
            }, config);
        }
        return handleRecursive(match[0], packageFile, config, index + 1, mergeGroups(combinedGroups, match.groups || {}));
    });
}
function extractPackageFile(content, packageFile, config) {
    let deps;
    switch (config.matchStringsStrategy) {
        default:
        case 'any':
            deps = handleAny(content, packageFile, config);
            break;
        case 'combination':
            deps = handleCombination(content, packageFile, config);
            break;
        case 'recursive':
            deps = handleRecursive(content, packageFile, config);
            break;
    }
    // filter all null values
    deps = deps.filter(Boolean);
    if (deps.length) {
        const res = { deps, matchStrings: config.matchStrings };
        if (config.matchStringsStrategy) {
            res.matchStringsStrategy = config.matchStringsStrategy;
        }
        // copy over templates for autoreplace
        for (const field of validMatchFields.map((f) => `${f}Template`)) {
            if (config[field]) {
                res[field] = config[field];
            }
        }
        if (config.autoReplaceStringTemplate) {
            res.autoReplaceStringTemplate = config.autoReplaceStringTemplate;
        }
        return res;
    }
    return null;
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=index.js.map