"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArtifacts = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const upath_1 = require("upath");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const exec_1 = require("../../util/exec");
const fs_1 = require("../../util/fs");
const git_1 = require("../../util/git");
const auth_1 = require("../../util/git/auth");
const host_rules_1 = require("../../util/host-rules");
const regex_1 = require("../../util/regex");
const url_1 = require("../../util/url");
const semver_1 = require("../../versioning/semver");
function getGitEnvironmentVariables() {
    let environmentVariables = {};
    // hard-coded logic to use authentication for github.com based on the credentials for api.github.com
    const credentials = (0, host_rules_1.find)({
        hostType: "github" /* Github */,
        url: 'https://api.github.com/',
    });
    if (credentials === null || credentials === void 0 ? void 0 : credentials.token) {
        environmentVariables = (0, auth_1.getGitAuthenticatedEnvironmentVariables)('https://github.com/', credentials.token);
    }
    // get extra host rules for other git-based Go Module hosts
    const hostRules = (0, host_rules_1.getAll)() || [];
    const goGitAllowedHostType = [
        "azure" /* Azure */,
        "bitbucket" /* Bitbucket */,
        "bitbucket-server" /* BitbucketServer */,
        "gitea" /* Gitea */,
        "github" /* Github */,
        "gitlab" /* Gitlab */,
        // plus all without a host type (=== undefined)
        undefined,
    ];
    // for each hostRule we add additional authentication variables to the environmentVariables
    for (const hostRule of hostRules) {
        if ((hostRule === null || hostRule === void 0 ? void 0 : hostRule.token) &&
            hostRule.matchHost &&
            goGitAllowedHostType.includes(hostRule.hostType)) {
            const httpUrl = (0, url_1.createURLFromHostOrURL)(hostRule.matchHost).toString();
            if ((0, url_1.validateUrl)(httpUrl)) {
                logger_1.logger.debug(`Adding Git authentication for Go Module retrieval for ${httpUrl} using token auth.`);
                environmentVariables = (0, auth_1.getGitAuthenticatedEnvironmentVariables)(httpUrl, hostRule.token, environmentVariables);
            }
            else {
                logger_1.logger.warn(`Could not parse registryUrl ${hostRule.matchHost} or not using http(s). Ignoring`);
            }
        }
    }
    return environmentVariables;
}
function getUpdateImportPathCmds(updatedDeps, { constraints, newMajor }) {
    const updateImportCommands = updatedDeps
        .map((dep) => dep.depName)
        .filter((x) => !x.startsWith('gopkg.in'))
        .map((depName) => `mod upgrade --mod-name=${depName} -t=${newMajor}`);
    if (updateImportCommands.length > 0) {
        let installMarwanModArgs = 'install github.com/marwan-at-work/mod/cmd/mod@latest';
        const gomodModCompatibility = constraints === null || constraints === void 0 ? void 0 : constraints.gomodMod;
        if (gomodModCompatibility) {
            if (gomodModCompatibility.startsWith('v') &&
                (0, semver_1.isValid)(gomodModCompatibility.replace((0, regex_1.regEx)(/^v/), ''))) {
                installMarwanModArgs = installMarwanModArgs.replace((0, regex_1.regEx)(/@latest$/), `@${gomodModCompatibility}`);
            }
            else {
                logger_1.logger.debug({ gomodModCompatibility }, 'marwan-at-work/mod compatibility range is not valid - skipping');
            }
        }
        else {
            logger_1.logger.debug('No marwan-at-work/mod compatibility range found - installing marwan-at-work/mod latest');
        }
        updateImportCommands.unshift(`go ${installMarwanModArgs}`);
    }
    return updateImportCommands;
}
function useModcacherw(goVersion) {
    var _a;
    if (!is_1.default.string(goVersion)) {
        return true;
    }
    const [, majorPart, minorPart] = (_a = (0, regex_1.regEx)(/(\d+)\.(\d+)/).exec(goVersion)) !== null && _a !== void 0 ? _a : [];
    const [major, minor] = [majorPart, minorPart].map((x) => parseInt(x, 10));
    return (!Number.isNaN(major) &&
        !Number.isNaN(minor) &&
        (major > 1 || (major === 1 && minor >= 14)));
}
async function updateArtifacts({ packageFileName: goModFileName, updatedDeps, newPackageFileContent: newGoModContent, config, }) {
    var _a, _b, _c, _d, _e;
    logger_1.logger.debug(`gomod.updateArtifacts(${goModFileName})`);
    const sumFileName = goModFileName.replace((0, regex_1.regEx)(/\.mod$/), '.sum');
    const existingGoSumContent = await (0, fs_1.readLocalFile)(sumFileName);
    if (!existingGoSumContent) {
        logger_1.logger.debug('No go.sum found');
        return null;
    }
    const vendorDir = (0, upath_1.join)((0, upath_1.dirname)(goModFileName), 'vendor/');
    const vendorModulesFileName = (0, upath_1.join)(vendorDir, 'modules.txt');
    const useVendor = (await (0, fs_1.readLocalFile)(vendorModulesFileName)) !== null;
    try {
        const massagedGoMod = newGoModContent.replace((0, regex_1.regEx)(/\n(replace\s+[^\s]+\s+=>\s+\.\.\/.*)/g), '\n// renovate-replace $1');
        if (massagedGoMod !== newGoModContent) {
            logger_1.logger.debug('Removed some relative replace statements from go.mod');
        }
        await (0, fs_1.writeLocalFile)(goModFileName, massagedGoMod);
        const cmd = 'go';
        const execOptions = {
            cwdFile: goModFileName,
            extraEnv: {
                GOPATH: await (0, fs_1.ensureCacheDir)('go'),
                GOPROXY: process.env.GOPROXY,
                GOPRIVATE: process.env.GOPRIVATE,
                GONOPROXY: process.env.GONOPROXY,
                GONOSUMDB: process.env.GONOSUMDB,
                GOSUMDB: process.env.GOSUMDB,
                GOFLAGS: useModcacherw((_a = config.constraints) === null || _a === void 0 ? void 0 : _a.go) ? '-modcacherw' : null,
                CGO_ENABLED: global_1.GlobalConfig.get('binarySource') === 'docker' ? '0' : null,
                ...getGitEnvironmentVariables(),
            },
            docker: {
                image: 'go',
                tagConstraint: (_b = config.constraints) === null || _b === void 0 ? void 0 : _b.go,
                tagScheme: 'npm',
            },
        };
        const execCommands = [];
        let args = 'get -d ./...';
        logger_1.logger.debug({ cmd, args }, 'go get command included');
        execCommands.push(`${cmd} ${args}`);
        // Update import paths on major updates above v1
        const isImportPathUpdateRequired = ((_c = config.postUpdateOptions) === null || _c === void 0 ? void 0 : _c.includes('gomodUpdateImportPaths')) &&
            config.updateType === 'major' &&
            config.newMajor > 1;
        if (isImportPathUpdateRequired) {
            const updateImportCmds = getUpdateImportPathCmds(updatedDeps, config);
            if (updateImportCmds.length > 0) {
                logger_1.logger.debug(updateImportCmds, 'update import path commands included');
                // The updates
                execCommands.push(...updateImportCmds);
            }
        }
        const mustSkipGoModTidy = !((_d = config.postUpdateOptions) === null || _d === void 0 ? void 0 : _d.includes('gomodUpdateImportPaths')) &&
            config.updateType === 'major';
        if (mustSkipGoModTidy) {
            logger_1.logger.debug({ cmd, args }, 'go mod tidy command skipped');
        }
        const isGoModTidyRequired = !mustSkipGoModTidy &&
            (((_e = config.postUpdateOptions) === null || _e === void 0 ? void 0 : _e.includes('gomodTidy')) ||
                (config.updateType === 'major' && isImportPathUpdateRequired));
        if (isGoModTidyRequired) {
            args = 'mod tidy';
            logger_1.logger.debug({ cmd, args }, 'go mod tidy command included');
            execCommands.push(`${cmd} ${args}`);
        }
        if (useVendor) {
            args = 'mod vendor';
            logger_1.logger.debug({ cmd, args }, 'go mod vendor command included');
            execCommands.push(`${cmd} ${args}`);
            if (isGoModTidyRequired) {
                args = 'mod tidy';
                logger_1.logger.debug({ cmd, args }, 'go mod tidy command included');
                execCommands.push(`${cmd} ${args}`);
            }
        }
        // We tidy one more time as a solution for #6795
        if (isGoModTidyRequired) {
            args = 'mod tidy';
            logger_1.logger.debug({ cmd, args }, 'additional go mod tidy command included');
            execCommands.push(`${cmd} ${args}`);
        }
        await (0, exec_1.exec)(execCommands, execOptions);
        const status = await (0, git_1.getRepoStatus)();
        if (!status.modified.includes(sumFileName)) {
            return null;
        }
        logger_1.logger.debug('Returning updated go.sum');
        const res = [
            {
                file: {
                    name: sumFileName,
                    contents: await (0, fs_1.readLocalFile)(sumFileName),
                },
            },
        ];
        // Include all the .go file import changes
        if (isImportPathUpdateRequired) {
            logger_1.logger.debug('Returning updated go source files for import path changes');
            for (const f of status.modified) {
                if (f.endsWith('.go')) {
                    res.push({
                        file: {
                            name: f,
                            contents: await (0, fs_1.readLocalFile)(f),
                        },
                    });
                }
            }
        }
        if (useVendor) {
            for (const f of status.modified.concat(status.not_added)) {
                if (f.startsWith(vendorDir)) {
                    res.push({
                        file: {
                            name: f,
                            contents: await (0, fs_1.readLocalFile)(f),
                        },
                    });
                }
            }
            for (const f of status.deleted || []) {
                res.push({
                    file: {
                        name: '|delete|',
                        contents: f,
                    },
                });
            }
        }
        const finalGoModContent = (await (0, fs_1.readLocalFile)(goModFileName, 'utf8')).replace((0, regex_1.regEx)(/\/\/ renovate-replace /g), '');
        if (finalGoModContent !== newGoModContent) {
            logger_1.logger.debug('Found updated go.mod after go.sum update');
            res.push({
                file: {
                    name: goModFileName,
                    contents: finalGoModContent,
                },
            });
        }
        return res;
    }
    catch (err) {
        // istanbul ignore if
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        logger_1.logger.debug({ err }, 'Failed to update go.sum');
        return [
            {
                artifactError: {
                    lockFile: sumFileName,
                    stderr: err.message,
                },
            },
        ];
    }
}
exports.updateArtifacts = updateArtifacts;
//# sourceMappingURL=artifacts.js.map