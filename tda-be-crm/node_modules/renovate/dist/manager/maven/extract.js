"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAllPackageFiles = exports.resolveParents = exports.extractPackage = exports.parsePom = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const upath_1 = require("upath");
const xmldoc_1 = require("xmldoc");
const datasourceMaven = (0, tslib_1.__importStar)(require("../../datasource/maven"));
const common_1 = require("../../datasource/maven/common");
const logger_1 = require("../../logger");
const types_1 = require("../../types");
const fs_1 = require("../../util/fs");
const regex_1 = require("../../util/regex");
function parsePom(raw) {
    let project;
    try {
        project = new xmldoc_1.XmlDocument(raw);
    }
    catch (e) {
        return null;
    }
    const { name, attr, children } = project;
    if (name !== 'project') {
        return null;
    }
    if (attr.xmlns === 'http://maven.apache.org/POM/4.0.0') {
        return project;
    }
    if (is_1.default.nonEmptyArray(children) &&
        children.some((c) => c.name === 'modelVersion' && c.val === '4.0.0')) {
        return project;
    }
    return null;
}
exports.parsePom = parsePom;
function containsPlaceholder(str) {
    return (0, regex_1.regEx)(/\${.*?}/g).test(str);
}
function depFromNode(node) {
    var _a, _b, _c, _d;
    if (!('valueWithPath' in node)) {
        return null;
    }
    let groupId = (_a = node.valueWithPath('groupId')) === null || _a === void 0 ? void 0 : _a.trim();
    const artifactId = (_b = node.valueWithPath('artifactId')) === null || _b === void 0 ? void 0 : _b.trim();
    const currentValue = (_c = node.valueWithPath('version')) === null || _c === void 0 ? void 0 : _c.trim();
    if (!groupId && node.name === 'plugin') {
        groupId = 'org.apache.maven.plugins';
    }
    if (groupId && artifactId && currentValue) {
        const depName = `${groupId}:${artifactId}`;
        const versionNode = node.descendantWithPath('version');
        const fileReplacePosition = versionNode.position;
        const datasource = datasourceMaven.id;
        const registryUrls = [common_1.MAVEN_REPO];
        const result = {
            datasource,
            depName,
            currentValue,
            fileReplacePosition,
            registryUrls,
        };
        const depType = (_d = node.valueWithPath('scope')) === null || _d === void 0 ? void 0 : _d.trim();
        if (depType) {
            result.depType = depType;
        }
        return result;
    }
    return null;
}
function deepExtract(node, result = [], isRoot = true) {
    const dep = depFromNode(node);
    if (dep && !isRoot) {
        result.push(dep);
    }
    if (node.children) {
        for (const child of node.children) {
            deepExtract(child, result, false);
        }
    }
    return result;
}
function applyProps(dep, depPackageFile, props) {
    const replaceAll = (str) => str.replace((0, regex_1.regEx)(/\${.*?}/g), (substr) => {
        const propKey = substr.slice(2, -1).trim();
        const propValue = props[propKey];
        return propValue ? propValue.val : substr;
    });
    const depName = replaceAll(dep.depName);
    const registryUrls = dep.registryUrls.map((url) => replaceAll(url));
    let fileReplacePosition = dep.fileReplacePosition;
    let propSource = null;
    let groupName = null;
    const currentValue = dep.currentValue.replace((0, regex_1.regEx)(/^\${.*?}$/), (substr) => {
        const propKey = substr.slice(2, -1).trim();
        const propValue = props[propKey];
        if (propValue) {
            if (!groupName) {
                groupName = propKey;
            }
            fileReplacePosition = propValue.fileReplacePosition;
            propSource = propValue.packageFile;
            return propValue.val;
        }
        return substr;
    });
    const result = {
        ...dep,
        depName,
        registryUrls,
        fileReplacePosition,
        propSource,
        currentValue,
    };
    if (groupName) {
        result.groupName = groupName;
    }
    if (containsPlaceholder(depName)) {
        result.skipReason = types_1.SkipReason.NamePlaceholder;
    }
    else if (containsPlaceholder(currentValue)) {
        result.skipReason = types_1.SkipReason.VersionPlaceholder;
    }
    if (propSource && depPackageFile !== propSource) {
        result.editFile = propSource;
    }
    return result;
}
function resolveParentFile(packageFile, parentPath) {
    let parentFile = 'pom.xml';
    let parentDir = parentPath;
    const parentBasename = (0, upath_1.basename)(parentPath);
    if (parentBasename === 'pom.xml' || parentBasename.endsWith('.pom.xml')) {
        parentFile = parentBasename;
        parentDir = (0, upath_1.dirname)(parentPath);
    }
    const dir = (0, upath_1.dirname)(packageFile);
    return (0, upath_1.normalize)((0, upath_1.join)(dir, parentDir, parentFile));
}
function extractPackage(rawContent, packageFile = null) {
    var _a, _b, _c;
    if (!rawContent) {
        return null;
    }
    const project = parsePom(rawContent);
    if (!project) {
        return null;
    }
    const result = {
        datasource: datasourceMaven.id,
        packageFile,
        deps: [],
    };
    result.deps = deepExtract(project);
    const propsNode = project.childNamed('properties');
    const props = {};
    if (propsNode === null || propsNode === void 0 ? void 0 : propsNode.children) {
        for (const propNode of propsNode.children) {
            const key = propNode.name;
            const val = (_a = propNode === null || propNode === void 0 ? void 0 : propNode.val) === null || _a === void 0 ? void 0 : _a.trim();
            if (key && val) {
                const fileReplacePosition = propNode.position;
                props[key] = { val, fileReplacePosition, packageFile };
            }
        }
    }
    result.mavenProps = props;
    const repositories = project.childNamed('repositories');
    if (repositories === null || repositories === void 0 ? void 0 : repositories.children) {
        const repoUrls = [];
        for (const repo of repositories.childrenNamed('repository')) {
            const repoUrl = (_b = repo.valueWithPath('url')) === null || _b === void 0 ? void 0 : _b.trim();
            if (repoUrl) {
                repoUrls.push(repoUrl);
            }
        }
        result.deps.forEach((dep) => {
            if (dep.registryUrls) {
                repoUrls.forEach((url) => dep.registryUrls.push(url));
            }
        });
    }
    if (packageFile && project.childNamed('parent')) {
        const parentPath = ((_c = project.valueWithPath('parent.relativePath')) === null || _c === void 0 ? void 0 : _c.trim()) || '../pom.xml';
        result.parent = resolveParentFile(packageFile, parentPath);
    }
    return result;
}
exports.extractPackage = extractPackage;
function resolveParents(packages) {
    const packageFileNames = [];
    const extractedPackages = {};
    const extractedDeps = {};
    const extractedProps = {};
    const registryUrls = {};
    packages.forEach((pkg) => {
        const name = pkg.packageFile;
        packageFileNames.push(name);
        extractedPackages[name] = pkg;
        extractedDeps[name] = [];
    });
    // Construct package-specific prop scopes
    // and merge them in reverse order,
    // which allows inheritance/overriding.
    packageFileNames.forEach((name) => {
        registryUrls[name] = new Set();
        const propsHierarchy = [];
        const visitedPackages = new Set();
        let pkg = extractedPackages[name];
        while (pkg) {
            propsHierarchy.unshift(pkg.mavenProps);
            if (pkg.deps) {
                pkg.deps.forEach((dep) => {
                    if (dep.registryUrls) {
                        dep.registryUrls.forEach((url) => {
                            registryUrls[name].add(url);
                        });
                    }
                });
            }
            if (pkg.parent && !visitedPackages.has(pkg.parent)) {
                visitedPackages.add(pkg.parent);
                pkg = extractedPackages[pkg.parent];
            }
            else {
                pkg = null;
            }
        }
        propsHierarchy.unshift({});
        extractedProps[name] = Object.assign.apply(null, propsHierarchy);
    });
    // Resolve registryUrls
    packageFileNames.forEach((name) => {
        const pkg = extractedPackages[name];
        pkg.deps.forEach((rawDep) => {
            const urlsSet = new Set([...rawDep.registryUrls, ...registryUrls[name]]);
            rawDep.registryUrls = [...urlsSet];
        });
    });
    // Resolve placeholders
    packageFileNames.forEach((name) => {
        const pkg = extractedPackages[name];
        pkg.deps.forEach((rawDep) => {
            const dep = applyProps(rawDep, name, extractedProps[name]);
            const sourceName = dep.propSource || name;
            extractedDeps[sourceName].push(dep);
        });
    });
    return packageFileNames.map((name) => ({
        ...extractedPackages[name],
        deps: extractedDeps[name],
    }));
}
exports.resolveParents = resolveParents;
function cleanResult(packageFiles) {
    packageFiles.forEach((packageFile) => {
        delete packageFile.mavenProps;
        packageFile.deps.forEach((dep) => {
            delete dep.propSource;
        });
    });
    return packageFiles;
}
async function extractAllPackageFiles(_config, packageFiles) {
    const packages = [];
    for (const packageFile of packageFiles) {
        const content = await (0, fs_1.readLocalFile)(packageFile, 'utf8');
        if (content) {
            const pkg = extractPackage(content, packageFile);
            if (pkg) {
                packages.push(pkg);
            }
            else {
                logger_1.logger.debug({ packageFile }, 'can not read dependencies');
            }
        }
        else {
            logger_1.logger.debug({ packageFile }, 'packageFile has no content');
        }
    }
    return cleanResult(resolveParents(packages));
}
exports.extractAllPackageFiles = extractAllPackageFiles;
//# sourceMappingURL=extract.js.map