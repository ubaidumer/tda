"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = exports.getDep = exports.splitImageParts = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const datasourceDocker = (0, tslib_1.__importStar)(require("../../datasource/docker"));
const logger_1 = require("../../logger");
const types_1 = require("../../types");
const regex_1 = require("../../util/regex");
const ubuntuVersioning = (0, tslib_1.__importStar)(require("../../versioning/ubuntu"));
const variableMarker = '$';
const variableOpen = '${';
const variableClose = '}';
const variableDefaultValueSplit = ':-';
function splitImageParts(currentFrom) {
    // Check if we have a variable in format of "${VARIABLE:-<image>:<defaultVal>@<digest>}"
    // If so, remove everything except the image, defaultVal and digest.
    let isVariable = false;
    let cleanedCurrentFrom = currentFrom;
    if (currentFrom.startsWith(variableOpen) &&
        currentFrom.endsWith(variableClose)) {
        isVariable = true;
        // If the variable contains exactly one $ and has the default value, we consider it as a valid dependency;
        // otherwise skip it.
        if (currentFrom.split('$').length !== 2 ||
            currentFrom.indexOf(variableDefaultValueSplit) === -1) {
            return {
                skipReason: types_1.SkipReason.ContainsVariable,
            };
        }
        cleanedCurrentFrom = currentFrom.substr(variableOpen.length, currentFrom.length - (variableClose.length + 2));
        cleanedCurrentFrom = cleanedCurrentFrom.substr(cleanedCurrentFrom.indexOf(variableDefaultValueSplit) +
            variableDefaultValueSplit.length);
    }
    const [currentDepTag, currentDigest] = cleanedCurrentFrom.split('@');
    const depTagSplit = currentDepTag.split(':');
    let depName;
    let currentValue;
    if (depTagSplit.length === 1 ||
        depTagSplit[depTagSplit.length - 1].includes('/')) {
        depName = currentDepTag;
    }
    else {
        currentValue = depTagSplit.pop();
        depName = depTagSplit.join(':');
    }
    if (currentValue && currentValue.indexOf(variableMarker) !== -1) {
        // If tag contains a variable, e.g. "5.0${VERSION_SUFFIX}", we do not support this.
        return {
            skipReason: types_1.SkipReason.ContainsVariable,
        };
    }
    if (isVariable) {
        // If we have the variable and it contains the default value, we need to return
        // it as a valid dependency.
        const dep = {
            depName,
            currentValue,
            currentDigest,
            replaceString: cleanedCurrentFrom,
        };
        if (!dep.currentValue) {
            delete dep.currentValue;
        }
        if (!dep.currentDigest) {
            delete dep.currentDigest;
        }
        return dep;
    }
    const dep = {
        depName,
        currentValue,
        currentDigest,
    };
    return dep;
}
exports.splitImageParts = splitImageParts;
const quayRegex = (0, regex_1.regEx)(/^quay\.io(?::[1-9][0-9]{0,4})?/i);
function getDep(currentFrom, specifyReplaceString = true) {
    if (!is_1.default.string(currentFrom)) {
        return {
            skipReason: types_1.SkipReason.InvalidValue,
        };
    }
    const dep = splitImageParts(currentFrom);
    if (specifyReplaceString) {
        if (!dep.replaceString) {
            dep.replaceString = currentFrom;
        }
        dep.autoReplaceStringTemplate =
            '{{depName}}{{#if newValue}}:{{newValue}}{{/if}}{{#if newDigest}}@{{newDigest}}{{/if}}';
    }
    dep.datasource = datasourceDocker.id;
    // Pretty up special prefixes
    if (dep.depName) {
        const specialPrefixes = ['amd64', 'arm64', 'library'];
        for (const prefix of specialPrefixes) {
            if (dep.depName.startsWith(`${prefix}/`)) {
                dep.lookupName = dep.depName;
                dep.depName = dep.depName.replace(`${prefix}/`, '');
                if (specifyReplaceString) {
                    dep.autoReplaceStringTemplate =
                        '{{lookupName}}{{#if newValue}}:{{newValue}}{{/if}}{{#if newDigest}}@{{newDigest}}{{/if}}';
                }
            }
        }
    }
    if (dep.depName === 'ubuntu') {
        dep.versioning = ubuntuVersioning.id;
    }
    // Don't display quay.io ports
    if (quayRegex.test(dep.depName)) {
        const depName = dep.depName.replace(quayRegex, 'quay.io');
        if (depName !== dep.depName) {
            dep.lookupName = dep.depName;
            dep.depName = depName;
            dep.autoReplaceStringTemplate =
                '{{lookupName}}{{#if newValue}}:{{newValue}}{{/if}}{{#if newDigest}}@{{newDigest}}{{/if}}';
        }
    }
    return dep;
}
exports.getDep = getDep;
function extractPackageFile(content) {
    const deps = [];
    const stageNames = [];
    const fromMatches = content.matchAll(/^[ \t]*FROM(?:\\\r?\n| |\t|#.*?\r?\n|[ \t]--[a-z]+=\S+?)*[ \t](?<image>\S+)(?:(?:\\\r?\n| |\t|#.*\r?\n)+as[ \t]+(?<name>\S+))?/gim // TODO #12070 complex for re2 has too many not supported groups
    );
    for (const fromMatch of fromMatches) {
        if (fromMatch.groups.name) {
            logger_1.logger.debug('Found a multistage build stage name');
            stageNames.push(fromMatch.groups.name);
        }
        if (fromMatch.groups.image === 'scratch') {
            logger_1.logger.debug('Skipping scratch');
        }
        else if (stageNames.includes(fromMatch.groups.image)) {
            logger_1.logger.debug({ image: fromMatch.groups.image }, 'Skipping alias FROM');
        }
        else {
            const dep = getDep(fromMatch.groups.image);
            logger_1.logger.trace({
                depName: dep.depName,
                currentValue: dep.currentValue,
                currentDigest: dep.currentDigest,
            }, 'Dockerfile FROM');
            deps.push(dep);
        }
    }
    const copyFromMatches = content.matchAll(/^[ \t]*COPY(?:\\\r?\n| |\t|#.*\r?\n|[ \t]--[a-z]+=\w+?)*[ \t]--from=(?<image>\S+)/gim // TODO #12070 complex for re2 has too many not supported groups
    );
    for (const copyFromMatch of copyFromMatches) {
        if (stageNames.includes(copyFromMatch.groups.image)) {
            logger_1.logger.debug({ image: copyFromMatch.groups.image }, 'Skipping alias COPY --from');
        }
        else if (Number.isNaN(Number(copyFromMatch.groups.image))) {
            const dep = getDep(copyFromMatch.groups.image);
            logger_1.logger.debug({
                depName: dep.depName,
                currentValue: dep.currentValue,
                currentDigest: dep.currentDigest,
            }, 'Dockerfile COPY --from');
            deps.push(dep);
        }
        else {
            logger_1.logger.debug({ image: copyFromMatch.groups.image }, 'Skipping index reference COPY --from');
        }
    }
    if (!deps.length) {
        return null;
    }
    for (const d of deps) {
        d.depType = 'stage';
    }
    deps[deps.length - 1].depType = 'final';
    return { deps };
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=extract.js.map