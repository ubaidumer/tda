"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = void 0;
const rubygems_1 = require("../../datasource/rubygems");
const logger_1 = require("../../logger");
const fs_1 = require("../../util/fs");
const regex_1 = require("../../util/regex");
const locked_version_1 = require("./locked-version");
async function extractPackageFile(content, fileName) {
    const res = {
        registryUrls: [],
        deps: [],
    };
    const lines = content.split('\n');
    const delimiters = ['"', "'"];
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber += 1) {
        const line = lines[lineNumber];
        let sourceMatch;
        for (const delimiter of delimiters) {
            sourceMatch =
                sourceMatch ||
                    (0, regex_1.regEx)(`^source ${delimiter}([^${delimiter}]+)${delimiter}\\s*$`).exec(
                    // TODO #12071
                    line);
        }
        if (sourceMatch) {
            res.registryUrls.push(sourceMatch[1]);
        }
        let rubyMatch;
        for (const delimiter of delimiters) {
            rubyMatch =
                rubyMatch ||
                    (0, regex_1.regEx)(`^ruby ${delimiter}([^${delimiter}]+)${delimiter}`).exec(line); // TODO #12071
        }
        if (rubyMatch) {
            res.constraints = { ruby: rubyMatch[1] };
        }
        const gemMatchRegex = (0, regex_1.regEx)(`^\\s*gem\\s+(['"])(?<depName>[^'"]+)(['"])(\\s*,\\s*(?<currentValue>(['"])[^'"]+['"](\\s*,\\s*['"][^'"]+['"])?))?`); // TODO #12071
        const gemMatch = gemMatchRegex.exec(line);
        if (gemMatch) {
            const dep = {
                depName: gemMatch.groups.depName,
                managerData: { lineNumber },
            };
            if (gemMatch.groups.currentValue) {
                const currentValue = gemMatch.groups.currentValue;
                dep.currentValue = (0, regex_1.regEx)(/\s*,\s*/).test(currentValue) // TODO #12071
                    ? currentValue
                    : currentValue.slice(1, -1);
            }
            dep.datasource = rubygems_1.RubyGemsDatasource.id;
            res.deps.push(dep);
        }
        const groupMatch = (0, regex_1.regEx)(/^group\s+(.*?)\s+do/).exec(line); // TODO #12071
        if (groupMatch) {
            const depTypes = groupMatch[1]
                .split(',')
                .map((group) => group.trim())
                .map((group) => group.replace((0, regex_1.regEx)(/^:/), '')); // TODO #12071
            const groupLineNumber = lineNumber;
            let groupContent = '';
            let groupLine = '';
            while (lineNumber < lines.length && groupLine !== 'end') {
                lineNumber += 1;
                groupLine = lines[lineNumber];
                if (groupLine !== 'end') {
                    groupContent += (groupLine || '').replace((0, regex_1.regEx)(/^ {2}/), '') + '\n'; // TODO #12071
                }
            }
            const groupRes = await extractPackageFile(groupContent);
            if (groupRes) {
                res.deps = res.deps.concat(groupRes.deps.map((dep) => ({
                    ...dep,
                    depTypes,
                    managerData: {
                        lineNumber: Number(dep.managerData.lineNumber) + groupLineNumber + 1,
                    },
                })));
            }
        }
        for (const delimiter of delimiters) {
            const sourceBlockMatch = (0, regex_1.regEx)(`^source\\s+${delimiter}(.*?)${delimiter}\\s+do` // TODO #12071
            ).exec(line);
            if (sourceBlockMatch) {
                const repositoryUrl = sourceBlockMatch[1];
                const sourceLineNumber = lineNumber;
                let sourceContent = '';
                let sourceLine = '';
                while (lineNumber < lines.length && sourceLine.trim() !== 'end') {
                    lineNumber += 1;
                    sourceLine = lines[lineNumber];
                    // istanbul ignore if
                    if (sourceLine === null || sourceLine === undefined) {
                        logger_1.logger.info({ content, fileName }, 'Undefined sourceLine');
                        sourceLine = 'end';
                    }
                    if (sourceLine !== 'end') {
                        sourceContent += sourceLine.replace((0, regex_1.regEx)(/^ {2}/), '') + '\n'; // TODO #12071
                    }
                }
                const sourceRes = await extractPackageFile(sourceContent);
                if (sourceRes) {
                    res.deps = res.deps.concat(sourceRes.deps.map((dep) => ({
                        ...dep,
                        registryUrls: [repositoryUrl],
                        managerData: {
                            lineNumber: Number(dep.managerData.lineNumber) + sourceLineNumber + 1,
                        },
                    })));
                }
            }
        }
        const platformsMatch = (0, regex_1.regEx)(/^platforms\s+(.*?)\s+do/).test(line); // TODO #12071
        if (platformsMatch) {
            const platformsLineNumber = lineNumber;
            let platformsContent = '';
            let platformsLine = '';
            while (lineNumber < lines.length && platformsLine !== 'end') {
                lineNumber += 1;
                platformsLine = lines[lineNumber];
                if (platformsLine !== 'end') {
                    platformsContent += platformsLine.replace((0, regex_1.regEx)(/^ {2}/), '') + '\n'; // TODO #12071
                }
            }
            const platformsRes = await extractPackageFile(platformsContent);
            if (platformsRes) {
                res.deps = res.deps.concat(platformsRes.deps.map((dep) => ({
                    ...dep,
                    managerData: {
                        lineNumber: Number(dep.managerData.lineNumber) + platformsLineNumber + 1,
                    },
                })));
            }
        }
        const ifMatch = (0, regex_1.regEx)(/^if\s+(.*?)/).test(line); // TODO #12071
        if (ifMatch) {
            const ifLineNumber = lineNumber;
            let ifContent = '';
            let ifLine = '';
            while (lineNumber < lines.length && ifLine !== 'end') {
                lineNumber += 1;
                ifLine = lines[lineNumber];
                if (ifLine !== 'end') {
                    ifContent += ifLine.replace((0, regex_1.regEx)(/^ {2}/), '') + '\n'; // TODO #12071
                }
            }
            const ifRes = await extractPackageFile(ifContent);
            if (ifRes) {
                res.deps = res.deps.concat(ifRes.deps.map((dep) => ({
                    ...dep,
                    managerData: {
                        lineNumber: Number(dep.managerData.lineNumber) + ifLineNumber + 1,
                    },
                })));
            }
        }
    }
    if (!res.deps.length && !res.registryUrls.length) {
        return null;
    }
    if (fileName) {
        const gemfileLock = fileName + '.lock';
        const lockContent = await (0, fs_1.readLocalFile)(gemfileLock, 'utf8');
        if (lockContent) {
            logger_1.logger.debug({ packageFile: fileName }, 'Found Gemfile.lock file');
            res.lockFiles = [gemfileLock];
            const lockedEntries = (0, locked_version_1.extractLockFileEntries)(lockContent);
            for (const dep of res.deps) {
                const lockedDepValue = lockedEntries.get(dep.depName);
                if (lockedDepValue) {
                    dep.lockedVersion = lockedDepValue;
                }
            }
            const bundledWith = (0, regex_1.regEx)(/\nBUNDLED WITH\n\s+(.*?)(\n|$)/).exec(lockContent);
            if (bundledWith) {
                res.constraints = res.constraints || {};
                res.constraints.bundler = bundledWith[1];
            }
        }
    }
    return res;
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=extract.js.map