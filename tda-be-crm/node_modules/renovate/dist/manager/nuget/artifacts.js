"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArtifacts = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const nuget_1 = require("../../datasource/nuget");
const logger_1 = require("../../logger");
const exec_1 = require("../../util/exec");
const fs_1 = require("../../util/fs");
const hostRules = (0, tslib_1.__importStar)(require("../../util/host-rules"));
const regex_1 = require("../../util/regex");
const util_1 = require("./util");
async function addSourceCmds(packageFileName, config, nugetConfigFile) {
    const { localDir } = global_1.GlobalConfig.get();
    const registries = (await (0, util_1.getConfiguredRegistries)(packageFileName, localDir)) ||
        (0, util_1.getDefaultRegistries)();
    const result = [];
    for (const registry of registries) {
        const { username, password } = hostRules.find({
            hostType: nuget_1.id,
            url: registry.url,
        });
        const registryInfo = (0, nuget_1.parseRegistryUrl)(registry.url);
        let addSourceCmd = `dotnet nuget add source ${registryInfo.feedUrl} --configfile ${nugetConfigFile}`;
        if (registry.name) {
            // Add name for registry, if known.
            addSourceCmd += ` --name ${registry.name}`;
        }
        if (username && password) {
            // Add registry credentials from host rules, if configured.
            addSourceCmd += ` --username ${username} --password ${password} --store-password-in-clear-text`;
        }
        result.push(addSourceCmd);
    }
    return result;
}
async function runDotnetRestore(packageFileName, config) {
    const execOptions = {
        docker: {
            image: 'dotnet',
        },
    };
    const nugetCacheDir = await (0, fs_1.ensureCacheDir)('nuget');
    const nugetConfigDir = (0, path_1.join)(nugetCacheDir, `${(0, util_1.getRandomString)()}`);
    const nugetConfigFile = (0, path_1.join)(nugetConfigDir, `nuget.config`);
    await (0, fs_1.outputFile)(nugetConfigFile, `<?xml version="1.0" encoding="utf-8"?>\n<configuration>\n</configuration>\n`);
    const cmds = [
        ...(await addSourceCmds(packageFileName, config, nugetConfigFile)),
        `dotnet restore ${packageFileName} --force-evaluate --configfile ${nugetConfigFile}`,
    ];
    logger_1.logger.debug({ cmd: cmds }, 'dotnet command');
    await (0, exec_1.exec)(cmds, execOptions);
    await (0, fs_1.remove)(nugetConfigDir);
}
async function updateArtifacts({ packageFileName, newPackageFileContent, config, updatedDeps, }) {
    logger_1.logger.debug(`nuget.updateArtifacts(${packageFileName})`);
    if (!(0, regex_1.regEx)(/(?:cs|vb|fs)proj$/i).test(packageFileName)) {
        // This could be implemented in the future if necessary.
        // It's not that easy though because the questions which
        // project file to restore how to determine which lock files
        // have been changed in such cases.
        logger_1.logger.debug({ packageFileName }, 'Not updating lock file for non project files');
        return null;
    }
    const lockFileName = (0, fs_1.getSiblingFileName)(packageFileName, 'packages.lock.json');
    const existingLockFileContent = await (0, fs_1.readLocalFile)(lockFileName, 'utf8');
    if (!existingLockFileContent) {
        logger_1.logger.debug({ packageFileName }, 'No lock file found beneath package file.');
        return null;
    }
    try {
        if (updatedDeps.length === 0 && config.isLockFileMaintenance !== true) {
            logger_1.logger.debug(`Not updating lock file because no deps changed and no lock file maintenance.`);
            return null;
        }
        await (0, fs_1.writeLocalFile)(packageFileName, newPackageFileContent);
        await runDotnetRestore(packageFileName, config);
        const newLockFileContent = await (0, fs_1.readLocalFile)(lockFileName, 'utf8');
        if (existingLockFileContent === newLockFileContent) {
            logger_1.logger.debug(`Lock file is unchanged`);
            return null;
        }
        logger_1.logger.debug('Returning updated lock file');
        return [
            {
                file: {
                    name: lockFileName,
                    contents: await (0, fs_1.readLocalFile)(lockFileName),
                },
            },
        ];
    }
    catch (err) {
        // istanbul ignore if
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        logger_1.logger.debug({ err }, 'Failed to generate lock file');
        return [
            {
                artifactError: {
                    lockFile: lockFileName,
                    stderr: err.message,
                },
            },
        ];
    }
}
exports.updateArtifacts = updateArtifacts;
//# sourceMappingURL=artifacts.js.map