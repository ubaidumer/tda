"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractDependenciesFromUpdatesReport = exports.createRenovateGradlePlugin = exports.GRADLE_DEPENDENCY_REPORT_FILENAME = void 0;
const tslib_1 = require("tslib");
const upath_1 = require("upath");
const datasourceSbtPackage = (0, tslib_1.__importStar)(require("../../../datasource/sbt-package"));
const logger_1 = require("../../../logger");
const fs_1 = require("../../../util/fs");
const regex_1 = require("../../../util/regex");
exports.GRADLE_DEPENDENCY_REPORT_FILENAME = 'gradle-renovate-report.json';
async function createRenovateGradlePlugin(gradleRoot = '.') {
    const content = `
import groovy.json.JsonOutput
import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency
import java.util.concurrent.ConcurrentLinkedQueue

def output = new ConcurrentLinkedQueue<>();

allprojects {
  tasks.register("renovate") {
    doLast {
      def project = ['project': project.name]
      output << project

      def repos = (repositories + buildscript.repositories + settings.pluginManagement.repositories)
        .findAll { it instanceof MavenArtifactRepository && it.url.scheme ==~ /https?/ }
        .collect { "$it.url" }
        .unique()
      project.repositories = repos

      def deps = (buildscript.configurations + configurations + settings.buildscript.configurations)
        .collect { it.dependencies + it.dependencyConstraints }
        .flatten()
        .findAll { it instanceof DefaultExternalModuleDependency || it instanceof DependencyConstraint }
        .findAll { 'Pinned to the embedded Kotlin' != it.reason } // Embedded Kotlin dependencies
        .collect { ['name':it.name, 'group':it.group, 'version':it.version] }
      project.dependencies = deps
    }
  }
}
gradle.buildFinished {
   def outputFile = new File('${exports.GRADLE_DEPENDENCY_REPORT_FILENAME}')
   def json = JsonOutput.toJson(output)
   outputFile.write json
}`;
    const gradleInitFile = (0, upath_1.join)(gradleRoot, 'renovate-plugin.gradle');
    logger_1.logger.debug('Creating renovate-plugin.gradle file with renovate gradle plugin');
    await (0, fs_1.writeLocalFile)(gradleInitFile, content);
}
exports.createRenovateGradlePlugin = createRenovateGradlePlugin;
async function readGradleReport(localDir) {
    const renovateReportFilename = (0, upath_1.join)(localDir, exports.GRADLE_DEPENDENCY_REPORT_FILENAME);
    if (!(await (0, fs_1.localPathExists)(renovateReportFilename))) {
        return [];
    }
    const contents = await (0, fs_1.readLocalFile)(renovateReportFilename, 'utf8');
    try {
        return JSON.parse(contents);
    }
    catch (err) {
        logger_1.logger.error({ err }, 'Invalid Gradle extract JSON');
        return [];
    }
}
function mergeDependenciesWithRepositories(project) {
    if (!project.dependencies) {
        return [];
    }
    return project.dependencies.map((dep) => ({
        ...dep,
        repos: [...project.repositories],
    }));
}
function flattenDependencies(accumulator, currentValue) {
    accumulator.push(...currentValue);
    return accumulator;
}
function combineReposOnDuplicatedDependencies(accumulator, currentValue) {
    const existingDependency = accumulator.find((dep) => dep.name === currentValue.name && dep.group === currentValue.group);
    if (existingDependency) {
        const nonExistingRepos = currentValue.repos.filter((repo) => !existingDependency.repos.includes(repo));
        existingDependency.repos.push(...nonExistingRepos);
    }
    else {
        accumulator.push(currentValue);
    }
    return accumulator;
}
function buildDependency(gradleModule) {
    return {
        name: gradleModule.name,
        depGroup: gradleModule.group,
        depName: `${gradleModule.group}:${gradleModule.name}`,
        currentValue: gradleModule.version,
        registryUrls: gradleModule.repos,
    };
}
async function extractDependenciesFromUpdatesReport(localDir) {
    const gradleProjectConfigurations = await readGradleReport(localDir);
    const dependencies = gradleProjectConfigurations
        .map(mergeDependenciesWithRepositories, [])
        .reduce(flattenDependencies, [])
        .reduce(combineReposOnDuplicatedDependencies, []);
    return dependencies
        .map((gradleModule) => buildDependency(gradleModule))
        .map((dep) => {
        /* https://github.com/renovatebot/renovate/issues/4627 */
        const { depName, currentValue } = dep;
        if (depName.endsWith('_%%')) {
            return {
                ...dep,
                depName: depName.replace((0, regex_1.regEx)(/_%%/), ''),
                datasource: datasourceSbtPackage.id,
            };
        }
        if ((0, regex_1.regEx)(/^%.*%$/).test(currentValue)) {
            // TODO #12071
            return { ...dep, skipReason: 'version-placeholder' };
        }
        return dep;
    });
}
exports.extractDependenciesFromUpdatesReport = extractDependenciesFromUpdatesReport;
//# sourceMappingURL=gradle-updates-report.js.map