"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDependency = exports.extractAllPackageFiles = exports.executeGradle = exports.GRADLE_DEPENDENCY_REPORT_OPTIONS = void 0;
const tslib_1 = require("tslib");
const upath_1 = (0, tslib_1.__importDefault)(require("upath"));
const global_1 = require("../../../config/global");
const error_messages_1 = require("../../../constants/error-messages");
const datasourceMaven = (0, tslib_1.__importStar)(require("../../../datasource/maven"));
const logger_1 = require("../../../logger");
const external_host_error_1 = require("../../../types/errors/external-host-error");
const exec_1 = require("../../../util/exec");
const fs_1 = require("../../../util/fs");
const utils_1 = require("../../gradle-wrapper/utils");
const build_gradle_1 = require("./build-gradle");
const gradle_updates_report_1 = require("./gradle-updates-report");
const utils_2 = require("./utils");
exports.GRADLE_DEPENDENCY_REPORT_OPTIONS = '--init-script renovate-plugin.gradle renovate';
const TIMEOUT_CODE = 143;
async function prepareGradleCommandFallback(gradlewName, cwd, gradlew, args) {
    const cmd = await (0, utils_1.prepareGradleCommand)(gradlewName, cwd, gradlew, args);
    if (cmd === null) {
        return `gradle ${args}`;
    }
    return cmd;
}
async function executeGradle(config, cwd, gradlew, gradleRoot = '.') {
    var _a, _b, _c;
    let stdout;
    let stderr;
    let timeout;
    if ((_a = config.gradle) === null || _a === void 0 ? void 0 : _a.timeout) {
        timeout = config.gradle.timeout * 1000;
    }
    const cmd = await prepareGradleCommandFallback((0, utils_1.gradleWrapperFileName)(), cwd, gradlew, exports.GRADLE_DEPENDENCY_REPORT_OPTIONS);
    const execOptions = {
        timeout,
        cwd,
        docker: {
            image: 'java',
            tagConstraint: (_c = (_b = config.constraints) === null || _b === void 0 ? void 0 : _b.java) !== null && _c !== void 0 ? _c : (await (0, utils_2.getDockerConstraint)(gradleRoot)),
            tagScheme: (0, utils_1.getJavaVersioning)(),
            preCommands: await (0, utils_2.getDockerPreCommands)(gradleRoot),
        },
        extraEnv: utils_1.extraEnv,
    };
    try {
        logger_1.logger.debug({ cmd }, 'Start gradle command');
        ({ stdout, stderr } = await (0, exec_1.exec)(cmd, execOptions));
    }
    catch (err) /* istanbul ignore next */ {
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        if (err.code === TIMEOUT_CODE) {
            throw new external_host_error_1.ExternalHostError(err, 'gradle');
        }
        logger_1.logger.warn({ errMessage: err.message }, 'Gradle extraction failed');
        return;
    }
    logger_1.logger.debug(stdout + stderr);
    logger_1.logger.debug('Gradle report complete');
}
exports.executeGradle = executeGradle;
async function extractAllPackageFiles(config, packageFiles) {
    let rootBuildGradle;
    let gradlew;
    const { localDir } = global_1.GlobalConfig.get();
    for (const packageFile of packageFiles) {
        const dirname = upath_1.default.dirname(packageFile);
        const gradlewPath = upath_1.default.join(dirname, (0, utils_1.gradleWrapperFileName)());
        gradlew = await (0, fs_1.stat)(upath_1.default.join(localDir, gradlewPath)).catch(() => null);
        if (['build.gradle', 'build.gradle.kts'].includes(packageFile)) {
            rootBuildGradle = packageFile;
            break;
        }
        // If there is gradlew in the same directory, the directory should be a Gradle project root
        if ((gradlew === null || gradlew === void 0 ? void 0 : gradlew.isFile()) === true) {
            rootBuildGradle = packageFile;
            break;
        }
    }
    if (!rootBuildGradle) {
        logger_1.logger.warn('No root build.gradle nor build.gradle.kts found - skipping');
        return null;
    }
    logger_1.logger.debug('Extracting dependencies from all gradle files');
    const gradleRoot = upath_1.default.dirname(rootBuildGradle);
    const cwd = upath_1.default.join(localDir, gradleRoot);
    await (0, gradle_updates_report_1.createRenovateGradlePlugin)(gradleRoot);
    await executeGradle(config, cwd, gradlew, gradleRoot);
    (0, build_gradle_1.init)();
    const dependencies = await (0, gradle_updates_report_1.extractDependenciesFromUpdatesReport)(gradleRoot);
    if (dependencies.length === 0) {
        return [];
    }
    const gradleFiles = [];
    for (const packageFile of packageFiles) {
        const content = await (0, fs_1.readLocalFile)(packageFile, 'utf8');
        // istanbul ignore else
        if (content) {
            gradleFiles.push({
                packageFile,
                datasource: datasourceMaven.id,
                deps: dependencies,
            });
            (0, build_gradle_1.collectVersionVariables)(dependencies, content);
        }
        else {
            logger_1.logger.debug({ packageFile }, 'packageFile has no content');
        }
    }
    return gradleFiles;
}
exports.extractAllPackageFiles = extractAllPackageFiles;
function buildGradleDependency(config) {
    return {
        group: config.depGroup,
        name: config.name,
        version: config.currentValue,
    };
}
function updateDependency({ fileContent, upgrade, }) {
    // prettier-ignore
    logger_1.logger.debug(`gradle.updateDependency(): packageFile:${upgrade.packageFile} depName:${upgrade.depName}, version:${upgrade.currentValue} ==> ${upgrade.newValue}`);
    return (0, build_gradle_1.updateGradleVersion)(fileContent, buildGradleDependency(upgrade), upgrade.newValue);
}
exports.updateDependency = updateDependency;
//# sourceMappingURL=index.js.map