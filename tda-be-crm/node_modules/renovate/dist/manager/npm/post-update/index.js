"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAdditionalFiles = exports.updateYarnBinary = exports.writeUpdatedPackageFiles = exports.writeExistingFiles = exports.determineLockFileDirs = void 0;
const tslib_1 = require("tslib");
const is_1 = (0, tslib_1.__importDefault)(require("@sindresorhus/is"));
const deepmerge_1 = (0, tslib_1.__importDefault)(require("deepmerge"));
const detect_indent_1 = (0, tslib_1.__importDefault)(require("detect-indent"));
const js_yaml_1 = require("js-yaml");
const upath_1 = (0, tslib_1.__importDefault)(require("upath"));
const global_1 = require("../../../config/global");
const error_messages_1 = require("../../../constants/error-messages");
const npm_1 = require("../../../datasource/npm");
const logger_1 = require("../../../logger");
const external_host_error_1 = require("../../../types/errors/external-host-error");
const env_1 = require("../../../util/exec/env");
const fs_1 = require("../../../util/fs");
const git_1 = require("../../../util/git");
const hostRules = (0, tslib_1.__importStar)(require("../../../util/host-rules"));
const regex_1 = require("../../../util/regex");
const yarn_1 = require("../extract/yarn");
const lerna = (0, tslib_1.__importStar)(require("./lerna"));
const npm = (0, tslib_1.__importStar)(require("./npm"));
const pnpm = (0, tslib_1.__importStar)(require("./pnpm"));
const rules_1 = require("./rules");
const yarn = (0, tslib_1.__importStar)(require("./yarn"));
// Strips empty values, deduplicates, and returns the directories from filenames
// istanbul ignore next
const getDirs = (arr) => Array.from(new Set(arr.filter(Boolean)));
// istanbul ignore next
function determineLockFileDirs(config, packageFiles) {
    var _a, _b, _c;
    const npmLockDirs = [];
    const yarnLockDirs = [];
    const pnpmShrinkwrapDirs = [];
    const lernaJsonFiles = [];
    for (const upgrade of config.upgrades) {
        if (upgrade.updateType === 'lockFileMaintenance' || upgrade.isRemediation) {
            // Return every directory that contains a lockfile
            if (((_a = upgrade.managerData) === null || _a === void 0 ? void 0 : _a.lernaJsonFile) && upgrade.npmLock) {
                lernaJsonFiles.push(upgrade.managerData.lernaJsonFile);
            }
            else {
                yarnLockDirs.push(upgrade.yarnLock);
                npmLockDirs.push(upgrade.npmLock);
                pnpmShrinkwrapDirs.push(upgrade.pnpmShrinkwrap);
            }
            continue;
        }
        if (upgrade.isLockfileUpdate) {
            yarnLockDirs.push(upgrade.yarnLock);
            npmLockDirs.push(upgrade.npmLock);
        }
    }
    if (config.upgrades.every((upgrade) => upgrade.updateType === 'lockFileMaintenance' || upgrade.isLockfileUpdate)) {
        return {
            yarnLockDirs: getDirs(yarnLockDirs),
            npmLockDirs: getDirs(npmLockDirs),
            pnpmShrinkwrapDirs: getDirs(pnpmShrinkwrapDirs),
            lernaJsonFiles: getDirs(lernaJsonFiles),
        };
    }
    function getPackageFile(fileName) {
        logger_1.logger.trace('Looking for packageFile: ' + fileName);
        for (const packageFile of packageFiles.npm) {
            if (packageFile.packageFile === fileName) {
                logger_1.logger.trace({ packageFile }, 'Found packageFile');
                return packageFile;
            }
            logger_1.logger.trace('No match');
        }
        return {};
    }
    for (const p of config.updatedPackageFiles) {
        logger_1.logger.trace(`Checking ${String(p.name)} for lock files`);
        const packageFile = getPackageFile(p.name);
        // lerna first
        if (((_b = packageFile.managerData) === null || _b === void 0 ? void 0 : _b.lernaJsonFile) && packageFile.npmLock) {
            logger_1.logger.debug(`${packageFile.packageFile} has lerna lock file`);
            lernaJsonFiles.push(packageFile.managerData.lernaJsonFile);
        }
        else if (((_c = packageFile.managerData) === null || _c === void 0 ? void 0 : _c.lernaJsonFile) &&
            packageFile.yarnLock &&
            !packageFile.hasYarnWorkspaces) {
            lernaJsonFiles.push(packageFile.managerData.lernaJsonFile);
        }
        else {
            // push full lock file names and convert them later
            yarnLockDirs.push(packageFile.yarnLock);
            npmLockDirs.push(packageFile.npmLock);
            pnpmShrinkwrapDirs.push(packageFile.pnpmShrinkwrap);
        }
    }
    return {
        yarnLockDirs: getDirs(yarnLockDirs),
        npmLockDirs: getDirs(npmLockDirs),
        pnpmShrinkwrapDirs: getDirs(pnpmShrinkwrapDirs),
        lernaJsonFiles: getDirs(lernaJsonFiles),
    };
}
exports.determineLockFileDirs = determineLockFileDirs;
// istanbul ignore next
async function writeExistingFiles(config, packageFiles) {
    if (!packageFiles.npm) {
        return;
    }
    const npmFiles = packageFiles.npm;
    logger_1.logger.debug({ packageFiles: npmFiles.map((n) => n.packageFile) }, 'Writing package.json files');
    const { localDir } = global_1.GlobalConfig.get();
    for (const packageFile of npmFiles) {
        const basedir = upath_1.default.join(localDir, upath_1.default.dirname(packageFile.packageFile));
        const npmrc = packageFile.npmrc || config.npmrc;
        const npmrcFilename = upath_1.default.join(basedir, '.npmrc');
        if (is_1.default.string(npmrc)) {
            try {
                await (0, fs_1.outputFile)(npmrcFilename, `${npmrc}\n`);
            }
            catch (err) /* istanbul ignore next */ {
                logger_1.logger.warn({ npmrcFilename, err }, 'Error writing .npmrc');
            }
        }
        const { npmLock } = packageFile;
        if (npmLock) {
            const npmLockPath = upath_1.default.join(localDir, npmLock);
            if (process.env.RENOVATE_REUSE_PACKAGE_LOCK === 'false' ||
                config.reuseLockFiles === false) {
                logger_1.logger.debug(`Ensuring ${npmLock} is removed`);
                await (0, fs_1.remove)(npmLockPath);
            }
            else {
                logger_1.logger.debug(`Writing ${npmLock}`);
                let existingNpmLock;
                let detectedIndent;
                let npmLockParsed;
                try {
                    existingNpmLock = await (0, git_1.getFile)(npmLock);
                    detectedIndent = (0, detect_indent_1.default)(existingNpmLock).indent || '  ';
                    npmLockParsed = JSON.parse(existingNpmLock);
                }
                catch (err) {
                    logger_1.logger.warn({ err }, 'Error parsing npm lock file');
                }
                if (npmLockParsed) {
                    const packageNames = Object.keys((npmLockParsed === null || npmLockParsed === void 0 ? void 0 : npmLockParsed.packages) || {}); // lockfileVersion=2
                    const widens = [];
                    let lockFileChanged = false;
                    for (const upgrade of config.upgrades) {
                        if (upgrade.rangeStrategy === 'widen' &&
                            upgrade.npmLock === npmLock) {
                            widens.push(upgrade.depName);
                        }
                        const { depName } = upgrade;
                        for (const packageName of packageNames) {
                            if (packageName === `node_modules/${depName}` ||
                                packageName.startsWith(`node_modules/${depName}/`)) {
                                logger_1.logger.trace({ packageName }, 'Massaging out package name');
                                lockFileChanged = true;
                                delete npmLockParsed.packages[packageName];
                            }
                        }
                    }
                    if (widens.length) {
                        logger_1.logger.debug(`Removing ${String(widens)} from ${npmLock} to force an update`);
                        lockFileChanged = true;
                        try {
                            if (npmLockParsed.dependencies) {
                                widens.forEach((depName) => {
                                    delete npmLockParsed.dependencies[depName];
                                });
                            }
                        }
                        catch (err) {
                            logger_1.logger.warn({ npmLock }, 'Error massaging package-lock.json for widen');
                        }
                    }
                    if (lockFileChanged) {
                        logger_1.logger.debug('Massaging npm lock file before writing to disk');
                        existingNpmLock = JSON.stringify(npmLockParsed, null, detectedIndent);
                    }
                    await (0, fs_1.outputFile)(npmLockPath, existingNpmLock);
                }
            }
        }
        const { yarnLock } = packageFile;
        if (yarnLock && config.reuseLockFiles === false) {
            await (0, fs_1.deleteLocalFile)(yarnLock);
        }
        // istanbul ignore next
        if (packageFile.pnpmShrinkwrap && config.reuseLockFiles === false) {
            await (0, fs_1.deleteLocalFile)(packageFile.pnpmShrinkwrap);
        }
    }
}
exports.writeExistingFiles = writeExistingFiles;
// istanbul ignore next
async function writeUpdatedPackageFiles(config) {
    logger_1.logger.trace({ config }, 'writeUpdatedPackageFiles');
    logger_1.logger.debug('Writing any updated package files');
    if (!config.updatedPackageFiles) {
        logger_1.logger.debug('No files found');
        return;
    }
    const { localDir } = global_1.GlobalConfig.get();
    for (const packageFile of config.updatedPackageFiles) {
        if (packageFile.name.endsWith('package-lock.json')) {
            logger_1.logger.debug(`Writing package-lock file: ${packageFile.name}`);
            await (0, fs_1.outputFile)(upath_1.default.join(localDir, packageFile.name), packageFile.contents);
            continue;
        }
        if (!packageFile.name.endsWith('package.json')) {
            continue;
        }
        logger_1.logger.debug(`Writing ${String(packageFile.name)}`);
        const detectedIndent = (0, detect_indent_1.default)(packageFile.contents.toString()).indent || '  ';
        const massagedFile = JSON.parse(packageFile.contents.toString());
        try {
            const { token } = hostRules.find({
                hostType: config.platform,
                url: 'https://api.github.com/',
            });
            for (const upgrade of config.upgrades) {
                if (upgrade.gitRef && upgrade.packageFile === packageFile.name) {
                    massagedFile[upgrade.depType][upgrade.depName] = massagedFile[upgrade.depType][upgrade.depName].replace('git+https://github.com', `git+https://${token}@github.com`);
                }
            }
        }
        catch (err) {
            logger_1.logger.warn({ err }, 'Error adding token to package files');
        }
        await (0, fs_1.outputFile)(upath_1.default.join(localDir, packageFile.name), JSON.stringify(massagedFile, null, detectedIndent));
    }
}
exports.writeUpdatedPackageFiles = writeUpdatedPackageFiles;
// istanbul ignore next
async function getNpmrcContent(dir) {
    const npmrcFilePath = upath_1.default.join(dir, '.npmrc');
    let originalNpmrcContent = null;
    try {
        originalNpmrcContent = await (0, fs_1.readFile)(npmrcFilePath, 'utf8');
        logger_1.logger.debug('npmrc file found in repository');
    }
    catch (_a) {
        logger_1.logger.debug('No npmrc file found in repository');
        originalNpmrcContent = null;
    }
    return originalNpmrcContent;
}
// istanbul ignore next
async function updateNpmrcContent(dir, originalContent, additionalLines) {
    const npmrcFilePath = upath_1.default.join(dir, '.npmrc');
    const newNpmrc = originalContent
        ? [originalContent, ...additionalLines]
        : additionalLines;
    try {
        const newContent = newNpmrc.join('\n');
        if (newContent !== originalContent) {
            logger_1.logger.debug(`Writing updated .npmrc file to ${npmrcFilePath}`);
            await (0, fs_1.writeFile)(npmrcFilePath, `${newContent}\n`);
        }
    }
    catch (_a) {
        logger_1.logger.warn('Unable to write custom npmrc file');
    }
}
// istanbul ignore next
async function resetNpmrcContent(dir, originalContent) {
    const npmrcFilePath = upath_1.default.join(dir, '.npmrc');
    if (originalContent) {
        try {
            await (0, fs_1.writeFile)(npmrcFilePath, originalContent);
        }
        catch (_a) {
            logger_1.logger.warn('Unable to reset npmrc to original contents');
        }
    }
    else {
        try {
            await (0, fs_1.unlink)(npmrcFilePath);
        }
        catch (_b) {
            logger_1.logger.warn('Unable to delete custom npmrc');
        }
    }
}
// istanbul ignore next
async function updateYarnOffline(lockFileDir, localDir, updatedArtifacts) {
    try {
        const resolvedPaths = [];
        const yarnrcYml = await (0, git_1.getFile)(upath_1.default.join(lockFileDir, '.yarnrc.yml'));
        const yarnrc = await (0, git_1.getFile)(upath_1.default.join(lockFileDir, '.yarnrc'));
        // As .yarnrc.yml overrides .yarnrc in Yarn 1 (https://git.io/JUcco)
        // both files may exist, so check for .yarnrc.yml first
        if (yarnrcYml) {
            // Yarn 2 (offline cache and zero-installs)
            const paths = (0, yarn_1.getZeroInstallPaths)(yarnrcYml);
            resolvedPaths.push(...paths.map((p) => upath_1.default.join(lockFileDir, p)));
        }
        else if (yarnrc) {
            // Yarn 1 (offline mirror)
            const mirrorLine = yarnrc
                .split('\n')
                .find((line) => line.startsWith('yarn-offline-mirror '));
            if (mirrorLine) {
                const mirrorPath = mirrorLine
                    .split(' ')[1]
                    .replace((0, regex_1.regEx)(/"/g), '')
                    .replace((0, regex_1.regEx)(/\/?$/), '/');
                resolvedPaths.push(upath_1.default.join(lockFileDir, mirrorPath));
            }
        }
        logger_1.logger.debug({ resolvedPaths }, 'updateYarnOffline resolvedPaths');
        if (resolvedPaths.length) {
            const status = await (0, git_1.getRepoStatus)();
            for (const f of status.modified.concat(status.not_added)) {
                if (resolvedPaths.some((p) => f.startsWith(p))) {
                    const localModified = upath_1.default.join(localDir, f);
                    updatedArtifacts.push({
                        name: f,
                        contents: await (0, fs_1.readFile)(localModified),
                    });
                }
            }
            for (const f of status.deleted || []) {
                if (resolvedPaths.some((p) => f.startsWith(p))) {
                    updatedArtifacts.push({
                        name: '|delete|',
                        contents: f,
                    });
                }
            }
        }
    }
    catch (err) {
        logger_1.logger.error({ err }, 'Error updating yarn offline packages');
    }
}
// exported for testing
async function updateYarnBinary(lockFileDir, updatedArtifacts, existingYarnrcYmlContent) {
    let yarnrcYml = existingYarnrcYmlContent;
    try {
        const yarnrcYmlFilename = upath_1.default.join(lockFileDir, '.yarnrc.yml');
        yarnrcYml || (yarnrcYml = await (0, git_1.getFile)(yarnrcYmlFilename));
        const newYarnrcYml = await (0, fs_1.readLocalFile)(yarnrcYmlFilename, 'utf8');
        if (!is_1.default.string(yarnrcYml) || !is_1.default.string(newYarnrcYml)) {
            return existingYarnrcYmlContent;
        }
        const oldYarnPath = (0, js_yaml_1.load)(yarnrcYml).yarnPath;
        const newYarnPath = (0, js_yaml_1.load)(newYarnrcYml).yarnPath;
        const oldYarnFullPath = upath_1.default.join(lockFileDir, oldYarnPath);
        const newYarnFullPath = upath_1.default.join(lockFileDir, newYarnPath);
        logger_1.logger.debug({ oldYarnPath, newYarnPath }, 'Found updated Yarn binary');
        yarnrcYml = yarnrcYml.replace(oldYarnPath, newYarnPath);
        updatedArtifacts.push({
            name: yarnrcYmlFilename,
            contents: yarnrcYml,
        }, {
            name: '|delete|',
            contents: oldYarnFullPath,
        }, {
            name: newYarnFullPath,
            contents: await (0, fs_1.readLocalFile)(newYarnFullPath, 'utf8'),
            executable: true,
        });
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.error({ err }, 'Error updating Yarn binary');
    }
    return existingYarnrcYmlContent && yarnrcYml;
}
exports.updateYarnBinary = updateYarnBinary;
// istanbul ignore next
async function getAdditionalFiles(config, packageFiles) {
    var _a, _b, _c, _d, _e, _f;
    logger_1.logger.trace({ config }, 'getAdditionalFiles');
    const artifactErrors = [];
    const updatedArtifacts = [];
    if (!((_a = packageFiles.npm) === null || _a === void 0 ? void 0 : _a.length)) {
        return { artifactErrors, updatedArtifacts };
    }
    if (!config.updateLockFiles) {
        logger_1.logger.debug('Skipping lock file generation');
        return { artifactErrors, updatedArtifacts };
    }
    if (!((_b = config.updatedPackageFiles) === null || _b === void 0 ? void 0 : _b.length) &&
        config.transitiveRemediation &&
        ((_c = config.upgrades) === null || _c === void 0 ? void 0 : _c.every((upgrade) => upgrade.isRemediation || upgrade.isVulnerabilityAlert))) {
        logger_1.logger.debug('Skipping lock file generation for remediations');
        return { artifactErrors, updatedArtifacts };
    }
    logger_1.logger.debug('Getting updated lock files');
    if (config.updateType === 'lockFileMaintenance' &&
        config.reuseExistingBranch &&
        (0, git_1.branchExists)(config.branchName)) {
        logger_1.logger.debug('Skipping lockFileMaintenance update');
        return { artifactErrors, updatedArtifacts };
    }
    const dirs = determineLockFileDirs(config, packageFiles);
    logger_1.logger.trace({ dirs }, 'lock file dirs');
    await writeExistingFiles(config, packageFiles);
    await writeUpdatedPackageFiles(config);
    const { additionalNpmrcContent, additionalYarnRcYml } = (0, rules_1.processHostRules)();
    const env = {
        ...(0, env_1.getChildProcessEnv)(),
        NPM_CONFIG_CACHE: await (0, fs_1.ensureCacheDir)('npm'),
        YARN_CACHE_FOLDER: await (0, fs_1.ensureCacheDir)('yarn'),
        YARN_GLOBAL_FOLDER: await (0, fs_1.ensureCacheDir)('berry'),
        npm_config_store: await (0, fs_1.ensureCacheDir)('pnpm'),
        NODE_ENV: 'dev',
    };
    let token = '';
    try {
        ({ token } = hostRules.find({
            hostType: config.platform,
            url: 'https://api.github.com/',
        }));
        token += '@';
    }
    catch (err) {
        logger_1.logger.warn({ err }, 'Error getting token for packageFile');
    }
    const { localDir } = global_1.GlobalConfig.get();
    for (const npmLock of dirs.npmLockDirs) {
        const lockFileDir = upath_1.default.dirname(npmLock);
        const fullLockFileDir = upath_1.default.join(localDir, lockFileDir);
        const npmrcContent = await getNpmrcContent(fullLockFileDir);
        await updateNpmrcContent(fullLockFileDir, npmrcContent, additionalNpmrcContent);
        const fileName = upath_1.default.basename(npmLock);
        logger_1.logger.debug(`Generating ${fileName} for ${lockFileDir}`);
        const upgrades = config.upgrades.filter((upgrade) => upgrade.npmLock === npmLock);
        const res = await npm.generateLockFile(fullLockFileDir, env, fileName, config, upgrades);
        if (res.error) {
            // istanbul ignore if
            if ((_d = res.stderr) === null || _d === void 0 ? void 0 : _d.includes('No matching version found for')) {
                for (const upgrade of config.upgrades) {
                    if (res.stderr.includes(`No matching version found for ${upgrade.depName}`)) {
                        logger_1.logger.debug({ dependency: upgrade.depName, type: 'npm' }, 'lock file failed for the dependency being updated - skipping branch creation');
                        const err = new Error('lock file failed for the dependency being updated - skipping branch creation');
                        throw new external_host_error_1.ExternalHostError(err, npm_1.id);
                    }
                }
            }
            artifactErrors.push({
                lockFile: npmLock,
                stderr: res.stderr,
            });
        }
        else {
            const existingContent = await (0, git_1.getFile)(npmLock, config.reuseExistingBranch ? config.branchName : config.baseBranch);
            if (res.lockFile === existingContent) {
                logger_1.logger.debug(`${npmLock} hasn't changed`);
            }
            else {
                logger_1.logger.debug(`${npmLock} needs updating`);
                updatedArtifacts.push({
                    name: npmLock,
                    contents: res.lockFile.replace((0, regex_1.regEx)(`${token}`, 'g'), ''),
                });
            }
        }
        await resetNpmrcContent(fullLockFileDir, npmrcContent);
    }
    for (const yarnLock of dirs.yarnLockDirs) {
        const lockFileDir = upath_1.default.dirname(yarnLock);
        const fullLockFileDir = upath_1.default.join(localDir, lockFileDir);
        const npmrcContent = await getNpmrcContent(fullLockFileDir);
        await updateNpmrcContent(fullLockFileDir, npmrcContent, additionalNpmrcContent);
        let yarnRcYmlFilename;
        let existingYarnrcYmlContent;
        if (additionalYarnRcYml) {
            yarnRcYmlFilename = (0, fs_1.getSiblingFileName)(yarnLock, '.yarnrc.yml');
            existingYarnrcYmlContent = await (0, fs_1.readLocalFile)(yarnRcYmlFilename, 'utf8');
            if (existingYarnrcYmlContent) {
                try {
                    const existingYarnrRcYml = (0, js_yaml_1.load)(existingYarnrcYmlContent);
                    const updatedYarnYrcYml = (0, deepmerge_1.default)(existingYarnrRcYml, additionalYarnRcYml);
                    await (0, fs_1.writeLocalFile)(yarnRcYmlFilename, (0, js_yaml_1.dump)(updatedYarnYrcYml));
                    logger_1.logger.debug('Added authentication to .yarnrc.yml');
                }
                catch (err) {
                    logger_1.logger.warn({ err }, 'Error appending .yarnrc.yml content');
                }
            }
        }
        logger_1.logger.debug(`Generating yarn.lock for ${lockFileDir}`);
        const lockFileName = upath_1.default.join(lockFileDir, 'yarn.lock');
        const upgrades = config.upgrades.filter((upgrade) => upgrade.yarnLock === yarnLock);
        const res = await yarn.generateLockFile(upath_1.default.join(localDir, lockFileDir), env, config, upgrades);
        if (res.error) {
            // istanbul ignore if
            if ((_e = res.stderr) === null || _e === void 0 ? void 0 : _e.includes(`Couldn't find any versions for`)) {
                for (const upgrade of config.upgrades) {
                    /* eslint-disable no-useless-escape */
                    if (res.stderr.includes(`Couldn't find any versions for \\\"${upgrade.depName}\\\"`)) {
                        logger_1.logger.debug({ dependency: upgrade.depName, type: 'yarn' }, 'lock file failed for the dependency being updated - skipping branch creation');
                        throw new external_host_error_1.ExternalHostError(new Error('lock file failed for the dependency being updated - skipping branch creation'), npm_1.id);
                    }
                    /* eslint-enable no-useless-escape */
                }
            }
            artifactErrors.push({
                lockFile: yarnLock,
                stderr: res.stderr || res.stdout,
            });
        }
        else {
            const existingContent = await (0, git_1.getFile)(lockFileName, config.reuseExistingBranch ? config.branchName : config.baseBranch);
            if (res.lockFile === existingContent) {
                logger_1.logger.debug("yarn.lock hasn't changed");
            }
            else {
                logger_1.logger.debug('yarn.lock needs updating');
                updatedArtifacts.push({
                    name: lockFileName,
                    contents: res.lockFile,
                });
                await updateYarnOffline(lockFileDir, localDir, updatedArtifacts);
            }
            if (upgrades.some(yarn.isYarnUpdate)) {
                existingYarnrcYmlContent = await updateYarnBinary(lockFileDir, updatedArtifacts, existingYarnrcYmlContent);
            }
        }
        await resetNpmrcContent(fullLockFileDir, npmrcContent);
        if (existingYarnrcYmlContent) {
            await (0, fs_1.writeLocalFile)(yarnRcYmlFilename, existingYarnrcYmlContent);
        }
    }
    for (const pnpmShrinkwrap of dirs.pnpmShrinkwrapDirs) {
        const lockFileDir = upath_1.default.dirname(pnpmShrinkwrap);
        const fullLockFileDir = upath_1.default.join(localDir, lockFileDir);
        const npmrcContent = await getNpmrcContent(fullLockFileDir);
        await updateNpmrcContent(fullLockFileDir, npmrcContent, additionalNpmrcContent);
        logger_1.logger.debug(`Generating pnpm-lock.yaml for ${lockFileDir}`);
        const upgrades = config.upgrades.filter((upgrade) => upgrade.pnpmShrinkwrap === pnpmShrinkwrap);
        const res = await pnpm.generateLockFile(upath_1.default.join(localDir, lockFileDir), env, config, upgrades);
        if (res.error) {
            // istanbul ignore if
            if ((_f = res.stdout) === null || _f === void 0 ? void 0 : _f.includes(`No compatible version found:`)) {
                for (const upgrade of config.upgrades) {
                    if (res.stdout.includes(`No compatible version found: ${upgrade.depName}`)) {
                        logger_1.logger.debug({ dependency: upgrade.depName, type: 'pnpm' }, 'lock file failed for the dependency being updated - skipping branch creation');
                        throw new external_host_error_1.ExternalHostError(Error('lock file failed for the dependency being updated - skipping branch creation'), npm_1.id);
                    }
                }
            }
            artifactErrors.push({
                lockFile: pnpmShrinkwrap,
                stderr: res.stderr || res.stdout,
            });
        }
        else {
            const existingContent = await (0, git_1.getFile)(pnpmShrinkwrap, config.reuseExistingBranch ? config.branchName : config.baseBranch);
            if (res.lockFile === existingContent) {
                logger_1.logger.debug("pnpm-lock.yaml hasn't changed");
            }
            else {
                logger_1.logger.debug('pnpm-lock.yaml needs updating');
                updatedArtifacts.push({
                    name: pnpmShrinkwrap,
                    contents: res.lockFile,
                });
            }
        }
        await resetNpmrcContent(fullLockFileDir, npmrcContent);
    }
    for (const lernaJsonFile of dirs.lernaJsonFiles) {
        let lockFile;
        logger_1.logger.debug(`Finding package.json for lerna location "${lernaJsonFile}"`);
        const lernaPackageFile = packageFiles.npm.find((p) => (0, fs_1.getSubDirectory)(p.packageFile) === (0, fs_1.getSubDirectory)(lernaJsonFile));
        if (!lernaPackageFile) {
            logger_1.logger.debug('No matching package.json found');
            throw new Error('lerna-no-lockfile');
        }
        if (lernaPackageFile.lernaClient === 'npm') {
            lockFile = config.npmLock || 'package-lock.json';
        }
        else {
            lockFile = config.yarnLock || 'yarn.lock';
        }
        const skipInstalls = lockFile === 'npm-shrinkwrap.json' ? false : config.skipInstalls;
        const fullLearnaFileDir = upath_1.default.join(localDir, (0, fs_1.getSubDirectory)(lernaJsonFile));
        const npmrcContent = await getNpmrcContent(fullLearnaFileDir);
        await updateNpmrcContent(fullLearnaFileDir, npmrcContent, additionalNpmrcContent);
        const res = await lerna.generateLockFiles(lernaPackageFile, fullLearnaFileDir, config, env, skipInstalls);
        // istanbul ignore else
        if (res.stderr) {
            // istanbul ignore if
            if (res.stderr.includes('ENOSPC: no space left on device')) {
                throw new Error(error_messages_1.SYSTEM_INSUFFICIENT_DISK_SPACE);
            }
            for (const upgrade of config.upgrades) {
                /* eslint-disable no-useless-escape */
                if (res.stderr.includes(`Couldn't find any versions for \\\"${upgrade.depName}\\\"`)) {
                    logger_1.logger.debug({ dependency: upgrade.depName, type: 'yarn' }, 'lock file failed for the dependency being updated - skipping branch creation');
                    throw new external_host_error_1.ExternalHostError(Error('lock file failed for the dependency being updated - skipping branch creation'), npm_1.id);
                }
                /* eslint-enable no-useless-escape */
                if (res.stderr.includes(`No matching version found for ${upgrade.depName}`)) {
                    logger_1.logger.debug({ dependency: upgrade.depName, type: 'npm' }, 'lock file failed for the dependency being updated - skipping branch creation');
                    throw new external_host_error_1.ExternalHostError(Error('lock file failed for the dependency being updated - skipping branch creation'), npm_1.id);
                }
            }
            artifactErrors.push({
                lockFile,
                stderr: res.stderr,
            });
        }
        else {
            for (const packageFile of packageFiles.npm) {
                const filename = packageFile.npmLock || packageFile.yarnLock;
                logger_1.logger.trace('Checking for ' + filename);
                const existingContent = await (0, git_1.getFile)(filename, config.reuseExistingBranch ? config.branchName : config.baseBranch);
                if (existingContent) {
                    logger_1.logger.trace('Found lock file');
                    const lockFilePath = upath_1.default.join(localDir, filename);
                    logger_1.logger.trace('Checking against ' + lockFilePath);
                    try {
                        let newContent;
                        try {
                            newContent = await (0, fs_1.readFile)(lockFilePath, 'utf8');
                        }
                        catch (err) {
                            newContent = await (0, fs_1.readFile)(lockFilePath.replace('npm-shrinkwrap.json', 'package-lock.json'), 'utf8');
                        }
                        if (newContent === existingContent) {
                            logger_1.logger.trace('File is unchanged');
                        }
                        else {
                            logger_1.logger.debug('File is updated: ' + lockFilePath);
                            updatedArtifacts.push({
                                name: filename,
                                contents: newContent,
                            });
                        }
                    }
                    catch (err) {
                        if (config.updateType === 'lockFileMaintenance') {
                            logger_1.logger.debug({ packageFile, lockFilePath }, 'No lock file found after lerna lockFileMaintenance');
                        }
                        else {
                            logger_1.logger.warn({ packageFile, lockFilePath }, 'No lock file found after lerna bootstrap');
                        }
                    }
                }
                else {
                    logger_1.logger.trace('No lock file found');
                }
            }
        }
        await resetNpmrcContent(fullLearnaFileDir, npmrcContent);
    }
    return { artifactErrors, updatedArtifacts };
}
exports.getAdditionalFiles = getAdditionalFiles;
//# sourceMappingURL=index.js.map