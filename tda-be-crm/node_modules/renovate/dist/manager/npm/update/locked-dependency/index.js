"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateLockedDependency = exports.validateInputs = void 0;
const tslib_1 = require("tslib");
const detect_indent_1 = (0, tslib_1.__importDefault)(require("detect-indent"));
const logger_1 = require("../../../../logger");
const npm_1 = require("../../../../versioning/npm");
const dependency_1 = require("../dependency");
const dep_constraints_1 = require("./dep-constraints");
const get_locked_1 = require("./get-locked");
const parent_version_1 = require("./parent-version");
function validateInputs(config) {
    const { currentVersion, newVersion, lockFile } = config;
    if (!lockFile.endsWith('package-lock.json')) {
        logger_1.logger.debug({ lockFile }, 'Unsupported lock file');
        return false;
    }
    if (!(npm_1.api.isVersion(currentVersion) && npm_1.api.isVersion(newVersion))) {
        logger_1.logger.warn({ config }, 'Update versions are not valid');
        return false;
    }
    return true;
}
exports.validateInputs = validateInputs;
async function updateLockedDependency(config, isParentUpdate = false) {
    const { depName, currentVersion, newVersion, packageFile, packageFileContent, lockFile, lockFileContent, } = config;
    logger_1.logger.debug(`npm.updateLockedDependency: ${depName}@${currentVersion} -> ${newVersion} [${lockFile}]`);
    try {
        if (!validateInputs(config)) {
            return null;
        }
        let packageJson;
        let packageLockJson;
        const detectedIndent = (0, detect_indent_1.default)(lockFileContent).indent || '  ';
        let newPackageJsonContent;
        try {
            packageJson = JSON.parse(packageFileContent);
            packageLockJson = JSON.parse(lockFileContent);
        }
        catch (err) {
            logger_1.logger.warn({ err }, 'Failed to parse files');
            return null;
        }
        if (packageLockJson.lockfileVersion === 2) {
            logger_1.logger.debug('Only lockfileVersion 1 is supported');
            return null;
        }
        const lockedDeps = (0, get_locked_1.getLockedDependencies)(packageLockJson, depName, currentVersion);
        if (!lockedDeps.length) {
            logger_1.logger.debug(`${depName}@${currentVersion} not found in ${lockFile} - no work to do`);
            // Don't return null if we're a parent update or else the whole update will fail
            // istanbul ignore if: too hard to replicate
            if (isParentUpdate) {
                const res = {};
                res[packageFile] = packageFileContent;
                res[lockFile] = lockFileContent;
                return res;
            }
            return null;
        }
        logger_1.logger.debug(`Found matching dependencies with length ${lockedDeps.length}`);
        const constraints = (0, dep_constraints_1.findDepConstraints)(packageJson, packageLockJson, depName, currentVersion, newVersion);
        logger_1.logger.trace({ deps: lockedDeps, constraints }, 'Matching details');
        if (!constraints.length) {
            logger_1.logger.info({ depName, currentVersion, newVersion }, 'Could not find constraints for the locked dependency - cannot remediate');
            return null;
        }
        const parentUpdates = [];
        for (const { parentDepName, parentVersion, constraint, depType, } of constraints) {
            if (npm_1.api.matches(newVersion, constraint)) {
                // Parent dependency is compatible with the new version we want
                logger_1.logger.debug(`${depName} can be updated to ${newVersion} in-range with matching constraint "${constraint}" in ${parentDepName ? `${parentDepName}@${parentVersion}` : packageFile}`);
            }
            else if (parentDepName && parentVersion) {
                // Parent dependency needs updating too
                const parentNewVersion = await (0, parent_version_1.findFirstParentVersion)(parentDepName, parentVersion, depName, newVersion);
                if (parentNewVersion) {
                    if (parentNewVersion === parentVersion) {
                        logger_1.logger.debug(`Update of ${depName} to ${newVersion} already achieved in parent ${parentDepName}@${parentNewVersion}`);
                    }
                    else {
                        // Update the parent dependency so that we can update this dependency
                        logger_1.logger.debug(`Update of ${depName} to ${newVersion} can be achieved due to parent ${parentDepName}`);
                        const parentUpdate = {
                            depName: parentDepName,
                            currentVersion: parentVersion,
                            newVersion: parentNewVersion,
                        };
                        parentUpdates.push(parentUpdate);
                    }
                }
                else {
                    // For some reason it's not possible to update the parent to a version compatible with our desired dep version
                    logger_1.logger.debug(`Update of ${depName} to ${newVersion} cannot be achieved due to parent ${parentDepName}`);
                    return null;
                }
            }
            else if (depType) {
                // The constaint comes from the package.json file, so we need to update it
                const newValue = npm_1.api.getNewValue({
                    currentValue: constraint,
                    rangeStrategy: 'replace',
                    currentVersion,
                    newVersion,
                });
                newPackageJsonContent = (0, dependency_1.updateDependency)({
                    fileContent: packageFileContent,
                    upgrade: { depName, depType, newValue },
                });
            }
        }
        for (const dependency of lockedDeps) {
            // Remove resolved and integrity fields for npm to fill in
            dependency.version = newVersion;
            delete dependency.resolved;
            delete dependency.integrity;
        }
        let newLockFileContent = JSON.stringify(packageLockJson, null, detectedIndent);
        // iterate through the parent updates first
        for (const parentUpdate of parentUpdates) {
            const parentUpdateConfig = {
                ...config,
                lockFileContent: newLockFileContent,
                packageFileContent: newPackageJsonContent || packageFileContent,
                ...parentUpdate,
            };
            const parentUpdateResult = await updateLockedDependency(parentUpdateConfig, true);
            // istanbul ignore if: hard to test due to recursion
            if (!parentUpdateResult) {
                logger_1.logger.debug(`Update of ${depName} to ${newVersion} impossible due to failed update of parent ${parentUpdate.depName} to ${parentUpdate.newVersion}`);
                return null;
            }
            newPackageJsonContent =
                parentUpdateResult[packageFile] || newPackageJsonContent;
            newLockFileContent = parentUpdateResult[lockFile] || newLockFileContent;
        }
        const files = {};
        if (newLockFileContent) {
            files[lockFile] = newLockFileContent;
        }
        if (newPackageJsonContent) {
            files[packageFile] = newPackageJsonContent;
        }
        return files;
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.error({ err }, 'updateLockedDependency() error');
        return null;
    }
}
exports.updateLockedDependency = updateLockedDependency;
//# sourceMappingURL=index.js.map