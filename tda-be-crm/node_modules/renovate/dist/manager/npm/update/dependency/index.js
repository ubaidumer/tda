"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDependency = void 0;
const dequal_1 = require("dequal");
const logger_1 = require("../../../../logger");
const string_1 = require("../../../../util/string");
function replaceAsString(parsedContents, fileContent, depType, depName, oldValue, newValue) {
    if (depType === 'packageManager') {
        parsedContents[depType] = newValue;
    }
    else if (depName === oldValue) {
        // The old value is the name of the dependency itself
        delete Object.assign(parsedContents[depType], {
            [newValue]: parsedContents[depType][oldValue],
        })[oldValue];
    }
    else {
        // The old value is the version of the dependency
        parsedContents[depType][depName] = newValue;
    }
    // Look for the old version number
    const searchString = `"${oldValue}"`;
    const newString = `"${newValue}"`;
    // Skip ahead to depType section
    let searchIndex = fileContent.indexOf(`"${depType}"`) + depType.length;
    logger_1.logger.trace(`Starting search at index ${searchIndex}`);
    // Iterate through the rest of the file
    for (; searchIndex < fileContent.length; searchIndex += 1) {
        // First check if we have a hit for the old version
        if ((0, string_1.matchAt)(fileContent, searchIndex, searchString)) {
            logger_1.logger.trace(`Found match at index ${searchIndex}`);
            // Now test if the result matches
            const testContent = (0, string_1.replaceAt)(fileContent, searchIndex, searchString, newString);
            // Compare the parsed JSON structure of old and new
            if ((0, dequal_1.dequal)(parsedContents, JSON.parse(testContent))) {
                return testContent;
            }
        }
    }
    // istanbul ignore next
    throw new Error();
}
function updateDependency({ fileContent, upgrade, }) {
    const { depType, managerData } = upgrade;
    const depName = (managerData === null || managerData === void 0 ? void 0 : managerData.key) || upgrade.depName;
    let { newValue } = upgrade;
    if (upgrade.currentRawValue) {
        if (upgrade.currentDigest) {
            logger_1.logger.debug('Updating package.json git digest');
            newValue = upgrade.currentRawValue.replace(upgrade.currentDigest, upgrade.newDigest.substring(0, upgrade.currentDigest.length));
        }
        else {
            logger_1.logger.debug('Updating package.json git version tag');
            newValue = upgrade.currentRawValue.replace(upgrade.currentValue, upgrade.newValue);
        }
    }
    if (upgrade.npmPackageAlias) {
        newValue = `npm:${upgrade.lookupName}@${newValue}`;
    }
    logger_1.logger.debug(`npm.updateDependency(): ${depType}.${depName} = ${newValue}`);
    try {
        const parsedContents = JSON.parse(fileContent);
        // Save the old version
        let oldVersion;
        if (depType === 'packageManager') {
            oldVersion = parsedContents[depType];
            newValue = `${depName}@${newValue}`;
        }
        else {
            oldVersion = parsedContents[depType][depName];
        }
        if (oldVersion === newValue) {
            logger_1.logger.trace('Version is already updated');
            return fileContent;
        }
        let newFileContent = replaceAsString(parsedContents, fileContent, depType, depName, oldVersion, newValue);
        if (upgrade.newName) {
            newFileContent = replaceAsString(parsedContents, newFileContent, depType, depName, depName, upgrade.newName);
        }
        // istanbul ignore if
        if (!newFileContent) {
            logger_1.logger.debug({ fileContent, parsedContents, depType, depName, newValue }, 'Warning: updateDependency error');
            return fileContent;
        }
        if (parsedContents === null || parsedContents === void 0 ? void 0 : parsedContents.resolutions) {
            let depKey;
            if (parsedContents.resolutions[depName]) {
                depKey = depName;
            }
            else if (parsedContents.resolutions[`**/${depName}`]) {
                depKey = `**/${depName}`;
            }
            if (depKey) {
                // istanbul ignore if
                if (parsedContents.resolutions[depKey] !== oldVersion) {
                    logger_1.logger.debug({
                        depName,
                        depKey,
                        oldVersion,
                        resolutionsVersion: parsedContents.resolutions[depKey],
                    }, 'Upgraded dependency exists in yarn resolutions but is different version');
                }
                newFileContent = replaceAsString(parsedContents, newFileContent, 'resolutions', depKey, parsedContents.resolutions[depKey], newValue);
                if (upgrade.newName) {
                    if (depKey === `**/${depName}`) {
                        // handles the case where a replacement is in a resolution
                        upgrade.newName = `**/${upgrade.newName}`;
                    }
                    newFileContent = replaceAsString(parsedContents, newFileContent, 'resolutions', depKey, depKey, upgrade.newName);
                }
            }
        }
        return newFileContent;
    }
    catch (err) {
        logger_1.logger.debug({ err }, 'updateDependency error');
        return null;
    }
}
exports.updateDependency = updateDependency;
//# sourceMappingURL=index.js.map