"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = void 0;
const tslib_1 = require("tslib");
const pypi_1 = require("../../datasource/pypi");
const regex_1 = require("../../util/regex");
const pep440_1 = (0, tslib_1.__importDefault)(require("../../versioning/pep440"));
function getSectionName(str) {
    const [, sectionName] = (0, regex_1.regEx)(/^\[\s*([^\s]+)\s*]\s*$/).exec(str) || []; // TODO #12071
    return sectionName;
}
function getSectionRecord(str) {
    const [, sectionRecord] = (0, regex_1.regEx)(/^([^\s]+)\s+=/).exec(str) || []; // TODO #12071
    return sectionRecord;
}
function getDepType(section, record) {
    if (section === 'options') {
        if (record === 'install_requires') {
            return 'install';
        }
        if (record === 'setup_requires') {
            return 'setup';
        }
        if (record === 'tests_require') {
            return 'test';
        }
    }
    return 'extra';
}
function parseDep(line, section, record) {
    const [, depName, , currentValue] = (0, regex_1.regEx)(/\s+([-_a-zA-Z0-9]*)(\[.*\])?\s*(.*)/).exec(line) || [];
    if (section &&
        record &&
        depName &&
        currentValue &&
        pep440_1.default.isValid(currentValue)) {
        const dep = {
            datasource: pypi_1.PypiDatasource.id,
            depName,
            currentValue,
        };
        const depType = getDepType(section, record);
        if (depType) {
            dep.depType = depType;
        }
        return dep;
    }
    return null;
}
function extractPackageFile(content) {
    let sectionName = null;
    let sectionRecord = null;
    const deps = [];
    content
        .split('\n')
        .map((line) => line.replace((0, regex_1.regEx)(/[;#].*$/), '').trimRight()) // TODO #12071
        .forEach((rawLine) => {
        let line = rawLine;
        const newSectionName = getSectionName(line);
        const newSectionRecord = getSectionRecord(line);
        if (newSectionName) {
            sectionName = newSectionName;
        }
        else {
            if (newSectionRecord) {
                sectionRecord = newSectionRecord;
                line = rawLine.replace((0, regex_1.regEx)(/^[^=]*=\s*/), '\t'); // TODO #12071
            }
            const dep = parseDep(line, sectionName, sectionRecord);
            if (dep) {
                deps.push(dep);
            }
        }
    });
    return deps.length > 0 ? { deps } : null;
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=extract.js.map