"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLessThanRange = exports.getNewValue = void 0;
const pep440_1 = require("@renovate/pep440");
const specifier_1 = require("@renovate/pep440/lib/specifier");
const version_1 = require("@renovate/pep440/lib/version");
const logger_1 = require("../../logger");
const regex_1 = require("../../util/regex");
function getFutureVersion(baseVersion, newVersion, step) {
    const toRelease = (0, version_1.parse)(newVersion).release;
    const baseRelease = (0, version_1.parse)(baseVersion).release;
    let found = false;
    const futureRelease = baseRelease.map((basePart, index) => {
        if (found) {
            return 0;
        }
        const toPart = toRelease[index] || 0;
        if (toPart > basePart) {
            found = true;
            return toPart + step;
        }
        return toPart;
    });
    if (!found) {
        futureRelease[futureRelease.length - 1] += step;
    }
    return futureRelease.join('.');
}
function getNewValue({ currentValue, rangeStrategy, currentVersion, newVersion, }) {
    // easy pin
    if (rangeStrategy === 'pin') {
        return '==' + newVersion;
    }
    if (currentValue === currentVersion) {
        return newVersion;
    }
    const ranges = (0, specifier_1.parse)(currentValue);
    if (!ranges) {
        logger_1.logger.warn({ currentValue }, 'Invalid pep440 currentValue');
        return null;
    }
    if (!ranges.length) {
        // an empty string is an allowed value for PEP440 range
        // it means get any version
        logger_1.logger.warn('Empty currentValue: ' + currentValue);
        return currentValue;
    }
    if (rangeStrategy === 'auto' || rangeStrategy === 'replace') {
        if ((0, pep440_1.satisfies)(newVersion, currentValue)) {
            return currentValue;
        }
    }
    if (!['replace', 'bump'].includes(rangeStrategy)) {
        logger_1.logger.debug('Unsupported rangeStrategy: ' +
            rangeStrategy +
            '. Using "replace" instead.');
        return getNewValue({
            currentValue,
            rangeStrategy: 'replace',
            currentVersion,
            newVersion,
        });
    }
    if (ranges.some((range) => range.operator === '===')) {
        // the operator "===" is used for legacy non PEP440 versions
        logger_1.logger.warn({ currentValue }, 'PEP440 arbitrary equality (===) not supported');
        return null;
    }
    let result = ranges
        .map((range) => {
        // used to exclude versions,
        // we assume that's for a good reason
        if (range.operator === '!=') {
            return range.operator + range.version;
        }
        // used to mark minimum supported version
        if (['>', '>='].includes(range.operator)) {
            if ((0, pep440_1.lte)(newVersion, range.version)) {
                // this looks like a rollback
                return '>=' + newVersion;
            }
            // this is similar to ~=
            if (rangeStrategy === 'bump' && range.operator === '>=') {
                return range.operator + newVersion;
            }
            // otherwise treat it same as exclude
            return range.operator + range.version;
        }
        // this is used to exclude future versions
        if (range.operator === '<') {
            // if newVersion is that future version
            if ((0, pep440_1.gte)(newVersion, range.version)) {
                // now here things get tricky
                // we calculate the new future version
                const futureVersion = getFutureVersion(range.version, newVersion, 1);
                return range.operator + futureVersion;
            }
            // otherwise treat it same as exclude
            return range.operator + range.version;
        }
        // keep the .* suffix
        if (range.prefix) {
            const futureVersion = getFutureVersion(range.version, newVersion, 0);
            return range.operator + futureVersion + '.*';
        }
        if (['==', '~=', '<='].includes(range.operator)) {
            return range.operator + newVersion;
        }
        // unless PEP440 changes, this won't happen
        // istanbul ignore next
        logger_1.logger.error({ newVersion, currentValue, range }, 'pep440: failed to process range');
        // istanbul ignore next
        return null;
    })
        .filter(Boolean)
        .join(', ');
    if (result.includes(', ') && !currentValue.includes(', ')) {
        result = result.replace((0, regex_1.regEx)(/, /g), ',');
    }
    if (!(0, pep440_1.satisfies)(newVersion, result)) {
        // we failed at creating the range
        logger_1.logger.warn({ result, newVersion, currentValue }, 'pep440: failed to calculate newValue');
        return null;
    }
    return result;
}
exports.getNewValue = getNewValue;
function isLessThanRange(input, range) {
    try {
        let invertResult = true;
        const results = range
            .split(',')
            .map((x) => x
            .replace((0, regex_1.regEx)(/\s*/g), '') // TODO #12071
            .split((0, regex_1.regEx)(/(~=|==|!=|<=|>=|<|>|===)/)) // TODO #12071
            .slice(1))
            .map(([op, version]) => {
            if (['!=', '<=', '<'].includes(op)) {
                return true;
            }
            invertResult = false;
            if (['~=', '==', '>=', '==='].includes(op)) {
                return (0, pep440_1.lt)(input, version);
            }
            if (op === '>') {
                return (0, pep440_1.lte)(input, version);
            }
            // istanbul ignore next
            return false;
        });
        const result = results.every((res) => res === true);
        return invertResult ? !result : result;
    }
    catch (err) /* istanbul ignore next */ {
        return false;
    }
}
exports.isLessThanRange = isLessThanRange;
//# sourceMappingURL=range.js.map