"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.api = exports.isValid = exports.supportedRangeStrategies = exports.supportsRanges = exports.urls = exports.displayName = exports.id = void 0;
const semver_utils_1 = require("semver-utils");
const logger_1 = require("../../logger");
const npm_1 = require("../npm");
const patterns_1 = require("./patterns");
const transform_1 = require("./transform");
exports.id = 'poetry';
exports.displayName = 'Poetry';
exports.urls = ['https://python-poetry.org/docs/versions/'];
exports.supportsRanges = true;
exports.supportedRangeStrategies = ['bump', 'extend', 'pin', 'replace'];
function equals(a, b) {
    return npm_1.api.equals((0, transform_1.poetry2semver)(a), (0, transform_1.poetry2semver)(b));
}
function getMajor(version) {
    return npm_1.api.getMajor((0, transform_1.poetry2semver)(version));
}
function getMinor(version) {
    return npm_1.api.getMinor((0, transform_1.poetry2semver)(version));
}
function getPatch(version) {
    return npm_1.api.getPatch((0, transform_1.poetry2semver)(version));
}
function isVersion(input) {
    return patterns_1.VERSION_PATTERN.test(input);
}
function isGreaterThan(a, b) {
    return npm_1.api.isGreaterThan((0, transform_1.poetry2semver)(a), (0, transform_1.poetry2semver)(b));
}
function isLessThanRange(version, range) {
    return (isVersion(version) &&
        npm_1.api.isLessThanRange((0, transform_1.poetry2semver)(version), (0, transform_1.poetry2npm)(range)));
}
function isValid(input) {
    return npm_1.api.isValid((0, transform_1.poetry2npm)(input));
}
exports.isValid = isValid;
function isStable(version) {
    return npm_1.api.isStable((0, transform_1.poetry2semver)(version));
}
function matches(version, range) {
    return (isVersion(version) && npm_1.api.matches((0, transform_1.poetry2semver)(version), (0, transform_1.poetry2npm)(range)));
}
function getSatisfyingVersion(versions, range) {
    return (0, transform_1.semver2poetry)(npm_1.api.getSatisfyingVersion(versions.map((version) => (0, transform_1.poetry2semver)(version)), (0, transform_1.poetry2npm)(range)));
}
function minSatisfyingVersion(versions, range) {
    return (0, transform_1.semver2poetry)(npm_1.api.minSatisfyingVersion(versions.map((version) => (0, transform_1.poetry2semver)(version)), (0, transform_1.poetry2npm)(range)));
}
function isSingleVersion(constraint) {
    return ((constraint.trim().startsWith('=') &&
        isVersion(constraint.trim().substring(1).trim())) ||
        isVersion(constraint.trim()));
}
function handleShort(operator, currentValue, newVersion) {
    const toVersionMajor = getMajor(newVersion);
    const toVersionMinor = getMinor(newVersion);
    const split = currentValue.split('.');
    if (split.length === 1) {
        // [^,~]4
        return `${operator}${toVersionMajor}`;
    }
    if (split.length === 2) {
        // [^,~]4.1
        return `${operator}${toVersionMajor}.${toVersionMinor}`;
    }
    return null;
}
function getNewValue({ currentValue, rangeStrategy, currentVersion, newVersion, }) {
    var _a, _b;
    if (rangeStrategy === 'replace') {
        const npmCurrentValue = (0, transform_1.poetry2npm)(currentValue);
        try {
            const massagedNewVersion = (0, transform_1.poetry2semver)(newVersion);
            if (isVersion(massagedNewVersion) &&
                npm_1.api.matches(massagedNewVersion, npmCurrentValue)) {
                return currentValue;
            }
        }
        catch (err) /* istanbul ignore next */ {
            logger_1.logger.info({ err }, 'Poetry versioning: Error caught checking if newVersion satisfies currentValue');
        }
        const parsedRange = (0, semver_utils_1.parseRange)(npmCurrentValue);
        const element = parsedRange[parsedRange.length - 1];
        if (parsedRange.length === 1 && element.operator) {
            if (element.operator === '^') {
                const version = handleShort('^', npmCurrentValue, newVersion);
                if (version) {
                    return (0, transform_1.npm2poetry)(version);
                }
            }
            if (element.operator === '~') {
                const version = handleShort('~', npmCurrentValue, newVersion);
                if (version) {
                    return (0, transform_1.npm2poetry)(version);
                }
            }
        }
    }
    // Explicitly check whether this is a fully-qualified version
    if ((((_b = (_a = patterns_1.VERSION_PATTERN.exec(newVersion)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.release) || '').split('.')
        .length !== 3) {
        logger_1.logger.debug('Cannot massage python version to npm - returning currentValue');
        return currentValue;
    }
    try {
        const newSemver = npm_1.api.getNewValue({
            currentValue: (0, transform_1.poetry2npm)(currentValue),
            rangeStrategy,
            currentVersion: (0, transform_1.poetry2semver)(currentVersion),
            newVersion: (0, transform_1.poetry2semver)(newVersion),
        });
        const newPoetry = (0, transform_1.npm2poetry)(newSemver);
        return newPoetry;
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.debug({ currentValue, rangeStrategy, currentVersion, newVersion, err }, 'Could not generate new value using npm.getNewValue()');
        return currentValue;
    }
}
function sortVersions(a, b) {
    return npm_1.api.sortVersions((0, transform_1.poetry2semver)(a), (0, transform_1.poetry2semver)(b));
}
exports.api = {
    equals,
    getMajor,
    getMinor,
    getPatch,
    getNewValue,
    getSatisfyingVersion,
    isCompatible: isVersion,
    isGreaterThan,
    isLessThanRange,
    isSingleVersion,
    isStable,
    isValid,
    isVersion,
    matches,
    minSatisfyingVersion,
    sortVersions,
};
exports.default = exports.api;
//# sourceMappingURL=index.js.map